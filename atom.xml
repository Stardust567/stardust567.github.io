<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star Trail</title>
  
  <subtitle>stardust1084062596@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stardust567.github.io/"/>
  <updated>2020-05-27T14:14:43.665Z</updated>
  <id>https://stardust567.github.io/</id>
  
  <author>
    <name>Stardust567</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python异步编程</title>
    <link href="https://stardust567.github.io/post/92c.html"/>
    <id>https://stardust567.github.io/post/92c.html</id>
    <published>2020-05-24T04:24:06.000Z</published>
    <updated>2020-05-27T14:14:43.665Z</updated>
    
    <content type="html"><![CDATA[<p>python由于GIL（全局锁）的存在，不能发挥多核的优势，这点一直饱受诟病。不过在IO密集型的网络编程里，异步处理比同步处理能提升成百上千倍的效率，弥补了python性能方面的短板。<a id="more"></a></p><div class="table-container"><table><thead><tr><th style="text-align:left">并发类型</th><th style="text-align:left">切换决策</th><th style="text-align:left">处理器数量</th></tr></thead><tbody><tr><td style="text-align:left">抢占式多任务处理（<code>threading</code>）</td><td style="text-align:left">操作系统决定何时切换Python外部的任务</td><td style="text-align:left">1个</td></tr><tr><td style="text-align:left">合作多任务处理（<code>asyncio</code>）</td><td style="text-align:left">由任务自身决定何时放弃控制权</td><td style="text-align:left">1个</td></tr><tr><td style="text-align:left">多进程并行处理（<code>multiprocessing</code>）</td><td style="text-align:left">所有进程都同时在不同的处理器上运行</td><td style="text-align:left">many</td></tr></tbody></table></div><p>事实上，因为GIL的存在，thread哪怕操作系统这边一切ok，抢不到GIL锁还是白搭，多核跑多线程python属实不太行。用process跑多核，要申请的资源开销还是比较大的。coroutine底层是单线程，虽然开销小，但没法用多核。那么，我们组合一下呗，采取多进程+协程的模式，皆大欢喜。不过考虑到GIL在遇到IO操作时会主动释放，所以python多线程也不是说不能用，只是说对耗CPU的操作不适合。</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><p>用过scrapy的想必都对yield不陌生，generator是一个标准的python协程，由<code>yield</code>实现<strong>return+暂定</strong>的功能，<code>next</code>实现<strong>再次调用</strong>的功能，<code>send</code>实现<strong>再次调用+yield传值</strong>的功能。以最简单的生产者消费者举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(n, consumer)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">"producting:"</span>, i)</span><br><span class="line">        consumer.send(i) </span><br><span class="line">        <span class="comment"># 将i发送到yield位置并从该位置调用生成器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">        i = <span class="keyword">yield</span> <span class="keyword">True</span></span><br><span class="line">        print(<span class="string">"consuming:"</span>, i)</span><br><span class="line"></span><br><span class="line">c = consumer() <span class="comment"># 一个生成器实例</span></span><br><span class="line">next(c) <span class="comment"># 先让c到第一次yield处，不然没法接收send</span></span><br><span class="line">producer(<span class="number">10</span>, c) <span class="comment"># 调用生产者函数</span></span><br></pre></td></tr></table></figure><blockquote><p>没有<code>next(c)</code>是会报错的哦：TypeError: can’t send non-None value to a just-started generator</p></blockquote><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>在聊asyncio异步编程之前，我们先来聊聊I/O的经典模型和多路复用。</p><h2 id="unix下I-O模型"><a href="#unix下I-O模型" class="headerlink" title="unix下I/O模型"></a>unix下I/O模型</h2><p>5中IO模型：阻塞式IO、非阻塞IO、IO复用、信号驱动式IO、异步IO（POSIX的aio_系列函数）</p><p>同步：代码调用IO操作时，必须等IO完成才返回的调用方式。<br>异步：代码调用IO操作时，不必等IO完成就返回的调用方式。</p><p>阻塞：调用函数时，当前线程被挂起，<strong>但不会消耗CPU资源</strong>。<br>非阻塞：调用函数时，当前进程不会被挂起，而是立即返回。</p><h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>阻塞式I/O是我们最常写的I/O方式，直观简单。比如TCP socket编程常用的<code>connect()</code>、<code>recv()</code>等都是经典的阻塞式I/O，即当前服务会一直等待这些函数返回再继续往下进行。</p><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><p>对于<code>client.connect()</code>、<code>client.recv()</code>这种，可以在之前声明<code>client.setblocking(False)</code>，这样当访问到相关函数时不管有没有完成，都会立即返回。但这样容易出问题，比如connect没完成三次握手就被返回运行到send语句时会直接抛出异常。为了避免这种情况，需要while循环不停地检查状态，不停询问连接是否建立好。</p><p>所以非阻塞I/O适用下面代码不依赖于connect连接的场景，比如计算任务或者发起其他连接请求。</p><h3 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>通过一种机制，<strong>一个进程可以监视多个描述符</strong>（文件/socket）一旦某个描述符就绪（可读/写），能够通知程序进行相应的读写操作。不过select、poll、epoll本质都是同步I/O，需要在读写事件就绪后自己负责读写，即这个读写过程是阻塞的。而异步I/O是在数据从内核拷贝到用户空间后才通知用户进行处理。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>调用select后会<strong>阻塞</strong>，直到有描述符就绪（可读readfds/写writefds或异常exceptfds）或者超时，函数返回。当select返回后，可以通过<strong>遍历</strong>fdset来找到就绪的描述符。但是select单个进程能监视的文件描述符的数量存在<strong>最大限制</strong>（linux上一般为1024）</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>不同于select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。pollfd包含了要监视的event和发生的event，不再使用select的“参数-值”传递方式。同时，pollfd<strong>没有最大数量限制</strong>。但和select一样，return后还是需要<strong>轮询</strong>pollfd来获取就绪的描述符。因为事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，由此随着监视的描述符数量增长，效率会线性下降。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是linux下关于poll的提升版，epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个时间表中，这样在用户空间和内空间的copy只需一次。epoll底层采用红黑树的数据结构，性能蛮高，最大的优点就是<strong>不再轮询所有描述符</strong>(N)，只需要查看相关描述符(k)就可，把复杂度从O(N)降到了常数级O(k)，所以它适用于高并发但连接活跃度低的情况，比如浏览网页。但是如果并发性不高但连接活跃度高的话，还是select比较合适一点，比如连线游戏。</p><h1 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h1><p>asyncio在python3.4版本引入到标准库，python3.5又加入了async/await特性。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><code>asyncio</code> 最大特点就是，底层只有一个线程，多个任务分享运行时间，即多任务并发。asyncio 允许异步任务交出执行权给其他任务，等到其他任务完成，再收回执行权继续往下执行。作为协程，用户态控制切换，所以和线程比省去了切换的开销，当然切换时候还是会保存上下文和栈（<em>协程的栈空间是可以动态调整的</em>）可以无锁。</p><p>asyncio 模块在单线程上启动一个事件循环（event loop），时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事件循环event_loop：程序会开启一个无限循环，我们把一些函数注册到循环上。</p><p>如果一个对象可以在<code>await</code>语句中使用，则称该对象为awaitable objec，即可等待对象。<br>常用的可等待对象有两种，分别是协程 <strong>coroutines</strong> 和任务 <strong>Tasks</strong> （还有Future但和Task差不多）</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>这里的<strong>coroutines</strong>指<strong>协程函数</strong>（形式为<code>async def</code>的函数）和<strong>协程对象</strong>（调用协程函数所返回的对象）</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>一个协程可以通过<code>asyncio.create_task()</code>被打包为一个Task，该协程自动排入队列准备立即运行。</p><p>但我个人觉得除非需要调用task类的方法，一把没必要<code>task = asyncio.create_task(cor)</code>封装。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>Python遇到<code>await f()</code>时：在等到<code>f()</code>return之前，先暂停掉<code>g()</code>的运行，同时让其他任务run起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Pause here and come back to g() when f() is ready</span></span><br><span class="line">    r = <span class="keyword">await</span> f()</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># async相当于go的goroutine</span></span><br><span class="line">    print(<span class="string">"One"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># asyncio.sleep(1)生成一个异步任务，休眠1秒后结束</span></span><br><span class="line">    print(<span class="string">"Two"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(count(), count())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># async.run()加载async函数，启动事件循环</span></span><br></pre></td></tr></table></figure><p>执行引擎遇到<code>await</code>命令，就会在异步任务开始执行之后，暂停当前 async 函数的执行，把执行权交给其他任务。等到异步任务结束，再把执行权交回 async 函数，继续往下执行。</p><p><code>asyncio.sleep()</code>可以暂时将控制权让给另一个更易立即执行的任务。而<code>time.sleep()</code>这种阻塞调用与异步Python代码不兼容，因为它会在睡眠时间内停止轨道中的所有内容。</p><p><code>asyncio.gather()</code> 将多个异步任务 <code>count()</code>包装成一个新的异步任务，必须等到内部的多个异步任务都执行结束，这个新的异步任务才会结束。</p><p><code>asyncio.run()</code> 在事件循环上监听 async 函数<code>main</code>的执行，等到 <code>main</code> 执行完了，事件循环才会终止。TIPS：如果直接调用<code>main()</code>，只会返回一个<code>coroutine</code>对象，<code>main()</code>方法内的代码不会执行。</p><blockquote><p>One<br>One<br>Two<br>Two</p></blockquote><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>以下代码段会在等待 2 秒后打印 “hello”，然后 <em>再次</em> 等待 3 秒后打印 “world”，耗时5秒:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">3</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><blockquote><p>started at 21:27:46<br>hello<br>world<br>finished at 21:27:51</p></blockquote><p>只耗时3秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (3s)</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(say_after(<span class="number">2</span>, <span class="string">'hello'</span>), say_after(<span class="number">3</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>started at 21:27:15<br>hello<br>world<br>finished at 21:27:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python由于GIL（全局锁）的存在，不能发挥多核的优势，这点一直饱受诟病。不过在IO密集型的网络编程里，异步处理比同步处理能提升成百上千倍的效率，弥补了python性能方面的短板。
    
    </summary>
    
    
      <category term="Python" scheme="https://stardust567.github.io/categories/Python/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Python" scheme="https://stardust567.github.io/tags/Python/"/>
    
      <category term="asyncio" scheme="https://stardust567.github.io/tags/asyncio/"/>
    
      <category term="concurrency" scheme="https://stardust567.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Server Deployment</title>
    <link href="https://stardust567.github.io/post/c4f7.html"/>
    <id>https://stardust567.github.io/post/c4f7.html</id>
    <published>2020-05-21T13:39:17.000Z</published>
    <updated>2020-05-26T08:50:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>19年底部署了个web应用，20年初发现404了（微笑）为了纪念成功踩雷，于是有了这篇博客。<br>20年中数据库被黑客攻击，勒索我 0.03 btc（按当日，近两千人民币），于是更新了这篇博客。<br><a id="more"></a></p><h2 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h2><h3 id="购买个服务器-amp-域名"><a href="#购买个服务器-amp-域名" class="headerlink" title="购买个服务器&amp;域名"></a>购买个服务器&amp;域名</h3><p>这显然是一句废话，目前买的比较多的是阿里云、腾讯云，笔者就是趁双11租了腾讯云最便宜的服务器<del>（虽说都有学生优惠活动，但优惠力度还没有双11大）</del>之后跨年夜晚上腾讯小哥还亲切就域名申请致电了我半小时: )</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li><p>远程登录ssh，可以选择密钥登录 <code>sudo ssh -i keyfile &lt;user&gt;@ip</code> 或者 密码登录 <code>ssh-copy-id USER_NAME@IP_ADDRESS</code> 进入远程服务器。</p></li><li><p>安装最新版本的docker，对下列步骤如有疑惑，请详见<a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">docker官网教程</a>。</p><ul><li><p>首先，更新现有的软件包列表并安装一些必备软件包：<br><code>sudo apt-get update</code><br><code>sudo apt install apt-transport-https ca-certificates \</code><br><code>curl software-properties-common</code></p></li><li><p>然后将官方Docker存储库的GPG密钥添加到系统中：<br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p></li><li><p>将Docker存储库添加到APT源：<br><code>sudo add-apt-repository \</code><br><code>&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</code></p></li><li><p>使用新添加的存储库中的Docker软件包更新软件包数据库：<br><code>sudo apt update</code></p></li><li><p>确保要从Docker存储库而不是默认的Ubuntu存储库进行安装：<br><code>apt-cache policy docker-ce</code></p></li><li><p>最后，终于到了安装Docker这一步：<br><code>sudo apt install docker-ce</code></p></li><li><p>启动守护程序，并启用启动过程。检查它是否正在运行：<br><code>sudo systemctl status docker</code></p></li></ul><p><strong>注意此时使用docker需要加sudo关键字，例如 sudo docker ps</strong></p></li></ol><h3 id="Portainer管理"><a href="#Portainer管理" class="headerlink" title="Portainer管理"></a>Portainer管理</h3><p>部署Portainer Server方便管理别的docker容器，详情见<a href="https://www.portainer.io/installation/" target="_blank" rel="noopener">官网</a>教程。<br><code>$ docker volume create portainer_data</code><br><code>$ docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></p><p>部署完在浏览器中打开服务器的9000端口，注册完后选择<strong>local</strong>即可。</p><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><ol><li><p>在服务器上安装nginx 用<code>sudo apt install nginx</code>即可。 </p></li><li><p>打开<code>/etc/nginx/sites-enabled/</code>新建一个conf配置文件，写入nginx配置。写完后执行生效并检查：<br><code>sudo service nginx restart</code><br><code>sudo nginx -t</code></p></li></ol><h3 id="pull相关镜像"><a href="#pull相关镜像" class="headerlink" title="pull相关镜像"></a>pull相关镜像</h3><ol><li>Registries -&gt; Add registry -&gt; Custom registry -&gt; URL: registry.cn-shanghai.aliyuncs.com -&gt; Authentication -&gt; Username: stardust567 （这是我在阿里云的镜像仓库）</li><li>Stacks &gt; Add stack 加上你想加的镜像即可，具体配置可参考<a href="https://yeasy.gitbook.io/docker_practice/introduction" target="_blank" rel="noopener">教程文档</a>。</li><li>理论上现在整个项目就跑起来了，可以<code>sudo docker ps</code>查看相关CONTAINER ID，然后<code>sudo docker logs [CONTAINER ID]</code>查看相关日志。</li></ol><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -i 567top ubuntu@118.25.70.50</span><br><span class="line">sudo docker ps</span><br><span class="line">sudo docker exec -it f62b0da943e3 /bin/bash</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use infoweb</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br></pre></td></tr></table></figure><p>然后一个大大的WARNING出现在我眼前，让我意识到了之前忽视的软件安全的重要性。</p><h3 id="改root密码"><a href="#改root密码" class="headerlink" title="改root密码"></a>改root密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_password&apos;);</span><br></pre></td></tr></table></figure><h3 id="改root用户名"><a href="#改root用户名" class="headerlink" title="改root用户名"></a>改root用户名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE mysql;</span><br><span class="line">mysql&gt; UPDATE user SET user=&quot;another_username&quot; WHERE user=&quot;root&quot;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>mysql默认root账户无法远程登录，哪怕你改名改密码也不行，会出现ERROR 1045 (28000)</strong> </p><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &apos;username&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;</span><br></pre></td></tr></table></figure><p>@后面跟登入IP，%为通配符，表示任意IP都可登录。</p><h3 id="赋予用户权限"><a href="#赋予用户权限" class="headerlink" title="赋予用户权限"></a>赋予用户权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on infoweb.* to &apos;stardust567&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><p>info是相关数据库的名字，为’stardust567’@’%’赋予infoweb上的所有权限。</p><h3 id="服务器方面"><a href="#服务器方面" class="headerlink" title="服务器方面"></a>服务器方面</h3><p>建议在服务器设置上关掉3306（mysql）端口，只开80（http）和443（https）端口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;19年底部署了个web应用，20年初发现404了（微笑）为了纪念成功踩雷，于是有了这篇博客。&lt;br&gt;20年中数据库被黑客攻击，勒索我 0.03 btc（按当日，近两千人民币），于是更新了这篇博客。&lt;br&gt;
    
    </summary>
    
    
      <category term="SRE" scheme="https://stardust567.github.io/categories/SRE/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Tips" scheme="https://stardust567.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Garbage collection in Python</title>
    <link href="https://stardust567.github.io/post/d860.html"/>
    <id>https://stardust567.github.io/post/d860.html</id>
    <published>2020-05-09T03:35:46.000Z</published>
    <updated>2020-05-13T03:22:51.144Z</updated>
    
    <content type="html"><![CDATA[<p>相比于C这种需要你手动malloc和free的语言，Python实现了自动内存管理。一般而言，手动内存管理显然容易出问题，比如忘记free导致的内存泄漏，提前free导致的悬空指针。那么自动内存管理的垃圾回收是怎么一回事呢，简单来说：引用计数，标记-清除，分代回收。 <a id="more"></a></p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h3><p>我们先要考虑什么叫<strong>引用</strong>。在python中赋值语句是在建立对象的引用值，而非复制对象。因此python变量更像是指针，而不是数据存储区域。当你写出<code>a = 1</code>的时候，实际上是变量a通过引用指向了一个int对象3。</p><p>再举个经典例子，<code>nums = [1]</code>然后<code>nums.append(nums)</code>如果是直观上的赋值操作，那结果应该是<code>[1, [1]]</code>但实际运行下就会发现<code>[1, [...]]</code>这是因为一个object的自身引用造成的不断递归死循环。如果想完成原先想法的话，可以用<code>nums.append(nums[:])</code>或者<code>nums.append(nums.copy())</code>这样就完成了一次浅拷贝。不过浅拷贝只是当前层的拷贝，如果拷贝的对象中存在引用的话，只会拷贝相关引用，而不会拷贝深层的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, [<span class="number">1</span>]]</span><br><span class="line">b = a.copy()</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">b[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">print(a) <span class="comment"># [1, [0]]</span></span><br></pre></td></tr></table></figure><p>如果想复制当前层以及所有子层对象的话，需要使用深拷贝<code>deepcopy</code>（本质上算是种递归拷贝）</p><h3 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h3><p>python的对象分为不可变对象 int float long str tuple 等，可变对象 list set dict 等。</p><p> 这里的不可变不是指值的不可变，而是说，对于不可变类型的变量，如果要更改变量，会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收。<em>（不可变的类型可以计算hash值，作字典的key）</em></p><p>可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。</p><p>内置函数id()可以查看python对象的内存地址。<em>（None值也有内存地址）</em><br>在python里， <code>is</code> 判断两个对象的id（即内存地址）是否一样， <code>==</code> 判断两个对象的值是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 1609788160</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">id(a) <span class="comment"># 1609788192</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">id(b) <span class="comment"># 1609788160</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>]</span><br><span class="line">id(a) <span class="comment"># 2031362701064</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">id(a) <span class="comment"># 2031362701064</span></span><br><span class="line">id(a[<span class="number">0</span>]) <span class="comment"># 1609788160</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">None</span></span><br><span class="line">id(a) <span class="comment"># 1609344144</span></span><br><span class="line">b = <span class="keyword">None</span></span><br><span class="line">id(b) <span class="comment"># 1609344144</span></span><br></pre></td></tr></table></figure><p>所以python函数的传参没有传值还是传引用一说，Python参数传递只有“<strong>传对象引用</strong>”的方式。实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象的引用，就能修改对象的原始值，相当于传引用来传递对象；如果函数收到的是一个不可变对象的引用，就不能直接修改原始对象，相当于传值来传递对象。</p><h3 id="引用计数-1"><a href="#引用计数-1" class="headerlink" title="引用计数"></a>引用计数</h3><h4 id="对象的引用计数-1的情况"><a href="#对象的引用计数-1的情况" class="headerlink" title="对象的引用计数+1的情况"></a>对象的引用计数+1的情况</h4><ol><li>对象被创建<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">a = <span class="number">23</span></span><br><span class="line">sys.getrefcount(a) <span class="comment"># 6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyName</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">sys.getrefcount(MyName()) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li></ol><p>这里int对象23其实并未被新建，在Python启动解释器时会将常用对象自动创建并加载到内存中等待调用；<br>MyName()结果为1，是因为sys.getrefcount(MyName())函数也算一个引用。</p><ol><li><p>对象被引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span></span><br><span class="line">b = a</span><br><span class="line">c = b</span><br><span class="line">sys.getrefcount(a) <span class="comment"># 4</span></span><br><span class="line">sys.getrefcount(c) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></li><li><p>对象被作为参数，传入到一个函数中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(c)</span>:</span></span><br><span class="line">print(sys.getrefcount(c))</span><br><span class="line">a = <span class="number">3.1415926</span>   </span><br><span class="line">sys.getrefcount(a) <span class="comment"># 2</span></span><br><span class="line">func(a) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></li></ol><p>多加一层函数包装感觉应该只加1才对，即func参数c对3.1415926的引用，为什么会加2呢？实际上在运行<code>func(a)</code>时，会先将函数func和变量a压栈，此时函数栈保存了入参对3.1415926的引用。</p><ol><li><p>对象作为一个元素，存储在容器中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span>   <span class="comment"># 增加一个引用  count = 1</span></span><br><span class="line">b = a   <span class="comment"># 增加一个引用  count = 2</span></span><br><span class="line">nums = [a, b]   <span class="comment"># 增加两个引用  count = 4</span></span><br></pre></td></tr></table></figure><h4 id="对象的引用计数-1的情况-1"><a href="#对象的引用计数-1的情况-1" class="headerlink" title="对象的引用计数-1的情况"></a>对象的引用计数-1的情况</h4></li><li><p>对象的别名被赋予新的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span>   <span class="comment"># 增加一个引用  count = 1</span></span><br><span class="line">b = a   <span class="comment"># 增加一个引用  count = 2</span></span><br><span class="line">b = <span class="number">-3.1415926</span>   <span class="comment"># 原对象减少一个引用  count = 1</span></span><br><span class="line">sys.getrefcount(a) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li><p>对象的别名被显式销毁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span>   <span class="comment"># 增加一个引用  count = 1</span></span><br><span class="line">b = a   <span class="comment"># 增加一个引用  count = 2</span></span><br><span class="line"><span class="keyword">del</span> b   <span class="comment"># 减少一个引用  count = 1</span></span><br><span class="line">sys.getrefcount(a) <span class="comment">#  2</span></span><br></pre></td></tr></table></figure></li><li><p>一个对象离开它的作用域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span>   <span class="comment"># 增加一个引用  count = 1 </span></span><br><span class="line">sys.getrefcount(a)   <span class="comment"># 增加一个引用count=2 -&gt; 打印 2 -&gt; 减少一个引用count=1</span></span><br></pre></td></tr></table></figure></li><li><p>对象所在的容器被销毁，或从容器中删除对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span> <span class="comment"># 增加一个引用  count = 1 </span></span><br><span class="line">list_ = [a,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment"># 增加一个引用  count = 2</span></span><br><span class="line"><span class="keyword">del</span> list_ <span class="comment"># 减少一个引用  count = 1</span></span><br></pre></td></tr></table></figure></li></ol><p>当引用计数为0时，系统会收回这个对象，完成垃圾回收。但是存在一种问题，循环引用。</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当出现引用链成环的时候，会导致引用计数永远不为0，造成内存泄漏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> objgraph </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(objgraph.count(<span class="string">"Person"</span>)) <span class="comment"># 0</span></span><br><span class="line">print(objgraph.count(<span class="string">"Animal"</span>)) <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">P = Person()</span><br><span class="line">A = Animal()</span><br><span class="line">print(objgraph.count(<span class="string">"Person"</span>)) <span class="comment"># 1</span></span><br><span class="line">print(objgraph.count(<span class="string">"Animal"</span>)) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">P.pet = A</span><br><span class="line">A.master = P</span><br><span class="line"><span class="keyword">del</span> P</span><br><span class="line"><span class="keyword">del</span> A</span><br><span class="line"><span class="comment"># 正常情况下，如果删除了P和A，应该为0，但由于循环引用，结果为1</span></span><br><span class="line">print(objgraph.count(<span class="string">"Person"</span>)) <span class="comment"># 1</span></span><br><span class="line">print(objgraph.count(<span class="string">"Animal"</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>这种时候计数就无法解决了，也为我们引入了下面的主题： 标记-清除 &amp;  分代回收。</p><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>标记清除就是用来解决循环引用的问题的只有容器对象才会出现引用循环，比如列表、字典、类、元组。</p><ul><li>标记阶段，遍历所有的对象，如果可达（reachable），即还有对象引用它，则标记该对象为可达；</li><li>清除阶段，再次遍历对象，如果发现某个对象未标记为可达，则就将其回收。</li></ul><p>为了追踪容器对象，每个容器对象维护两个额外的指针，将所有容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python维护了两个这样的双端链表，一个链表”Object to Scan”存放着需要被扫描的容器对象，另一个链表”Unreachable”存放着临时不可达对象。链表中每个节点除了有记录当前引用计数的变量ref_count还有一个gc_ref变量，gc_ref是ref_count的一个副本，所以初始值为ref_count的大小。</p><p>gc启动的时候，会从根节点root逐个遍历”Object to Scan”链表中的容器对象，并使当前对象引用的所有对象的<code>gc_ref--</code>，将”Objects to Scan”链表中的所有对象遍历一遍，相当于解除了循环引用对引用计数的影响。</p><p>接着，gc会再次扫描所有的容器对象，如果对象的gc_ref值为0，那么这个对象就被标记为UNREACHABLE，并移至”Unreachable”链表中。如果对象的gc_ref不为0，那么这个对象就会被标记为REACHABLE。同时当gc发现有一个节点是可达的，他会递归式的将从该节点出发可以到达的所有节点标记为REACHABLE。</p><p>第二次遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象，gc随即释放之。</p><p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>随着程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。理论上，创建 == 释放数，但如果存在循环引用的话，肯定是创建 &gt; 释放数，当创建数与释放数的差值达到规定的阈值的时候，就会采用分代回收机制。</p><p>分代回收将对象分为三代（generation 0,1,2），根据弱代假说（对象存活时间越久，越不可能是垃圾）新生的对象被放入0代，如果该对象在第0代的一次gc垃圾回收中活了下来，那么它就被放到第1代里面；如果第1代里面的对象在第1代的一次gc垃圾回收中活了下来，它就被放到第2代里面。</p><p><code>gc.set_threshold(threshold0[,threshold1[,threshold2]])</code>设置gc每一代垃圾回收所触发的阈值。<br><code>gc.get_threshold()</code>是获取三者的值，默认值为(700,10,10).</p><p>从上一次第0代gc后，如果分配对象的个数减去释放对象的个数大于threshold0，那么就会对第0代中的对象进行gc垃圾回收检查。 从上一次第1代gc后，如过第0代被gc垃圾回收的次数大于threshold1，那么就会对第1代中的对象进行gc垃圾回收检查。同样，从上一次第2代gc后，如过第1代被gc垃圾回收的次数大于threshold2，那么就会对第2代中的对象进行gc垃圾回收检查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比于C这种需要你手动malloc和free的语言，Python实现了自动内存管理。一般而言，手动内存管理显然容易出问题，比如忘记free导致的内存泄漏，提前free导致的悬空指针。那么自动内存管理的垃圾回收是怎么一回事呢，简单来说：引用计数，标记-清除，分代回收。
    
    </summary>
    
    
      <category term="Python" scheme="https://stardust567.github.io/categories/Python/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Python" scheme="https://stardust567.github.io/tags/Python/"/>
    
      <category term="GC" scheme="https://stardust567.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>被动读写锁</title>
    <link href="https://stardust567.github.io/post/9271.html"/>
    <id>https://stardust567.github.io/post/9271.html</id>
    <published>2020-03-22T07:35:14.000Z</published>
    <updated>2020-04-01T06:59:23.671Z</updated>
    
    <content type="html"><![CDATA[<p>Prwlock 为TSO架构系统提供了可扩展读者侧性能和写者低延迟，其关键在于多个无交互读者和一个不确定写者间基于version的共识协议。Prwlock 利用内存一致性的有界旧一致性(bounded staleness)来避免读者侧的原子操作和内存屏障，同时用消息传递(IPI)落伍的读者来限定写锁获取延迟。<a id="more"></a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="内存一致性"><a href="#内存一致性" class="headerlink" title="内存一致性"></a>内存一致性</h3><p>并发编程主要有两种编程范式：消息传递及共享内存。前者主要用于分布式系统，通过网络，采用消息的发送及接收的方式完成对共享数据的访问；而后者主要用于单机，通过内部互联总线，采用读写共享内存的方式完成对共享数据的访问。一致性模型为后者服务。</p><p>当一个处理器对共享变量（V）的本地副本进行了修改，而另一个处理器（PB）用于保存相应变量的缓存行因此而失效或被更新，则称 PB 看见了 PA 的内存更新（对变量 V 的修改）内存一致性模型规定了处理器能否在一个变量为指定处理器可见之前继续执行下去。</p><p>一种系统在每个处理器内部都设置了一块写缓冲区，用以吸收写指令，并异步地将这些写指令分别提交到内存控制器中。本处理器在读取内存时，如果检测到写缓冲区里已经存在针对同一地址的写了，那么它就直接解析这个写指令要写入的值并返回。这样能够很好地增加访存指令吞吐量。但在多处理器系统上，处理器很可能会从内存中读到过期的数据，因为相关的写操作可能仍缓冲在另一个处理器的缓冲区里，从而遭遇一致性问题。</p><h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><p>最严格的一致性，当然性能也最差。确保程序顺序和原子性。程序顺序，即各处理器的操作保持程序指定的顺序；原子性，即各处理器能够同时看到访存指令的结果。这种最易理解，一致性长度也最高，但那些基于重排序的编译器优化都不能用了，比如代码移动、寄存器染色、子表达式消除。</p><blockquote><p>本文中的访存（Memory Access）指令，指读存指令（Load）和写存指令（Store）</p></blockquote><h4 id="TSO-Total-Store-Order"><a href="#TSO-Total-Store-Order" class="headerlink" title="TSO(Total Store Order)"></a>TSO(Total Store Order)</h4><p>Intel x86采用TSO模型，各处理器看见所有写存指令的执行顺序都是一样的。</p><p><strong>程序顺序</strong>上，先写后读(W-&gt;R)的顺序可以改变为先读后写(R-&gt;W)，但W-&gt;W(写操作)和R-&gt;RW(读取并赋值)的顺序不可改变。</p><p><strong>原子性</strong>上，不能提前读取到别的处理器的写。即某个处理器修改了变量 x 后，别的处理器要么都看到这个修改，要么都没看到这个修改。但可以提前读取本处理器的写。即本处理器不必等待别的处理器看见本处理器的写操作，就可以继续运行下去。</p><p>同时TSO提供了增强一致性的 safety net ：</p><ol><li><p><strong>RMW(read-modify-write)</strong>：在 intel 64 架构中，即为 locked 指令。</p></li><li><p><strong>Memory barrier</strong>：一种特别的屏障指令，其导致 CPU 或编译器强制约束内存指令，使之在屏障之前或之后发射。以 mfence 这个指令为例，其保证在程序顺序中，mfence 之前的所有访存指令，其结果都能为 mfence 之后的访存指令所见。</p></li></ol><blockquote><p>发射(issue)：在乱序处理器中指指令进入指令调度器；派发(dispatch)：指令进入执行单元。<br>一般将发射理解为已经开始执行了。</p></blockquote><h4 id="有界旧一致性-bounded-staleness"><a href="#有界旧一致性-bounded-staleness" class="headerlink" title="有界旧一致性 bounded staleness"></a>有界旧一致性 bounded staleness</h4><p>提交的写更新操作，不一定立即会被读操作读到，读写两者所冲突的区间形成了一个“不一致窗口”，我们允许该窗口存在，但window size应在一定限度范围内，而在窗口之外 bounded staleness 可以保证操作的全局按序。通常有两种size尺度，一种以版本个数K为限，此时window size指读操作读到的值和最新值的版本差max。一种以时间间隔T为限，此时window size指读操作可以读到最新值的时间差max。</p><h3 id="读写锁-rwlock"><a href="#读写锁-rwlock" class="headerlink" title="读写锁 rwlock"></a>读写锁 rwlock</h3><p>rwlock 把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需对共享资源进行写操作。这种锁能提高并发性，在多处理器系统中它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者，但不能同时既有读者又有写者。</p><p>如果读写锁当前没有读者，也没有其它写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p><h4 id="大读者锁-brlock"><a href="#大读者锁-brlock" class="headerlink" title="大读者锁 brlock"></a>大读者锁 brlock</h4><p>大读者锁是读写锁的高性能版，读者可以非常快地获得锁，但写者获得锁的开销比较大。这种锁适合于读多写少的情况，它在这种情况下远好于读写锁。大读者锁的实现机制有两种：</p><ul><li>brlock1：每个线程都有互斥锁，一个读者仅需要获取本线程锁，但写者需要获得所有锁</li><li>brlock2：使用一个由读者和写者共享的读者flags数组</li></ul><p>当一个线程被抢占然后移到另一个core的时候，brlock容易发生死锁，所以brlock常用在禁止抢占的环境中。</p><h2 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a>设计框架</h2><h3 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h3><p>典型的rwlock依赖于原子指令来协调读者和写者。在多处理器上，一条原子指令暗含了一次内存屏障，这样可以保证读者读到的是最后一位写者的最新数据。但当不存在任何写程序时，这样的内存屏障是不必要的，读程序之间没有内存顺序依赖性，此类不必要的内存屏障可能会导致大量开销。</p><p><strong>Message passing is not prohibitively expensive:</strong><br>常见多核处理器类似于分布式系统，每个核都有自己的内存层次结构。每个内核本质上都使用消息传递来与其他内核通信，但硬件设计人员添加了一个抽象（缓存一致性）来模拟共享内存接口。但由于连贯性消息的序列化，共享有竞争的cache开销可能远超像处理器间中断（IPI）之类的显式消息传递。此外，将多个IPI传递到不同的内核可以并行进行。</p><blockquote><p>处理器间中断（Inter-Processor Interrupt）是种特殊类型的中断，即在多核系统中，允许一个CPU向系统其他的CPU发送中断信号，可能要求采取的行动：刷新其它CPU的内存管理单元缓存、停机（当系统被一个处理器关闭时）</p></blockquote><p><strong>Bounded staleness without memory barriers：</strong><br>在rwlock中，一个写者需要与所有读者达成 consensus 才能获取该锁。因此，写者必须让所有读者看到其当前状态才能继续进行。典型的rwlock使用内存屏障以确保读者写者的版本更新按顺序对彼此可见，但这样开销太大，那么能否不用内存屏障？事实上一般处理器如x86-64，通常在很短的时间内其他内核就可以看到多个内存更新。基于此采取微基准测试：重复写入一个内存位置，并在随机延迟后在另一个内核上读取该位置，然后收集看到过时值的读者的时间间隔，发现大多数读者其实可以在很短的时间内看到写者的更新（因为处理器由于其有限的大小而将主动刷新其存储缓冲区）</p><p><strong>Memory barrier not essential for mutual exclusion:</strong><br>现代处理器为了性能考虑不会按序执行指令，存在一个存储缓冲区，以使处理器在write cache未命中后继续执行，但这也导致了较弱的内存一致性。为了实现正确的互斥，通常使用性能开销较大的同步机制（例如内存屏障）来对管道进行序列化并刷新存储缓冲区。事实证明，在TSO机器上的所有执行中，都不可能构建一种满足互斥，无死锁且避免原子指令和内存屏障的算法。尽管prwlock读者不包含显式的内存屏障，因此似乎违反了该“顺序法则”，但prwlock使用 IPI 序列化了针对写者的读者执行，并且IPI处理具有与内存屏障相同的效果。</p><h3 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h3><p><strong>Consensus using bounded staleness:</strong><br>Prwlock 将version变量引入锁结构。每个写者都会自增version，并等待所有读者看到新的version后才继续写。 </p><p>写者：lock(writer) ; ver++;<br>读者：while(writer!=FREE) status[my_id] = ver;<br>写者：for_each (id) while(status[id] &lt; ver); </p><p>但如果某个读者id再也不进入临界区，那status[id]会永远小于ver，写者会一直陷入等待，无法进入临界区。 其次，读者可能会从一个core迁移到另一个core，但可能并不会更新离开的core。 </p><p><strong>Handling straggling readers:</strong><br>为解决上述问题，prwlock引入了基于消息的共识协议，以使写者在必要时用IPI主动向读者发送请求。</p><p>写者：lock(writer) ; ver++;<br>读者：while(writer!=FREE) status[my_id] = ver;<br>写者：for_each (id) while(status[id] &lt; ver) <strong>IPI_request_ to_reader(id)</strong>;</p><p>但如果允许读者在读取侧临界区中睡眠的话，睡眠状态的读者可能会错过请求，因此可能会无限阻塞写者。</p><p><strong>Supporting sleeping readers:</strong><br>为了解决读者睡眠问题，prwlock引入了传统的计数器，让写者确认此时有无睡眠读者。</p><p>Prwlock跟踪两种类型的读者：被动读者和主动读者。读者开始时都设为passive，但在睡眠前会从passive转换为active。在此转换期间，共享的counter会自增。当active读者释放其锁定后，counter自减。写者使用该counter来确定是否有任何活动的读者。由于读者在读取器侧临界区睡眠很少，因此prwlock总体具有良好的性能。</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>为了简化说明，我们假设这些功能中只有一个锁，并且禁止抢占，以便它们可以安全地使用每个CPU状态。</p><h4 id="Read-side-algorithm"><a href="#Read-side-algorithm" class="headerlink" title="Read-side algorithm"></a>Read-side algorithm</h4><p>每个per-core reader status structure（st）分布式跟踪passive reader，st会记住最新查看的version以及每个内核上prwlock的被动状态。<strong>FREE, PASSIVE两种状态体现在st.reader上，ACTIVE状态体现在lock.active上。</strong></p><p>要锁读者锁，要先设置状态为PASSIVE，再检查写者锁（<em>否则会存在一个时间窗口：读者明明观测到写者锁处于FREE，但并不能获得读者锁。如果在此时间窗口中传递了共识消息（例如IPI），则写者将成功获取锁并进入临界区，这违反了rwlock的语义</em>）如果读者发现此锁已被写者锁定(lock.writer != FREE)，则应释放被动锁定，将状态设置为FREE，等待写者解锁并重试。</p><p>要解锁读者锁，只需检查该锁是否处于PASSIVE并相应地将其解锁（<em>ReadUnlock</em>）。因此，在TSO体系结构上的读者公共路径中，不需要原子指令/内存障碍。此外，PASSIVE读者不会相互通信，从而保证了读者的可伸缩性和较低的延迟。</p><p>如果读者被调度时正在PASSIVE模式持有锁，则应通过增加主动计数器（<em>ScheduleOut</em>）转换为ACTIVE锁。</p><p><strong>ReadLock(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st ← PerCorePtr(lock.rstatus, CoreID); </span><br><span class="line">st.reader ← PASSIVE; </span><br><span class="line">while lock.writer != FREE do </span><br><span class="line">st.reader ← FREE; //释放被动锁定</span><br><span class="line">st.version ← lock.version; </span><br><span class="line"> WaitUntil(lock.writer == FREE); </span><br><span class="line"> st ← PerCorePtr(lock.rstatus, CoreID); </span><br><span class="line"> st.reader ← PASSIVE; </span><br><span class="line">/* Barrier needed here on non-TSO architecture */;</span><br></pre></td></tr></table></figure><p><strong>ReadUnlock(lock)</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st ← PerCorePtr(lock.rstatus, CoreID);</span><br><span class="line">if st.reader = PASSIVE then st.reader ← FREE;</span><br><span class="line">else AtomicDec(lock.active);</span><br><span class="line">/* Barrier needed here on non-TSO architecture */;</span><br><span class="line">st.version ← lock.version;</span><br></pre></td></tr></table></figure><p><strong>ScheduleOut(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">st ← PerCorePtr(lock.rstatus, CoreID); </span><br><span class="line">if st.reader = PASSIVE then AtomicInc(lock.active);</span><br><span class="line">st.reader ← FREE;</span><br><span class="line">st.version ← lock.version;</span><br></pre></td></tr></table></figure><h4 id="Write-side-algorithm"><a href="#Write-side-algorithm" class="headerlink" title="Write-side algorithm"></a>Write-side algorithm</h4><p>写者锁的获取可分为两个阶段。一个写者首先锁定writer mutex，然后增加version以进入阶段1。然后，它将检查当前域中的所有联机cores，以确认cores是否已查看最新version。如果ok，则说明读者都在线，即知道此锁已被写者锁定，并在写者释放锁前不会获得读者锁。对于看不到最新version的内核，写者发送IPI并询问其状态。收到IPI后，未锁定的读者将通过更新其本地version（<em>Function Report</em>）向写者报告。锁定的读者在离开读取侧临界区或进入睡眠状态后将稍后报告。在报告了所有核心后，所有passive读者都达成了共识。然后，写者进入阶段2。在此阶段，写者只需等待所有活动的读者退出即可。</p><p>写者可以将锁直接传递给之后的writer，而无需再次达成共识（line2-4 in WriteLock and line1 in WriteUnlock）</p><p><strong>WriteLock(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lastState ← Lock(lock.writer);</span><br><span class="line">if lastState = PASS then return;</span><br><span class="line">/* Lock passed from another writer */</span><br><span class="line">newVersion ← AtomicInc(lock.version);</span><br><span class="line">coresWait ← /0;</span><br><span class="line">for ID ∈ AllCores do </span><br><span class="line">if Online(lock.domain, ID) ∧ ID != CoreID then </span><br><span class="line">if PerCorePtr(lock.rstatus, CoreID).version != newVersion then </span><br><span class="line">AskForReport(ID);</span><br><span class="line">Add(ID, coresWait);</span><br><span class="line">for ID ∈ coresWait do </span><br><span class="line">while PerCorePtr(lock.rstatus, CoreID).version != newVersion do Relax();</span><br><span class="line">while lock.active != 0 do Schedule();</span><br></pre></td></tr></table></figure><p><strong>WriteUnlock(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if SomeoneWaiting(lock.writer) then Unlock(lock.writer, PASS); </span><br><span class="line">else Unlock(lock.writer, FREE);</span><br></pre></td></tr></table></figure><p><strong>Report(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st ← PerCorePtr(lock.rstatus, CoreID);</span><br><span class="line">if st.reader != PASSIVE then st.version ← lock.version;</span><br></pre></td></tr></table></figure><h4 id="Correctness-on-TSO-architecture"><a href="#Correctness-on-TSO-architecture" class="headerlink" title="Correctness on TSO architecture"></a>Correctness on TSO architecture</h4><p>rwlocks与其他较弱的同步原语之间的主要区别在于，rwlocks在读者写者间有强大的可见性保证。<br>一旦读者看到了FREE的prwlock，可以确定：1）该FREE由直接的前一个写者设置；2）由于在TSO架构下按顺序可见内存写入，因此以前的写者所做的更新也应对该读者可见；3）在该读者退出前，没有写者可以进入临界区。<br>这三个属性共同确保读者始终可以看到受prwlock保护的共享数据的最新一致版本。此外，由于所有读者在获取写者锁期间都明确报告了最新版本，因此还可以保证写者查看读者st的所有更新。<br>在非TSO架构上，读者算法中需要两个额外的存储屏障。第一个确保读者在快速路径中获得锁定后，可以看到共享数据的最新版本。第二个是在释放读者锁之前使写者可以看到读者的内存更新。</p><h3 id="OS内核集成"><a href="#OS内核集成" class="headerlink" title="OS内核集成"></a>OS内核集成</h3><p>将prwlock集成到OS内核中存在几个问题。首先，prwlock的范围可以是全局范围的，也可以是进程范围的，并且每个范围中可能有多个prwlock。每个prwlock可以由多个任务共享。为了减少读者写者之间的消息，prwlock使用锁域抽象来将可以达成共识的相关prwlocks归为一组。域跟踪当前正在执行prwlock相关任务的CPU内核。</p><h4 id="Domain-Online-Offline"><a href="#Domain-Online-Offline" class="headerlink" title="Domain Online/Offline"></a>Domain Online/Offline</h4><p>在操作系统执行期间，可能会关闭一组prwlocks的范围。例如，对于保护进程的地址空间结构的一组锁，可以在地址空间切换期间关闭该结构。在这种情况下，prwlock使用域抽象来避免不必要的共识消息。域维护从cores到其online/offline状态的映射。只有活动域中的CPU内核才需要发送消息。</p><p>当域将在core上联机时<code>coreSt ← PerCorePtr(dom.cores, CoreID);</code>，它只需设置映射<code>coreSt.online = TRUE;</code>然后执行内存屏障<code>MemoryBarrier();</code>。由于写者总在检查域之前设置其状态，因此可以保证写者可以看到新联机的内核，或者该内核上新来的读者可以看到写者正在获取锁。在任何一种情况下，rwlock语义都会保留。为了正确地使域从core中offline，在更改域之前还需要一个内存屏障，以确保offline前所有操作都对其他cores可见。<br>对于与进程相对应的域，prwlock使域在上下文切换前后联机/脱机。在域外时，读者必须在较慢的ACTIVE状态中获取所有prwlock。我们选择保留锁定用户的选择，因为他们可能会对工作量有更多的了解。 </p><h4 id="Task-Online-Offline"><a href="#Task-Online-Offline" class="headerlink" title="Task Online/Offline"></a>Task Online/Offline</h4><p>可以将task（例如线程）上下文切换到其他任务，也可以将任务从一个核迁移到另一核。 prwlock使用联机/脱机任务来处理此类操作。当持有PASSIVE模式下prwlock的task即将切出时，如果prwlock为passive reader，将改为ACTIVE并增加active reader counter。这样可以确保写者一直处于等待，直到再次调度此任务，离开临界区继续执行。任务被调度再次联机时，无需执行任何操作。</p><h4 id="DownGrade-Upgrade"><a href="#DownGrade-Upgrade" class="headerlink" title="DownGrade/Upgrade"></a>DownGrade/Upgrade</h4><p>典型的操作系统通常支持将rwlock从写模式降级到读模式，并从读模式升级到写模式。通过将当前任务设置为读模式，然后在写模式下释放锁，Prwlock同样支持锁降级。与传统rwlock不同，在少数情况下，将prwlock从读模式升级到写模式，由于缺少读者数量的确切消息，可能开销会更大。要将锁从读模式升级到写模式，prwlock会尝试在读取侧临界区以写入模式获取锁，但是获取锁时，读者的数量要少一个（不包括升级读者本身）。</p><h3 id="用户级支持"><a href="#用户级支持" class="headerlink" title="用户级支持"></a>用户级支持</h3><p>用户空间实现主要障碍是无法在用户空间获取锁期间禁用抢占。<br>为了解决此问题，prwlock依赖于某些内核支持。背后的想法很简单：当有必要对每个内核状态执行任何操作时，prwlock进入内核并由内核处理。我们没有使用每核数据结构st来维护被动读者状态，而是在用户空间中引入了每线程数据结构。每个线程都应在执行锁定操作前将其实例注册到内核，因为任何时候内核上都只有一个线程在运行。这样的每线程数据结构类似于内核算法中使用的每核数据结构。</p><p>出于性能方面的考虑，读者临界区应完全位于用户空间内，否则syscall开销将破坏prwlock的短延迟优势。<br>在prwlock中，被动锁保持为每核状态，而主动锁则保持在共享计数器中；检查和更改被动锁定模式应自动完成。<br>ReadUnlock算法会在开头2-3行检查读者是否为PASSIVE，如果是，则通过将状态设置为FREE来释放被动锁定。如果线程在第2行和第3行之间被抢占，则该锁可能会转换为活动锁，并且活动计数会增加。稍后进行调度时，由于之前已经做出决定，因此活动计数不会减少。结果，rwlock变得不平衡，并且写者再也无法获取该锁。</p><p>为了克服这个问题，我们在每线程数据结构中添加了抢占检测字段。读取器首先将状态设置为PASSIVE，然后检查是否在被动锁定时被抢占。如果是这样，它将减少活动计数器，因为该锁现在是活动锁。对于写端算法，由于不可能在用户空间中发送IPI，因此几乎所有写者都应进入内核以获取锁。 不过与写者锁获取时间相比，内核和用户空间之间的模式切换成本通常可以忽略不计。</p><p><strong>Function ReadUnlock(lock) for user-level prwlock</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">st ← PerThreadPtr(lock.rstatus);</span><br><span class="line">st.reader ← FREE;</span><br><span class="line">if st.preempted then </span><br><span class="line">AtomicDec(lock.active);</span><br><span class="line">st.preempted ← FALSE;</span><br><span class="line">st.version ← lock.version;</span><br></pre></td></tr></table></figure></p><p><strong>Function ScheduleOut(lock)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">st ← PerThreadPtr(lock.rstatus);</span><br><span class="line">if st.reader = PASSIVE then </span><br><span class="line">AtomicInc(lock.active);</span><br><span class="line">st.preempted ← TRUE;</span><br><span class="line">st.reader ← FREE;</span><br><span class="line">st.version ← lock.version;</span><br></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li><p><strong>内存屏障：</strong>在读取侧临界区的通用路径中，没有写者时prwlock不需要任何内存屏障。唯一需要的内存屏障是当CPU内核即将离开锁定域时，例如，切换到另一个任务并使当前的锁定域脱机或联机。但域联机/脱机操作在典型执行中很少见。因此，通常情况下prwlock具有良好的性能可伸缩性。</p></li><li><p><strong>写者成本：</strong>使用IPI可能会显着增加写入成本，但IPI和模式切换的成本很小。此外，由于写者通常需要等待所有读者都离开临界区，因此开销可以忽略不计。与传统rwlock相比，当前在读取侧临界区执行的读者越多，写入完成共识并获得写入模式锁定的速度就越快。因为读者很可能会看到写者，因此会立即报告。这样的功能非常适合 rwlocks（读者多于写者）</p></li><li><p><strong>空间开销：</strong>由于prwlock本质上是分布式rwlock，因此它需要O（n）空间用于锁实例。<br>当前实现需要每个锁每个内核12个字节（版本8个，读取器状态4个），以使性能最大化。也可以将7位version和1位status打包到一个字节中以节省空间。需要另外几个字节来存储写者状态，其确切大小取决于特定写者使用的同步机制。此外，每个内核需要额外的1个字节来存储域online状态以支持锁定域抽象。通过使用Linux内核的按CPU存储机制，锁的按CPU状态可以与其他按CPU状态字打包到同一缓存行中。与其他可扩展的rwlock算法相比，prwlock施加了相似或更低的空间开销。</p></li><li><p><strong>内存一致性模型要求：</strong>由于prwlock依赖于一系列的内存操作事前发生关系，因此它要求内存存储操作被执行并按发布顺序对其他用户可见（TSO一致性）。像x86-64，SPARC和zSeries等常用处理器都是这个架构。</p></li></ul><h2 id="分布式并行唤醒"><a href="#分布式并行唤醒" class="headerlink" title="分布式并行唤醒"></a>分布式并行唤醒</h2><h3 id="集中式顺序唤醒的问题"><a href="#集中式顺序唤醒的问题" class="headerlink" title="集中式顺序唤醒的问题"></a>集中式顺序唤醒的问题</h3><p>睡眠/唤醒是一种常见的OS机制，该机制允许任务暂时睡眠以等待特定事件发生（例如I / O事件）。Linux操作系统使用共享队列来保存所有等待的任务。通常是signaling task负责唤醒所有等待的任务。为此，signaling task首先使任务从共享任务队列中出队，然后执行一些操作以准备唤醒任务。接下来，调度程序为任务选择一个core，然后将该任务插入cpu运行队列中。最后，调度程序将重新调度的IPI发送到目标内核，以便唤醒的任务可能有机会被调度。内核将重复发送IPI，直到重新安排了所有唤醒的任务。</p><p>这种集中的顺序唤醒机制存在多个问题。一，共享等待队列可能会成为瓶颈，因为尝试进入睡眠的多个内核可能会争用该队列。因此，我们的第一步涉及使用无锁唤醒队列，以便可以减轻锁争用。但这只能稍微提高性能。<br>进一步调查发现，主要的性能可伸缩性问题来自级联的唤醒现象。当写者离开其写侧临界区时，它需要唤醒所有等待它的读者。由于有多个读者在等待写者，写者会顺序唤醒所有读者。因此等待时间与读者数量成线性增长。</p><h3 id="分布式并行唤醒-1"><a href="#分布式并行唤醒-1" class="headerlink" title="分布式并行唤醒"></a>分布式并行唤醒</h3><p>为了加快此过程，prwlock在内核之间分配了唤醒任务的职责。一般来讲，这会带来优先级倒置的风险，但所有读者始终具有相同优先级，所以就不存在什么问题了。</p><p><img src="https://i.loli.net/2020/03/25/ECLQfDs536FGhmk.png" alt="被动读写锁_parallel_wakeup.png"> </p><p>上图展示了分散并行唤醒中使用的关键数据结构。每个内核维护一个唤醒队列（PWake-queue），以保持在此类队列中休眠的任务，每个任务均在唤醒条件字下休眠。</p><p>当任务从运行态进入睡眠状（步骤1）时，该任务将从CPU运行队列Run-queue中删除，并插入到CPU唤醒队列PWake-queue中。在进入调度程序之前，如果内核指示存在待处理的请求（例如，通过检查唤醒计数器），则每个内核都先查看PWake-queue中是否存在tasks meet their conditions，如果存在，它将被插入Run-queue。由于所有操作都在每个core的本地完成，所以不需要原子操作和内存屏障。在检查了PWake-queue之后，每个内核将执行其调度程序（步骤2）以选择要执行的任务（步骤3）</p><p>为了解决集中式顺序唤醒的问题，唤醒机制允许每个空闲core使用monitor &amp; mwait instructions to sleep on a global word（步骤4）当写者完成工作并发出信号以唤醒其等待的任务时，写者touch the word以唤醒空闲的内核，然后该内核将开始检查是否应唤醒唤醒队列中的任何任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prwlock 为TSO架构系统提供了可扩展读者侧性能和写者低延迟，其关键在于多个无交互读者和一个不确定写者间基于version的共识协议。Prwlock 利用内存一致性的有界旧一致性(bounded staleness)来避免读者侧的原子操作和内存屏障，同时用消息传递(IPI)落伍的读者来限定写锁获取延迟。
    
    </summary>
    
    
      <category term="Sys" scheme="https://stardust567.github.io/categories/Sys/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="rwlock" scheme="https://stardust567.github.io/tags/rwlock/"/>
    
      <category term="OS" scheme="https://stardust567.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>FSCQ文件系统</title>
    <link href="https://stardust567.github.io/post/3d2c.html"/>
    <id>https://stardust567.github.io/post/3d2c.html</id>
    <published>2020-03-09T13:22:37.000Z</published>
    <updated>2020-04-01T01:33:11.709Z</updated>
    
    <content type="html"><![CDATA[<p>FSCQ：可以应对crash的文件系统，with a machine-checkable proof (using the Coq proof assistant) 为说明FSCQ的定理，本文介绍了Crash Hoare Logic（CHL），它扩展了传统的Hoare逻辑，包括崩溃条件，恢复过程和用于指定不同抽象级别磁盘状态的逻辑地址空间。<a id="more"></a></p><h1 id="FSCQ论文"><a href="#FSCQ论文" class="headerlink" title="FSCQ论文"></a>FSCQ论文</h1><h2 id="基础背景"><a href="#基础背景" class="headerlink" title="基础背景"></a>基础背景</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>为避免操作系统知识的遗忘而影响接下来的阅读体验，这里简单给出一点OS文件系统的基础知识。</p><p>所谓文件系统，就是文件的储存方式。简单说，它就是一个门牌系统，为储存设备划分门牌号，每个文件分配一个门牌，然后就能按照门牌找到文件。没有文件系统的硬盘，就是片原始丛林，你根本不知道那户文件住在哪，就更别谈去高效访问了。</p><h4 id="文件存取单位"><a href="#文件存取单位" class="headerlink" title="文件存取单位"></a>文件存取单位</h4><p>文件储存在硬盘上，硬盘最小存储单位叫做<strong>扇区</strong>（Sector），每个扇区储存512字节（0.5KB）但OS读取硬盘时，不会一个个扇区地读取，而是一次性连续读取多个扇区以提高效率，即一次性读取一个<strong>块</strong>（block）。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个 sector 组成一个 block。</p><h4 id="索引节点-iNode"><a href="#索引节点-iNode" class="headerlink" title="索引节点 iNode"></a>索引节点 iNode</h4><p>文件数据都储存在块中，但还须找个地方来储存文件的元信息，比如文件的创建者、创建日期、文件大小等。这种储存文件元信息的区域就叫做<strong>索引节点</strong>（inode）。每一个文件都有对应的inode，里面包含了<em>除文件名外</em>与该文件有关的一些信息。Unix系统内部不使用文件名，而用inode号码来识别文件。对系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上用户通过文件名打开文件，实际上系统内部这个过程分成三步：1. 系统找到该文件名对应的inode号码；2. 通过inode号码，获取inode信息；3. 根据inode信息，找到文件数据所在的block，读出数据。</p><h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><p>Unix系统中目录（directory）也是一种文件。打开目录，实际是在打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项由两部分组成：文件名和该文件名对应的inode号码。</p><p>以ls命令为例，ls命令只列出目录文件中的所有文件名；ls -i命令列出整个目录文件，即文件名和inode号码；ls -l查看文件的详细信息，即必须要根据inode号码，访问inode节点。</p><p>目录文件的读权限r和写权限w，都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限x。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>Unix系统允许多个文件名指向同一个inode号码。也即可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但删除一个文件名，不影响另一个文件名的访问。这种被称为<strong>硬链接</strong>（hard link）</p><p>运行ln命令后，源文件与目标文件的inode号码相同，即指向同一个inode。inode信息中有一项叫做”链接数Links”，记录指向该inode的文件名总数，这时就会加1。反过来，删除一个文件名，inode节点中Links减1。当Links值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码及其所对应block区域。</p><p>目录文件的链接数：创建目录时，默认生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的硬链接；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的硬链接。所以，任何一个目录的硬链接总数，总是等于2加上它的子目录总数（含隐藏目录）。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>除硬链接外，还有种特殊情况，文件A和文件B的inode号码虽然不一样，但文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。即无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的<strong>软链接</strong>（soft link）或<strong>符号链接</strong>（symbolic link）。软链接类似于Windows的快捷方式，ln -s命令可以创建软链接。文件A依赖文件B存在，如果删除文件B，打开文件A就会报错：<em>No such file or directory</em>。</p><h4 id="iNode特殊作用"><a href="#iNode特殊作用" class="headerlink" title="iNode特殊作用"></a>iNode特殊作用</h4><p>由于inode号码与文件名分离，这种机制导致了一些Unix系统特有的现象：</p><ol><li>有时文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li><li>移动文件或重命名文件，只改变文件名，不影响inode号码。</li><li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li></ol><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><h4 id="数据缓存区"><a href="#数据缓存区" class="headerlink" title="数据缓存区"></a>数据缓存区</h4><p>访问磁盘比访问内存要慢几个数量级，因此需要在内存中维护一块磁盘的数据缓存区。 在读取磁盘时，先从缓冲区中查找想要读取的块是否已经缓存了，如果没有的话才会到磁盘去把数据块取回来，在写磁盘时，也会先把数据写到缓存区。如果缓存区已满，则通常会把最不常访问的数据驱逐出缓存区，为新的数据腾出空间。数据缓冲区在写时，可以选择直接将数据同步写到磁盘里（直写），或者将写延迟，直到数据块被驱逐的时候再写（写回）。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><code>$ who &gt; userlist</code> 在文件系统中增加了一个存放命令who输出内容的新文件。</p><ol><li>存储属性：也就是文件属性的存储，内核先找到一块空的inode节点（内核找到inode节点号47）内核把文件元信息记录其中，如文件的大小、文件所有者、和创建时间等。</li><li>存储数据：即文件内容的存储，假设该文件需要3个数据块。因此内核从自由块的列表中找到3个自由块（中分别为627、200、992，内核缓冲区的第一块数据复制到块627，第二和第三分别复制到200和992）</li><li>记录分配情况：数据保存到了627、200、992三个数据块中，分配情况记录在文件的inode节点中的磁盘序号列表里。这3个编号分别放在最开始的3个位置。</li><li>添加文件名到目录：新文件的名字是userlist，  内核将文件的入口 <em>(47,userlist)</em>  添加到目录文件里。文件名和inode节点号之间的对应关系将文件名和文件及其内容属性连接起来，找到文件名就找到文件的inode节点号，通过inode节点号就能找到文件的属性和内容。</li></ol><p><img src="https://i.loli.net/2020/03/30/RtJNuL6VY2dwOny.gif" alt="FSCQ_createFile.png"></p><p><code>cp /path/src /path/dst</code> 在path路径下新建dst文件，内容为同目录下的src文件内容。<br>文件系统首先需要从目录树中定位src文件位置，为此，它在根目录条目中找到“path”（通常已经缓存在数据缓存区里），拿到 path 的索引值 ipath，将path的目录条目加载到数据缓存区中，定位和名称“src”相对应的索引值isrc， 然后文件系统读取 isrc 索引节点的文件内容。要创建目标文件，文件系统将分配一个新的索引节点 idst，并在 inode 分配位图中标记为已使用，然后根据 src 文件大小来给 dst 文件分配新的磁盘块，在 idst 中记录分配的块号，并且在块的的数据位图中将其标记为已使用，再将 src 的内容写入到新分配的块中。最后，文件系统将一个新的目录条目 （“dst”，idst）添加到 path 的目录条目中，并将目录的新内容写回到磁盘里。注意：此处的顺序并不能保证崩溃安全性。</p><h3 id="崩溃安全性"><a href="#崩溃安全性" class="headerlink" title="崩溃安全性"></a>崩溃安全性</h3><p>应用完成某个操作可能涉及到多次写磁盘，该过程中系统可能随时崩溃，有可能一个写操作只完成一部分，崩溃后磁盘会处于一个中间状态，这个状态下数据可能不一致，因此再重启之后通常需要运行一个恢复程序，检查磁盘的状态，将其恢复到一个数据一致的状态，以便将来能继续正确执行程序，文件系统的这种属性称为崩溃安全性。 </p><h3 id="写屏障（磁盘同步）"><a href="#写屏障（磁盘同步）" class="headerlink" title="写屏障（磁盘同步）"></a>写屏障（磁盘同步）</h3><p>现代硬盘驱动通常会增加一层缓存来优化 I/O 实际写入磁盘的顺序，即发给磁盘的写入不会立即持久化，最近的写往往会被缓存在内部缓存中，并由硬盘驱动器决定什么时候会将这些未完成的写刷到磁盘。同时，硬盘驱动器可以对这些写重新排序进行写入以提高磁盘吞吐量。假如系统没有崩溃，一个读总是能够读到最新写得值，但假如系统崩溃并重启，可能会发现崩溃之前稍后发出的写持久到了磁盘，但是之前的写却没有。</p><p>硬盘驱动器提供了写屏障操作，称为磁盘同步，这会强制将写的缓存全部刷到磁盘上，磁盘同步操作可以用来保证不会有未完成的写操作，之前所有的写都会保留在磁盘上。但是磁盘同步非常的耗时，应当尽可能的避免，而这种异步的 I/O 使得论证崩溃安全性变得更加复杂。 </p><h3 id="预写式日志-WAL"><a href="#预写式日志-WAL" class="headerlink" title="预写式日志 WAL"></a>预写式日志 WAL</h3><p>许多文件系统操作涉及多个对磁盘的写。例如，创建文件至少涉及两个写操作，分配未使用的索引节点，并将索引节点添加到父目录中。如果系统在两次写之间崩溃，则索引节点在索引节点位图中可能被标记为已经使用，但却不属于任何一个目录。 文件系统一般会实现<strong>事务保证原子性+预写日志</strong>来解决这个问题，以确保系统崩溃重新启动的时候，磁盘上的数据结构处于一致的状态。磁盘通常会分配一块固定的区域给日志，日志通常由两部分构成，一部分是连续的日志条目，每个日志条目记录希望对磁盘进行的写操作，另一部分是 一个单一的提交块，记录日志条目的数量。</p><h3 id="日志协议"><a href="#日志协议" class="headerlink" title="日志协议"></a>日志协议</h3><p>一个基本的日志协议工作如下：（1）日志记录系统为文件系统的一个操作开启一个事务log_begin() （2）对于该操作引发的每一个磁盘写入的地址和值，日志记录系统向日志条目附加一个新的地址/值对log_write() （3）当日志记录系统提交事务log_commit()时，它会发出一个磁盘<strong>同步</strong>来保存磁盘上的日志条目，然后更新提交块以反映日志的长度，然后再次<strong>同步</strong>磁盘以完成这个事务（4）日志系统将日志中的修改应用到实际的磁盘位置，并发出磁盘<strong>同步</strong>将更改持久化到磁盘上（5）最后，将零写入提交块来截断日志，并<strong>同步</strong>到磁盘上（6）无论何时系统崩溃并重新启动，都会运行恢复过程。它根据提交块的长度读取日志；如果日志不为空，则跳到步骤（4）重新执行。 </p><p>上述协议的正确性依赖于一个重要的假设：更新提交块是原子的同步的操作。原子性确保了提交块上要么是原长度，要么是新长度，同步则保证了磁盘控制器不会对磁盘的写操作进行重新排序，将提交块的写和其他的写调换顺序，这是通过在更新提交块之前和之后发出两个屏障（磁盘同步操作）来强制执行。在这个协议下，在事务中途，还没有更新提交块之前系统崩溃的话，提交块的长度为零，此时磁盘的数据没有被写，这个事务就像没有执行一 样，数据处于一致的状态；提交之后但在应用完成之前的系统崩溃将导致提交块长度非零，并且日志中包含相同数目的有效条目，这时就只需要重新执行提交操作，会达到事务执行完的状态。 这个基本的日志协议会增加磁盘写操作以及耗时的磁盘同步操作。例如，写入单个磁盘块的操作将需要完成四次磁盘写入（两次为提交块，两次为块的内容）和四个磁盘同步（上文加粗处）。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def atomic_two_write(a1, v1, a2, v2): </span><br><span class="line">log_begin() </span><br><span class="line">log_write(a1, v1) </span><br><span class="line">log_write(a2, v2) </span><br><span class="line">log_commit()</span><br></pre></td></tr></table></figure><p>该过程使用预写日志在事务内部执行两次磁盘写操作，该日志提供log_begin，log_commit和log_write的API，log_write() 将块的内容追加到内存日志中，而不是直接更新磁盘块。log_commit() 将日志写入磁盘，写入提交记录，然后将块内容从日志复制到磁盘上的块位置。如果此过程崩溃且系统重新启动，则将运行事务系统的恢复过程。恢复过程将查找提交记录。如果存在提交记录，它将通过将日志中的块内容复制到正确的位置来完成事务，然后清除日志。如果没有提交记录，则恢复过程仅清除日志。<br>如果恢复期间发生崩溃，则重新启动后，恢复过程将再次运行。不管崩溃多少次，只要恢复完成，则两个块要么都已更新，要么都未更新。因此，atomic_two_write过程中，事务系统保证无论怎么崩溃，两次写入要么都发生，要么都不发生。</p><h3 id="日志优化"><a href="#日志优化" class="headerlink" title="日志优化"></a>日志优化</h3><ol><li><p>延迟应用日志：日志系统提交事务后，并不立即应用日志，而是等日志填满后，再一次性将日志内容应用。可以将每个事务的磁盘同步由四个 降为两个，同时将写磁盘的次数也由四次降为两次。</p></li><li><p>组提交：在内存中累积多个系统调用的写入，并将其合并到单个事物当中。</p></li><li><p>其实还有蛮多优化的，这里就不一一列举了……反正论文后续也用不太到。</p></li></ol><h2 id="CHL框架"><a href="#CHL框架" class="headerlink" title="CHL框架"></a>CHL框架</h2><p>CHL (Crash Hoare Logic) 框架是用 Coq 实现的用来书写规范的框架，它允许文件系统开发人员编写包含崩溃条件和恢复过程的规范，并提供了较好的证明自动化的支持。这涉及到了形式化验证的知识，我也只是刚有个模糊的认识。FSCQ 是从 Coq 提取出 Haskell 代码，再进一步获得可执行的文件系统，因此具有较高的 CPU 开销。</p><blockquote><p>Haskell是一门纯粹的函数式编程语言。</p><p>Coq 是一种基于构造演算的证明助手，被用于形式化各种领域的证明，包括数学和编程语言。如果对其感兴趣想了解更多，可以参照此网站进一步学习 -&gt; <a href="https://github.com/coq/coq/wiki#coq-tutorials" target="_blank" rel="noopener">https://github.com/coq/coq/wiki#coq-tutorials</a></p></blockquote><h3 id="磁盘模型"><a href="#磁盘模型" class="headerlink" title="磁盘模型"></a>磁盘模型</h3><p>磁盘被定义成从整数块号a到内容v的偏函数a → v，其中超过磁盘范围的块号不会映射到任何东西。 </p><p>因为I/O写入并不是同步的，中间会经过buffer异步写入磁盘。为了捕获这种异步的性质，CHL 用一个值集（v,vs）来描述一个块的内容，而不是一个单一的值，其中 v 代表着这个地址最近写入的值， 而 vs 是一系列的之前写入的值，假如系统突然崩溃，v 和 vs 中的任何一个值都可能出现在磁盘上。而磁盘同步操作意味着对应的缓存已经全部应用到该地址上，先前写入的值已经全部处理，即 vs 为 ∅，最新的值会出现在崩溃之后，否则，这个磁盘块就是未同步的。 CHL 的磁盘模型假设块是原子写的，也就是说，在系统崩溃之后，块必须包含最后写入的值或者是先前值中的一个，并且不允许部分块写入。 </p><h3 id="崩溃条件"><a href="#崩溃条件" class="headerlink" title="崩溃条件"></a>崩溃条件</h3><p>给定了异步磁盘模型，我们还需要一种手段来描述可能崩溃的中间状态，CHL 将霍尔逻辑扩展成一个具有崩溃条件的四元组， 写为：{P}C{Q}{R} 其中 P 是前置条件，描述C过程之前应满足的状态；Q 是后置条件，描述 C 在没有崩溃情况下执行结束时的状态，而 R 是描述 C 执行过程中可能发生的中间状态的崩溃条件。 我们以disk_write(a, v)举例：</p><p>前置条件：<code>a -&gt; (v0, vs) * other_blocks</code><br>后置条件：<code>a -&gt; (v, {v0} U vs) * other_blocks</code><br>崩溃条件：<code>a -&gt; (v0, vs) * other_blocks ∨ a -&gt; (v, {v0} U vs) * other_blocks</code></p><p>推理过程disk_write(a, v)，即把值v写到地址a上。其前置条件声明的是磁盘上地址 a 的地方指向的值是一个集合，v0是最新写入的值，vs则表示之前写入的值的序列，除 a 以外的地址满足谓词<code>other_blocks</code>；其后置条件说的是 a 以外的值依旧满足谓词other_blocks，而地址 a 指向的值的集合中，最新元素是v，旧的值则是由vs加上v0组成的序列；由于磁盘写是一个原子操作，因此它要么完成了值的写入，要么没有完成，因此可能发生系统崩溃时有两种状态，一是前置条件的状态，二是后置条件的状态，通过将前置条件和后置条件并起来则表示了系统崩溃时可能的所有状态，即系统崩溃时必须满足的谓词。</p><p>磁盘写的规范说明还表明了真实磁盘的两个重要行为，保证了磁盘的性能：</p><ul><li>磁盘实际 I/O 可以异步发生 </li><li>磁盘的写可以重新排序</li></ul><p>因为一个地址a会指向一组值而不是一个值，指向一组值表明系统崩溃恢复的时候，磁盘上的值可能是之前的某个值，而不同地址之间可能会呈现出不一致的状态，这也表明了磁盘对写进行了重新排序。</p><p>CHL 的崩溃条件有一个微妙的地方，他们描述的是系统崩溃之前磁盘的状态，而不是系统崩溃之后。在崩溃后，CHL 磁盘模型认为，每个块将从崩溃之前的值的集合中选择一个值，例如disk_write(a, v)的前置条件中表明，磁盘的 a 地址指向的可能是一系列值的集合，而不是一个值（明确表示a地址只指向一个值时，需要声明a → (v, ∅) 即之前写入序列为空集）这样的好处就是，崩溃条件会跟前置条件和后置条件类似，有利于证明自动化。 </p><h3 id="逻辑地址空间"><a href="#逻辑地址空间" class="headerlink" title="逻辑地址空间"></a>逻辑地址空间</h3><p>文件系统的许多地方涉及到逻辑地址空间。例如，磁盘是从磁盘块号到磁盘块内容的地址空间；文件索引层是从文件索引号到文件索引的地址空间；每个文件里，是从该文件中的偏移量到数据的地址空间；目录是从文件名到索引节点号的地址空间。基于这个观察，CHL 扩展了关于磁盘推理的分离逻辑， 使其以同样的方式表达诸如文件，目录或逻辑文件内容的更高级的地址空间。 </p><p>作为逻辑地址空间的实例，我们考虑 inc_two 的简单过程，inc_two 表达在一个操作中需要同时更新两个块的文件系统调用。我们先读取两个块的内容，然后将这两个块的内容加一，再写回。该过程使用日志系统提供的 log_begin 开始一个事务，用 log_read 来读取数据，然后用 log_write 来写数据，最后用 log_commit 来提交事务。假如在执行 inc_two 的过程中发生了系统崩溃并且重新启动，首先系统会运行 log_recover 这个恢复程序，如果在恢复过程中依然发生系统崩溃，则重新启动后，恢复过程将再次运行。原则上来说恢复过程可能运行若干次。尽管如此，只要 log_recover 完成， 日志记录系统就能保证两个写入要么都发生，要么都没有发生，不管经历了多少次系统崩溃。</p><p>为了简化说明，我们假设现在的日志系统只是采用前面所述的基础的日志协议:</p><p>SPEC  <code>inc_two(a1, a2)</code></p><p>PRE <code>disk: log_rep(NoTxn, start_state)</code><br><code>start_state: a1 → (v_x, vs_x) ⋆ a2 → (v_y, vs_y) ⋆ others</code></p><p>POST <code>disk: log_rep(NoTxn, new_state)</code><br><code>new_state: a1 → (v_x+1, ∅) ⋆ a2 → (v_y+1, ∅) ⋆ others</code></p><p>CRASH <code>disk: log_intact(start_state, new_state)</code></p><p>前置条件中，a1 → (v_x, vs_x) 适用于日志系统提供的逻辑磁盘的地址空间，后置条件中，a1 → (v_x+1, ∅) 适用于逻辑磁盘的新的内容。就像物理磁盘一样，这个地址空间也是从地址到值的偏函数。<strong>与物理磁盘不同的是，通过日志系统写入逻辑磁盘的操作展现的是一个同步的接口，即整个操作完成之后，能保证要写入地址的值被刷到磁盘上</strong>，因此在后置条件中，我们看到的是单个同步的值，这层抽象做的具体的事情就是隐藏更下层的异步的接口，这也是引入地址空间的好处。 </p><p>我们在 log_rep 将逻辑地址空间和实际的物理磁盘连接起来。例如，log_rep(NoTxn, start_state) 表示磁盘没有活动事务，并且处于状态start_state。。通过 log_rep 的这层转化，对逻辑地址空间的描述将会变成对物理磁盘的描述，并且隐藏了一 些琐碎的细节。log_rep 将会把逻辑地址空间作为参数，结合日志系统的状态和逻辑磁盘状态准确的反映出物理磁盘上的状态。日志系统中有好几个可能的状态：</p><ol><li>NoTxn ：表示当前磁盘没有事务活动。</li><li>ActiveTxn ：表示活跃状态中的事务所有的修改只会发生在内存中。</li><li>FlushedUnsync ：表示此时开始进入提交事务的过程，首先把内存中的修改刷到数据缓冲区的日志记录区中，Unsync表示还没有刷到磁盘上。</li><li>Flushed ：表示此时有了一次磁盘同步，已经将日志数据区的内容刷到了磁盘上。</li><li>CommittedUnsync ：表示我们现在将提交块写到了数据缓冲区里，但还没有同步到磁盘里。</li><li>Committed ：表示提交块被同步到了磁盘里，这个点之前和之后作为事务是否完成的分界点。</li><li>AppliedUnsync ：表示现在已经开始将数据缓存区里日志的内容实际应用到磁盘上。</li><li>AppliedSync ：表示日志应用的工作已经完全反映到了磁盘上，整个事务至此完成。 </li></ol><p>崩溃条件中使用的 log_intact(d1, d2) 表示可以使过程C崩溃的所有状态，该状态代表恢复到事务状态d1或d2的所有可能的log_rep状态。log_intact(start_state, new_state) 可使我们简洁地捕获atomic_two_write期间所有可能的崩溃状态，包括atomic_two_write可能调用的任何过程内部的崩溃（例如log_commit内的崩溃）</p><h3 id="恢复执行语义"><a href="#恢复执行语义" class="headerlink" title="恢复执行语义"></a>恢复执行语义</h3><p>计算机遇到崩溃并重新启动后，它会在恢复正常操作前先运行恢复程序（如 log_recover）。崩溃条件和地址空间可以指定计算机在执行过程中可能会崩溃的状态， 但还需要一种证明恢复过程正确性的方法（包括恢复期间的系统崩溃）。日志系统必须在每次崩溃后运行 log_recover 来将已提交的事务继续做完，包括在运行 log_recover 本身发生崩溃之后。 log_recover 指出，从与 log_would_recover(last_state, committed_state) 相匹配的任何状态开始，log_recover 会将事务回滚到 last_state 或将提交的事务继续执行到 committed_state。此外，log_recover 的规范是幂等的，因此它的崩溃条件等同于其前置条件，这将允许 log_recover 在执行的过程中崩溃多次。</p><p>SPEC <code>log_recover()</code><br>PRE <code>disk: log_intact(last_state, committed_state)</code><br>POST <code>disk: log_rep(NoTxn, last_state) ∨ log_rep(NoTxn, committed_state)</code><br>CRASH <code>disk: log_intact(last_state, committed_state)</code></p><p>为了表达 log_recover 在遇到崩溃之后运行，CHL 提供了恢复执行语义。恢复执行语义考虑了两个程序的执行，一个是正常程序，一个是恢复程序，并且要么产生一个错误，一个完成状态（正常程序完成执行）或者一个恢复状态（恢复程序完成执行）。这种模型下，首先正常程序尝试完成，但如果系统崩溃，它将开始运行恢复程序，如果再回复过程中系统崩溃，有可能需要多次运行恢复程序，最终达到恢复状态的过程。</p><p>由此我们对崩溃霍尔逻辑扩展恢复执行语义，扩展后{P}C≫R{Q}表示，假如 C 在满足前置条件 P 下执行，且每当系统在 C 崩溃或 R 自身崩溃时执行恢复过程 R，则当 C 或 R 终止时，条件 Q 将成 立。 我们可以由此扩展 inc_two 规范以包括恢复执行：</p><p>SPEC  <code>inc_two(a1, a2) ≫ log_recover</code></p><p>PRE <code>disk: log_rep(NoTxn, start_state)</code><br><code>start_state: F ⋆ a1 → (v_x, vs_x) ⋆ a2 → (v_y, vs_y)</code></p><p>POST <code>disk: log_rep(NoTxn, new_state) ∨ (status = recovered ∧ log_rep(NoTxn, start_state))</code><br><code>new_state: F ⋆ a1 → (v_x+1, ∅) ⋆ a2 → (v_y+1, ∅)</code></p><p>后置条件表示，如果 inc_two 在没有崩溃的情况下完成，则两个块都已经更新，或者两者都没有更新，这时一定是因为发生了崩溃，运行恢复程序之后达到了原状态。状态变量 status 指示系统当前状态。</p><h2 id="证明规范"><a href="#证明规范" class="headerlink" title="证明规范"></a>证明规范</h2><h3 id="证明自动化"><a href="#证明自动化" class="headerlink" title="证明自动化"></a>证明自动化</h3><p>为证明一个程序 C 是正确的，我们需证明如果 C 执行，且执行前 C 前置条件成立，那么，C 的后置条件的正常运行之后成立，且恢复条件在恢复程序运行之后成立。</p><p> 正常执行下，我们必须证明顶层程序的前置条件蕴含第一个子过程的前置条件，第一个子程序的后置条件蕴含着接下来要执行程序的前置条件，并这样一直下去。 对于崩溃，我们则必须证明每个过程的崩溃条件都蕴含这恢复程序的前置条件，恢复程序的后置条件蕴含着顶层程序的恢复条件。 在这两种情况下，逻辑蕴涵关系都按着控制流的方向传递，在 CHL 框架里面，有用策略语言写好的证明搜索的 Ltac 程序，假如前置条件很容易被之前程序的后置条件蕴涵，那么 Ltac 程序可以自动完成这个过程，开发人员不需要进行手动的证明，在实际中，通常开发人员只需要证明程序的不变量的成立。</p><h3 id="证明崩溃条件规范"><a href="#证明崩溃条件规范" class="headerlink" title="证明崩溃条件规范"></a>证明崩溃条件规范</h3><h4 id="程序分解"><a href="#程序分解" class="headerlink" title="程序分解"></a>程序分解</h4><p>CHL 的第一个阶段是使用 <em>组合规则</em> 将证明目标分解成一系列的证明义务。具体来说，CHL 会考虑 C 中的每个步骤，并查看每个步骤的前置条件和后置条件，假设每个小的步骤已经有一个证明好了的规范，比如最基本的磁盘读写，同步操作。CHL 首先假设 C 前置条件成立，并为每个步骤产生两个证明义务，（1）当前所能给定的条件，要么是 C 的前置条件（即当前步骤为第一步骤），要么是前一个步骤的后置条件，不管是那种情况，都要求给定条件能蕴涵当前步骤的前置条件；（2） 当前步骤的崩溃条件蕴涵 C 的崩溃条件（小范围推出大范围）。而对程序 C 的最后一个小步骤，会产生最后一个步骤蕴涵 C 的后置条件的证明义务。</p><blockquote><p>组合规则：{P1}C1{P2}{R1}  {P2}C2{P3}{R2}B -&gt; {P1}C1; C2{P3}{R1∨R2}<br>正常运行，P1→C1→P2→C2→P3；如若崩溃，可能在C1可能在C2，故用∨</p></blockquote><h4 id="谓词蕴涵"><a href="#谓词蕴涵" class="headerlink" title="谓词蕴涵"></a>谓词蕴涵</h4><p>有些程序分解之后产生的证明义务很容易证明，CHL 根据一阶逻辑会立即证明这个蕴涵成立。 对更复杂的情况，CHL 会依赖于分离逻辑的 <em>结构规则</em> 来证明。当 inc_two 第一次调用 log_write 时，我们需要证明<code>F1 ⋆ a1 → (v_x, vs_x) ⋆ a2 → (v_y, vs_y) 蕴涵 F ⋆ a → (v0, vs0)</code>，CHL 会自动将 a1 → (v_x, vs_x) 与a → (v0, vs0)  匹配，并将这些项从证明义务的两边同时去掉，然后将 F 匹配为F1 ⋆ a2 → (v_y, vs_y)，这样会将这个证明义务完成，然后将a2 → (v_y, vs_y) 的信息带入到接下来的证明义务中。</p><blockquote><p><strong>蕴涵</strong>：如果P，那么Q，表示为P→Q。蕴涵式中，只有当P真Q假时判断为假，其余均为真。<br>结构规则：{P}C{Q}{R}  -&gt;  {P⋆S}C{Q⋆S}{R⋆S}</p></blockquote><h3 id="证明恢复语义规范"><a href="#证明恢复语义规范" class="headerlink" title="证明恢复语义规范"></a>证明恢复语义规范</h3><p>如果恢复程序是幂等的，CHL 可以使用崩溃条件的规范直接来证明具有恢复条件的规范，证明恢复规范的规则称为恢复规则：对程序C有 {P}C{Q}{T} 当崩溃条件T触发时，启用恢复语义 {T}R{S}{T} 即可推出 {P}C≫R{Q∨S}</p><p>恢复规则说的是假如恢复过程的前置条件既是C的崩溃条件又是自身的崩溃条件，如果 C 和 R 的后置条件分别是 Q 和 S，那么将C和R一起运行的结果就是Q∨S</p><h2 id="文件系统构建"><a href="#文件系统构建" class="headerlink" title="文件系统构建"></a>文件系统构建</h2><p>FSCQ参照xv6文件系统设计，但不支持多处理器，同时采用单独的位图来分配索引节点。</p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>FscqLog提供了一个简单的预写日志，FSCQ使用它来原子地更新几个磁盘块。其他组件提供标准文件系统抽象的简单实现。缓存模块提供缓冲区缓存。 Balloc实现了一个位图分配器，用于块和inode分配。索引节点实现索引节点层；这里最有趣的逻辑是将直接块和间接块组合在一起，形成单个块地址列表。 Inode调用Balloc分配间接块。 BFile实现了一个块级文件接口，在更高级别上公开了一个接口，其中每个文件都是一个块列表。 BFile调用Balloc分配文件数据块。 Dir在块级文件的顶部实现目录。 ByteFile实现文件的字节级接口，其中每个文件都是字节数组。 DirTree将目录和字节级文件组合为分层目录树结构；在创建/删除文件或子目录时，它调用Balloc来分配/取消分配索引节点。最后，FSCQ在事务中实现完整的系统调用。</p><h3 id="磁盘模型-1"><a href="#磁盘模型-1" class="headerlink" title="磁盘模型"></a>磁盘模型</h3><p>FSCQ 崩溃后，并非每次发出的写入都将反映在磁盘状态中。 CHL模型的另外两个磁盘操作是读取磁盘块（disk_read），并等待所有写操作到达非易失性内存（disk_sync）disk_sync将块地址作为附加参数，以指示必须同步的块。 disk_sync的按地址变体会丢弃该块的所有先前值，从而使最后写入的值成为崩溃后可能出现的唯一可能值。在执行时，每个地址disk_syncs的连续调用被折叠为单个全局disk_sync操作，以实现所需的性能。</p><h3 id="POSIX接口"><a href="#POSIX接口" class="headerlink" title="POSIX接口"></a>POSIX接口</h3><p>FSCQ在顶层提供类似于POSIX的接口。 与POSIX的主要区别是：FSCQ不支持硬链接，以及 FSCQ不实现文件描述符，而是需要按索引节点编号命名打开的文件。 FSCQ依靠FUSE驱动程序来维护打开文件描述符和inode编号之间的映射。</p><h3 id="FscqLog"><a href="#FscqLog" class="headerlink" title="FscqLog"></a>FscqLog</h3><p>FscqLog一次仅允许一个事务，并假定内存足够大以容纳当前事务的内存日志。但即使对于这种简单的设计，日志记录协议也很复杂，因为disk_write是异步的。崩溃后，FSCQ的恢复过程fs_recover读取布局块以确定日志的位置，然后调用FscqLog的log_recover将磁盘置于一致状态。<br>FSCQ仅通过log_write更新磁盘，并将这些写入以sysCall的粒度包装到事务中，以实现崩溃安全。此外，它为上级软件提供了一个更简单的同步接口。因为事务API公开了一个逻辑地址空间，该逻辑地址空间会将每个块映射到唯一的块内容，哪怕物理磁盘会将每个块映射到最后写入值和一组先前值的元组。因此，在FscqLog之上编写的软件不必担心异步写入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FSCQ：可以应对crash的文件系统，with a machine-checkable proof (using the Coq proof assistant) 为说明FSCQ的定理，本文介绍了Crash Hoare Logic（CHL），它扩展了传统的Hoare逻辑，包括崩溃条件，恢复过程和用于指定不同抽象级别磁盘状态的逻辑地址空间。
    
    </summary>
    
    
      <category term="Sys" scheme="https://stardust567.github.io/categories/Sys/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="OS" scheme="https://stardust567.github.io/tags/OS/"/>
    
      <category term="CHL" scheme="https://stardust567.github.io/tags/CHL/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="https://stardust567.github.io/post/c51c.html"/>
    <id>https://stardust567.github.io/post/c51c.html</id>
    <published>2020-02-16T05:59:44.000Z</published>
    <updated>2020-03-09T13:37:38.486Z</updated>
    
    <content type="html"><![CDATA[<p>结合 MIT-6.824-2018 的各个 lab 来简单写下学习分布式系统的学习心得。</p><p>目前主要有：MapReduce, Raft（期待后续更新中）<a id="more"></a></p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="MapReduce-Paper"><a href="#MapReduce-Paper" class="headerlink" title="MapReduce Paper"></a>MapReduce Paper</h2><h3 id="MapReduce-Example"><a href="#MapReduce-Example" class="headerlink" title="MapReduce Example"></a>MapReduce Example</h3><p>我们用最经典的words count来举例介绍MapReduce模型：</p><p>对于一个三行的input file来说，我们按行进行splitting操作。每行分给不同的线程/节点，各节点单独进行mapping任务（单词分割）。各节点在shuffing阶段会进行相互通信，完成“洗牌”工作。然后各节点单独完成reducing任务并将结果输出在各节点本地文件上。最后将这些文件进行归并得到final result。</p><p><img src="https://i.loli.net/2020/02/18/hQyazOdRUK4YJHF.png" alt="Example"></p><h3 id="MapReduce-Execution"><a href="#MapReduce-Execution" class="headerlink" title="MapReduce Execution"></a>MapReduce Execution</h3><p><img src="https://i.loli.net/2020/02/16/QYdfgVnj4aubP6s.png" alt="Execution Overview"></p><ol><li>用户程序调用 MapReduce 库将 Input files 切成 M 个数据片度，然后用户程序在机群中 fork 大量程序副本。</li><li>Fork 的副本中有一个特殊的程序 master，其它都是 worker 程序，由 master 分配任务。有 M 个 Map Task 和 R 个 Reduce Task 将被分配，master 将一个 Map/Reduce Task 分配给一个空闲的 worker。</li><li>被分配 map task 的 worker 读取相关的输入数据片段并解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出中间 key/value pair，并缓存在内存中。 </li><li>缓存中的 key/value pair 通过分区函数分成 R 个区域，之后周期性的写入本地磁盘。缓存的 key/value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker。</li><li>当 Reduce worker 接收到 master 发来的数据存储位置信息后，使用 RPC 从 Map worker 所在主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，对 key 排序后使具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。</li><li>Reduce worker 遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。</li><li>当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。此时在用户程序里对 MapReduce 的调用才返回。 在成功完成任务之后，MapReduce 的输出存放在 R 个输出文件中（对应每个 Reduce 任务产生一个输出文件，文件名由用户指定）</li></ol><h3 id="MapReduce-Refinements"><a href="#MapReduce-Refinements" class="headerlink" title="MapReduce Refinements"></a>MapReduce Refinements</h3><h4 id="Partitioning-Function"><a href="#Partitioning-Function" class="headerlink" title="Partitioning Function"></a>Partitioning Function</h4><p>使用 MapReduce 时通常会指定 Reduce 任务和 Reduce 任务输出文件的数量（R）。我们在中间 key 上使用分区函数来对数据进行分区，再输入到后续任务执行进程。缺省的分区函数是使用 hash 方法，比如 <code>hash(key) mod R</code> 进行分区。</p><h4 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h4><p>确保在给定的分区中，中间 key/value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按 key 值随机存取的应用非常有意义， 对在排序输出的数据集也很有帮助。</p><h4 id="Combiner-Function"><a href="#Combiner-Function" class="headerlink" title="Combiner Function"></a>Combiner Function</h4><p>在某些情况下，Map 函数产生的中间 key 值的重复数据会占很大的比重，并且，用户自定义的 Reduce 函数满足结合律和交换律。MapReduce 允许用户指定一个可选的 combiner 函数，combiner 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出 去。 Combiner 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，Combiner 和 Reduce 函数是 一样的，唯一区别是 Reduce 函数的输出被保存在最终的输出文件里，而 Combiner 函数的输出被写到中间文件里，然后被发送给 Reduce 任务。 部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。</p><h4 id="Input-and-Output-Types"><a href="#Input-and-Output-Types" class="headerlink" title="Input and Output Types"></a>Input and Output Types</h4><p>MapReduce 库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个 key/value pair。key 是文件的偏移量，value 是那一行的内容。另外一种常见的格式是以 key 进行排序来存储的 key/value pair 的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的 Map 任务来进行后续处理。同时也可以通过提供一个简单的 Reader 接口实现就能够支持一个新的输入类型。</p><h2 id="MapReduce-Lab"><a href="#MapReduce-Lab" class="headerlink" title="MapReduce Lab"></a>MapReduce Lab</h2><h3 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h3><h4 id="doMap"><a href="#doMap" class="headerlink" title="doMap()"></a>doMap()</h4><p><em>doMap manages one map task</em>：读取一个输入文件inFile，并为改文件内容调用用户自定义的mapF()，最后将mapF()的输出拆分到nReduce个中间文件中。同时要保证reduce的输出为json格式以方便后续操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTask <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">data, err := ioutil.ReadFile(inFile)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> != err &#123; log.Fatal(err) &#125;</span><br><span class="line"><span class="comment">// mapF() returns a slice containing the key/value pairs for reduce</span></span><br><span class="line">kvs := mapF(inFile, <span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outFiles []*os.File</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> outFiles &#123; file.Close() &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;nReduce; i++ &#123;</span><br><span class="line"><span class="comment">//the filename as the intermediate file for reduce task r.</span></span><br><span class="line">name := reduceName(jobName, mapTask, i)</span><br><span class="line">file, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> != err &#123; log.Fatal(err) &#125;</span><br><span class="line">outFiles = <span class="built_in">append</span>(outFiles, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">index := ihash(kv.Key) % nReduce</span><br><span class="line"><span class="comment">//enc opens IO stream of outFiles[index]</span></span><br><span class="line">enc := json.NewEncoder(outFiles[index])</span><br><span class="line"><span class="comment">//writes kv in stream</span></span><br><span class="line">enc.Encode(kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReduce"><a href="#doReduce" class="headerlink" title="doReduce()"></a>doReduce()</h4><p><em>doReduce manages one reduce task</em>：读取map tasks产生的中间文件，将其根据键值对的key排序后，为每个key调用用户自定义的reduceF()函数，最后将reduceF()的结果写到磁盘outFile文件上。因为doMap()产生的是json格式，要注意解码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTask <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//set of having the same key</span></span><br><span class="line">kvsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]([]<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line"><span class="comment">//yield the filename from map task m</span></span><br><span class="line">name := reduceName(jobName, i, reduceTask)</span><br><span class="line">file, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> != err &#123; log.Fatal(err) &#125;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">err := dec.Decode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">kvsMap[kv.Key] = <span class="built_in">append</span>(kvsMap[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduceFile, err := os.Create(outFile)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> != err &#123; log.Fatal(err) &#125;</span><br><span class="line">enc := json.NewEncoder(reduceFile)</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> kvsMap &#123;</span><br><span class="line"><span class="comment">//reduceF() returns the reduced value for that key</span></span><br><span class="line">data := reduceF(key, value)</span><br><span class="line">kv := KeyValue&#123;key, data&#125;</span><br><span class="line">enc.Encode(kv)</span><br><span class="line">&#125;</span><br><span class="line">reduceFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h3><h4 id="mapF"><a href="#mapF" class="headerlink" title="mapF()"></a>mapF()</h4><p>向mapF()传递一个文件名以及该文件的内容，mapF()将文件内容拆分为单词（毕竟对于字数统计，仅将单词用作键才有意义），并返回KeyValue类型的Go切片。</p><p><em>Tips: strings.FieldsFunc()可以用来拆分string，strconv.Itoa()可以将int转换成string类型。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line"><span class="comment">//单词频率结果</span></span><br><span class="line">wordsKv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//分词并遍历</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> !unicode.IsLetter(r) &#125;</span><br><span class="line"><span class="comment">//splits contents at each run of Unicode code points c satisfying f(c)</span></span><br><span class="line">words := strings.FieldsFunc(contents, f)</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="comment">//统计单词</span></span><br><span class="line">_, ok := wordsKv[word]</span><br><span class="line"><span class="keyword">if</span> ok &#123; </span><br><span class="line">wordsKv[word]++ </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">wordsKv[word] = <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换为输出格式</span></span><br><span class="line"><span class="keyword">var</span> rst []mapreduce.KeyValue</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> wordsKv &#123;</span><br><span class="line">kv := mapreduce.KeyValue&#123; key, strconv.Itoa(value) &#125;</span><br><span class="line">rst = <span class="built_in">append</span>(rst, kv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF()"></a>reduceF()</h4><p>每个key都会调用一次reduceF()计算这个key的出现总数，并以string类型return。</p><p><em>Tips: strconv.Atoi()可以将string类型转换成int类型。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">    <span class="comment">//合并统计结果</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">num, err := strconv.Atoi(value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">cnt += num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-III-Distributing-MapReduce-tasks"><a href="#Part-III-Distributing-MapReduce-tasks" class="headerlink" title="Part III: Distributing MapReduce tasks"></a>Part III: Distributing MapReduce tasks</h3><h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a>schedule()</h4><p>在一次mapReduce中会调用两次schedule()，分别在map阶段和reduce阶段。schedule()将任务分发给可用的worker并等待所有任务完成后返回。<code>registerChan</code>参数channel为每个worker程序生成一个字符串，其中包含工作程序的RPC地址。schedule()通过<code>call(worker, &quot;Worker.DoTask&quot;, args, nil)</code>（worker := &lt;-registerChan）将<code>Worker.DoTask</code> RPC 发送给worker程序来通知其执行任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, </span></span></span><br><span class="line"><span class="function"><span class="params">              registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers. </span></span><br><span class="line"><span class="comment">// Once all tasks have completed successfully, </span></span><br><span class="line">    <span class="comment">// schedule() should return.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(ntasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//rpc call args</span></span><br><span class="line"><span class="keyword">var</span> args DoTaskArgs</span><br><span class="line">args.Phase = phase</span><br><span class="line">args.JobName = jobName</span><br><span class="line">args.NumOtherPhase = n_other</span><br><span class="line">args.TaskNumber = index</span><br><span class="line"><span class="keyword">if</span> phase == mapPhase &#123;</span><br><span class="line">args.File = mapFiles[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line"><span class="comment">// registerChan yields a stream of registered workers</span></span><br><span class="line">worker := &lt;-registerChan</span><br><span class="line">done = call(worker, <span class="string">"Worker.DoTask"</span>, args, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; registerChan &lt;- worker &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>Raft是一种共识算法，它在容错和性能上与Paxos等效，但更容易理解学习。可以通过 <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a> 简单认知下Raft共识算法。</p><p>共识是容错分布式系统中的一个基本问题，共识涉及多个服务器就价值达成一致。共识通常出现在复制状态机的背景下，每个服务器都有一个状态机和一个日志，每个状态机都从其日志中获取输入命令。以哈希表为例，日志将包含诸如 set x=3 之类的命令，而共识算法要确保所有状态机都 x=3 作为第n个命令应用。即每个状态机处理相同系列的命令，从而产生相同系列的结果并到达相同系列的状态。</p><h2 id="Raft-Paper"><a href="#Raft-Paper" class="headerlink" title="Raft Paper"></a>Raft Paper</h2><p>Raft 选举出一个leader来管理复制日志：leader从客户端接收日志条目，将其复制到其他服务器上，并在保证安全的时候应用日志条目到他们的状态机中。由此，Raft 将一致性问题分解成三个子问题：<strong>Leader Election</strong>, <strong>Log Replication</strong>, <strong>Safety</strong>（所有状态机都应执行相同的命令序列）</p><h3 id="Raft-Properties"><a href="#Raft-Properties" class="headerlink" title="Raft Properties"></a>Raft Properties</h3><p>Raft 在任何时候都保证以下的各个特性。</p><ul><li><strong>Election Safety</strong>：一个给定term最多能选出一位leader</li><li><strong>Leader Append-Only</strong>：leader不能删除或修改自身log中entries，只能追加新entries</li><li><strong>Log Matching</strong>：如果两个log在某一index处的entries具有相同term，则这两个log在该index前的所有entries相同。 </li><li><strong>Leader Completeness</strong>：一个committed的entry会始终存在于之后terms的leaders的log中。</li><li><strong>State Machine Safety</strong>：若一个给定index的entry已经被某台服务器apply，则不会有服务器会在其log的index位置apply别的entry的。</li></ul><h3 id="Raft-Basics"><a href="#Raft-Basics" class="headerlink" title="Raft Basics"></a>Raft Basics</h3><p>在任何时刻，每一个服务器节点都处于这三个状态之一：leader、followers、candidates。<br>通常系统中只有一个leader且其他节点全都是followers，在一个任期内，leader一直保持，直到自己宕机。Followers都是被动的：他们不会发送任何请求，只是简单的响应来自leader / candidates的请求。<br>Leader处理所有的客户端请求（如果一个客户端和followers联系，那followers会把请求重定向给leader）<br><img src="https://i.loli.net/2020/02/21/ANVsJ8aCyM5KifD.jpg" alt="Go与分布式_Raft_states.png"></p><p>Raft 把时间分割成任意长度的<strong>任期terms</strong>。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始。</p><p>每一个节点存储一个当前任期号current term，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换current term；如果一个服务器的current term比其他人小，那么他会更新到较大的编号值。Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。</p><h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h4><p>Raft 使用一种heartbeat机制来触发领导人选举。当服务器程序启动时，各自都是followers。Leader会周期性的向所有followers发送心跳包 (AppendEntries RPCs that carry no log entries) 来维持自己的权威。Followers只要收到了来自 leader / candidates 的有效RPCs就会一直保持followers。但如果一个follower在一段时间（random，一般在150ms-300ms）里没有接收到任何消息，即<strong>选举超时</strong>，那他会认为系统中无可用leader，并发起选举以选出新的leader。</p><p>要开始一次选举过程，followers先要current term++且转换到candidates，然后并行的向集群中的其他服务器节点发送RequestVote的 RPCs 来给自己投票。Candidates会继续保持当前状态直到以下三件事情之一发生：</p><ul><li><p><em>(a) <strong>it wins the election</strong>：</em>candidate从整个集群的大多数服务器节点获得了针对同一term的选票。每个服务器按先来先服务原则在每个term最多投一张选票。一旦candidate赢得选举，则立即成为leader并向其他的服务器发送heartbeat来建立自己的权威并且阻止产生别的leader。</p></li><li><p><em>(b) <strong>another server establishes itself as leader</strong>：</em>等待投票时candidate收到别的服务器leader声明的AppendEntries RPC，如果该RPC中leader的term &gt;= candidate的term，则candidate承认该leader并回到follower；否则candidate会拒绝该RPC并保持candidate 。</p></li><li><p><em>(c) <strong>a period of time goes by with no winner</strong>：</em>多个followers同时成为candidates来瓜分选票，导致无人能赢得大多数人的支持。为了避免瓜分次数过多，每个candidate在发RequestVote RPCs时都会设置一个<strong>随机的</strong>等待时间，若超时则重新发送RequestVote RPCs 。这样每次瓜分后，所有candidates都会超时，current term++开启新一轮选举。</p></li></ul><h4 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h4><p>客户端只和leader交互，leader把客户端指令作为一条log entry附加到自己log中，然后并行的发起 AppendEntries RPCs 给 followers，让他们复制这条entry。当这其被<strong>安全的</strong>复制，leader会将这条entry内容应用在自身状态机上并将其commit，同时return result给客户端。接下来leader会通知followers该entry已经committed，followers将其应用到各自状态机，完成各自log上该entry的commit。leader会不断的重复尝试 AppendEntries RPCs （尽管已经回复了客户端）直到所有的followers都最终存储了所有的日志条目。</p><p><img src="https://i.loli.net/2020/02/28/n4uPxsZJC8eYlgA.jpg" alt="Go与分布式_Raft_log.png"></p><blockquote><p>日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字）和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。</p></blockquote><p>在leader将创建的日志条目复制到大多数的服务器上的时候，此时可以认为该 log entry 应用到状态机中是安全的，即该 log entry is <strong>committed</strong>（如图中条目 7）。同时，leader的日志中之前的所有日志条目也都会被提交，包括之前所有terms里的条目。Leader跟踪 committed entries 的 highest index（例如图中为7），并将其写进未来所有的 AppendEntries RPCs 好让 followers 清楚。Followers会将 committed entries 按 log 顺序应用到本地的状态机中。</p><p>Raft 的日志机制维护了不同服务器的日志之间的高层次的一致性，同时也组成了上文中的日志匹配特性：</p><ul><li>不同log中的两个entry拥有相同index&amp;term -&gt; 他们存了相同的指令且之前的所有entries也全部相同。</li></ul><p><em>理由：leader会把前一个entry的index和term写进当前AppendEntries RPC中，如果followers发现在自己的log中找不到符合的entry，就会拒收这个新entry以保证其log和leader的log顺序一致。</em></p><p>正常操作中，logs肯定会保持一致性。但存在这种情况，leader在自己log中写入了一堆entries但在这些entries还没全部committed时leader就先自己崩溃了，下一term它作为follower，就会出现和当前leader的log不一致情况。Raft的解决办法是直接把followers冲突的那部分entries覆盖成leader的对应entries。</p><p>Leader针对每一个follower维护了一个 <strong>nextIndex</strong>（即将要发给followers的entry的index）当一个leader刚获得权力的时候，初始化所有的 nextIndex  = leader log highest index + 1。如果出现AppendEntries RPC被followers拒绝的情况，leader会让 nextIndex— 并重试。最终 nextIndex 会停在两者log一致的点，此时的AppendEntries RPC将不再被拒绝，即可followers冲突的entries全部删除并逐个追加leader的entries。通过这种机制，leader在获得权力的时候就不需要任何特殊的操作来恢复一致性。</p><h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>我们需要保证每个状态机都会按照相同的顺序执行相同的指令。但如果出现，一些entries被大部分followers接受并commit，但存在一个follower处于unavailable没有接受这些entries，但偏偏该follower在下一term成为了leader，这就会导致那些committed entries明明执行了却被强制删除，即不同状态机执行不同的指令序列。</p><p>Raft通过在leader election中增加一些限制来保证：任何leader对于给定的term，都拥有之前terms里所有的committed entries (即上文提到的 the Leader Completeness Property)</p><p>在raft的投票环节，每个candidates发出的RequestVote RPC都会包含其last log entry的term和index，followers会根据这些信息拒绝掉没有自己新（term越大越新，term相同index越大约新）的投票请求。这样选出来的leader至少和大部分followers一样新，而entries是在大部分followers都复制后才会commit，即committed entries存在于大部分followers上，如果能和大部分followers一样新，就能保证存储了所有的committed entries。</p><p><img src="https://i.loli.net/2020/02/29/7HLPm9AKQG54wvR.jpg" alt="Go与分布式_Raft_crash.png"></p><p>Leader不能断定之前term中保存到大部分服务器的entry是否已经commit，如图，S1作leader，开始复制entry_2，复制了小部分followers后换leader了。S5作leader，没有entry_2且刚接受到客户端的entry_3，继续换leader。S1作leader，继续复制那条entry_2并成功复制到大部分followers上，但在entry_2即将commit前，又被换leader。若S5作leader（因为entry_3的term&gt;entry_2的term，所以能收到S2,S3,S4的选票），此时entry_3会覆盖所有的entry_2；若S1继续作leader，则S1的entries都会被提交。</p><blockquote><p>leader复制之前term的entries时，这些entries的term不变（图c复制entry_2时，其term依旧为2 ）</p></blockquote><p>由此，对于之前term中的entries，leader不会通过计算其副本数目的方式去commit，事实上leader只会对当前term的entries用计算副本数目的方式来commit。而当前term的entries被commit，由于日志匹配特性，之前的entries都会被间接commit。</p><h3 id="Condenced-Summary"><a href="#Condenced-Summary" class="headerlink" title="Condenced Summary"></a>Condenced Summary</h3><p><img src="https://i.loli.net/2020/02/20/NzSX6Eq8yjUhPem.png" alt="Go与分布式_Raft_summary.png"></p><h4 id="AppendEntries-RPC"><a href="#AppendEntries-RPC" class="headerlink" title="AppendEntries RPC"></a>AppendEntries RPC</h4><p>由leader负责调用来复制日志指令；也会用作heartbeat，receiver实现：</p><ol><li>如果 <code>term &lt; currentTerm</code> 就返回 false </li><li>如果日志在 prevLogIndex 位置处的 entry 和 prevLogTerm 不匹配，则返回 false </li><li>如果已经存在的日志条目和新的产生冲突（index相同但term不同），删除这一条和之后所有的 entries</li><li>附加日志中尚未存在的任何新条目</li><li>如果 <code>leaderCommit &gt; commitIndex</code>，令 commitIndex = MIN(leaderCommit, 新日志条目索引值)</li></ol><h4 id="RequestVote-RPC"><a href="#RequestVote-RPC" class="headerlink" title="RequestVote RPC"></a>RequestVote RPC</h4><p>由candidates负责调用来征集选票，receiver实现：</p><ol><li>如果<code>term &lt; currentTerm</code>返回 false </li><li>如果 votedFor 为 null / candidateId，且candidate的日志至少和receiver一样新，那就投票给他</li></ol><h4 id="Rules-for-Servers"><a href="#Rules-for-Servers" class="headerlink" title="Rules for Servers"></a>Rules for Servers</h4><h5 id="All-Servers"><a href="#All-Servers" class="headerlink" title="All Servers"></a>All Servers</h5><ul><li>如果<code>commitIndex &gt; lastApplied</code>，那就 lastApplied ++，并把<code>log[lastApplied]</code>应用到状态机中</li><li>如果接收到的RPC请求或响应中，term<code>T &gt; currentTerm</code>，则令<code>currentTerm = T</code>，并切换状态为followers</li></ul><h5 id="Followers"><a href="#Followers" class="headerlink" title="Followers"></a>Followers</h5><ul><li>响应来自leader和candidates的RPCs</li><li>如果在选举超时前一直没有收到leader或candidates的RPCs，就自己变成candidate</li></ul><h5 id="Candidates"><a href="#Candidates" class="headerlink" title="Candidates"></a>Candidates</h5><ul><li>在转变成candidates后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的 AppendEntries RPC，转变成跟随者</li><li>如果选举过程超时，再次发起一轮选举</li></ul><h5 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h5><ul><li>一旦成为领导人：发送空的AppendEntries RPC (heartbeat) 给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止followers超时</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</li><li>如果对于一个跟随者，最后日志条目的index &gt;= nextIndex，则发送从 nextIndex 开始的所有日志条目：<ul><li>如果成功：更新相应 followers 的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，减少 nextIndex 重试</li></ul></li><li>如果存在一个N满足<code>N &gt; commitIndex</code>，且大多数的<code>matchIndex[i] ≥ N</code>成立，并且<code>log[N].term == currentTerm</code>成立，则令<code>commitIndex = N</code></li></ul><h3 id="Cluster-membership-changes"><a href="#Cluster-membership-changes" class="headerlink" title="Cluster membership changes"></a>Cluster membership changes</h3><p>实际操作中偶尔会改变集群的配置，但服务器直接从旧配置转换到新配置很容易出现分歧。为避免存在新旧配置在同一时间下出现各自leader，即同一时刻新旧配置同时生效的情况，配置更改必须使用两阶段方法。在 Raft 中，集群先切换到一个过渡的配置，称之为共同一致；一旦共同一致被commit，那系统就切换到新配置上。共同一致是老配置和新配置的结合：</p><ul><li>日志条目会被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为leader。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li></ul><p>当leader接收到一个改变配置从 C-old 到 C-new 的请求，他会创建configuration entry: C-old,new来存储配置，并复制给followers。各个服务器总是用latest configuration entry作为自己的配置，无论他是否committed。</p><p>一旦 C-old,new 被提交（C-old，C-new双方大部分都复制成功），那么无论是 C-old 还是 C-new，在没有经过对方批准的情况下都不可能做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。</p><p>在关于重新配置还有三个问题需要提出：</p><ul><li><p>新的服务器可能初始化没有存储任何的日志条目。此时他们需要时间来更新追赶，而没法提交新的条目。Raft 在配置更新之前使用了一种额外的阶段：该阶段里，新的服务器加入，接收leader的entries但无投票权，直到追赶上了集群中的其他机器。</p></li><li><p>当前leader不在C-new中，即当前leader节点即将下线。在C-new被commit之后Leader实际已经从集群中脱离，会退位到follower状态，此时可以对Leader节点进行下线操作，而新集群则会在C-new的配置下重新选举出一个Leader。</p></li><li><p>移除不在 C-new 中的服务器可能会扰乱集群。这些服务器因为不在C-new里，所以leader根本不会给他们发心跳，之后这些节点就会选举超时，发送term++的请求投票 RPCs，这样会导致当前leader回退成follower。为了避免这种情况，除非leader超时，不然各节点拒收投票请求RPCs。同时在每次选举前等待一个选举超时时间，这样每次旧节点在发起选举前需要等待一段时间，那这段时间新Leader可以发送心跳，减少影响。 </p></li></ul><h3 id="Log-compaction"><a href="#Log-compaction" class="headerlink" title="Log compaction"></a>Log compaction</h3><p>Raft 需要一定的机制去清除日志里积累的陈旧的信息，快照Snapshotting是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。<br><img src="https://i.loli.net/2020/03/01/xXltDZv8yfmi1n6.jpg" alt="Go与分布式_Raft_snapShot.png"><br>每个服务器独立的创建快照，快照只包括committed entries。Raft 包含状态机状态和少量元数据（last index&amp;term）到快照中，保留元数据是为了支持快照后第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新，快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p><p>但当followers运行缓慢或作为C-new刚加入集群时，需要leader发送快照让他们更新到最新状态。这种情况下leader使用 InstallSnapshot RPCs 来发送快照。当followers通过这种 RPC 接收到快照时，会决定如何处理log：通常快照会含当前log没有的信息，此时会丢弃整个log，用快照代替；也可能接收到的快照是自己日志的前面部分（网络重传或者错误），那么被快照包含的entries会被全部删除，但快照后面的entries仍然有效，必须保留。<br><img src="https://i.loli.net/2020/03/01/gbPEGHk894xwdID.png" alt="Go与分布式_Raft_snapShotRPC.png"></p><h3 id="Client-interaction"><a href="#Client-interaction" class="headerlink" title="Client interaction"></a>Client interaction</h3><p>Raft 要求客户端只和leader交互，所以当客户端请求到follower时，如果集群里存在leader，follower会将leader地址发给客户端；如果此时集群里无leader，客户端会等待、重试。</p><p>Raft 的目标是要实现线性化语义(each operation appears to execute instantaneously, exactly once, at some point between its invocation and its response)。但如果，leader在commit该entry之后，回复客户端之前crash，那么客户端会和新leader重试这条指令，导致这条命令就被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读操作可以直接处理而不用写进日志。但在不增加任何限制的情况下，这么做可能会返回脏数据，因为leader可能在response客户端时被退回成follower，此时原先leader的信息已经变脏。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。</p><ul><li>Leader必须有关于被提交日志的最新信息。在leader任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过leader在任期开始时commit一个空白entry到日志中去来实现。</li><li>Leader在处理只读的请求前必须检查自己是否已经被废黜了。Raft 中通过leader在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合 MIT-6.824-2018 的各个 lab 来简单写下学习分布式系统的学习心得。&lt;/p&gt;
&lt;p&gt;目前主要有：MapReduce, Raft（期待后续更新中）
    
    </summary>
    
    
      <category term="Sys" scheme="https://stardust567.github.io/categories/Sys/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Go" scheme="https://stardust567.github.io/tags/Go/"/>
    
      <category term="6.824" scheme="https://stardust567.github.io/tags/6-824/"/>
    
  </entry>
  
  <entry>
    <title>Go与并发</title>
    <link href="https://stardust567.github.io/post/28fa.html"/>
    <id>https://stardust567.github.io/post/28fa.html</id>
    <published>2020-02-06T01:14:05.000Z</published>
    <updated>2020-05-27T00:34:17.813Z</updated>
    
    <content type="html"><![CDATA[<p>goroutine是Go并行设计的核心。goroutine算是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)。goroutine比thread更易用、更高效、更轻便。<a id="more"></a></p><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p>goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过<code>go</code>关键字实现，类似普通函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched() <span class="comment">//让CPU把时间片让给别人,下次某个时候继续恢复执行该goroutine</span></span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">"hello"</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">进程</td><td style="text-align:left">一个程序对应一个独立程序空间</td></tr><tr><td style="text-align:left">线程</td><td style="text-align:left">一个执行空间，一个进程可以有多个线程</td></tr><tr><td style="text-align:left">逻辑处理器</td><td style="text-align:left">执行创建的goroutine，绑定一个线程</td></tr><tr><td style="text-align:left">调度器</td><td style="text-align:left">Go运行时中的，分配goroutine给不同的逻辑处理器</td></tr><tr><td style="text-align:left">全局运行队列</td><td style="text-align:left">所有刚创建的goroutine都会放到这里</td></tr><tr><td style="text-align:left">本地运行队列</td><td style="text-align:left">逻辑处理器的goroutine队列</td></tr></tbody></table></div><p>当我们创建一个goroutine的后，会先存放在<code>全局运行队列</code>中，等待Go运行时的<code>调度器</code>进行调度，把他们分配给其中的一个<code>逻辑处理器</code>，并放到这个逻辑处理器对应的<code>本地运行队列</code>中，最终等着被<code>逻辑处理器</code>执行即可。</p><p>这一套管理、调度、执行goroutine的方式称之为Go的并发。那怎么做到Go的并行呢？多创建一个<code>逻辑处理器</code>就好了，这样调度器就可以同时分配<code>全局运行队列</code>中的goroutine到不同的<code>逻辑处理器</code>上并行执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"A:"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"B:"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>sync.WaitGroup</code>其实是一个计数的信号量，使用它的目的是要<code>main</code>函数等待两个goroutine执行完成后再结束，不然这两个<code>goroutine</code>还在运行的时候，程序就结束了，看不到想要的结果。</p><p><code>sync.WaitGroup</code>的使用非常简单，先使用<code>Add</code> 方法设置计算器为2，每个goroutine的函数执行完后就调用<code>Done</code>方法减1（使用延迟语句defer完成逻辑）。<code>Wait</code>方法，在计数器大于0时阻塞，所以<code>main</code> 函数会一直等待2个goroutine完成后，再结束。</p><p>默认情况下，Go默认是给每个可用的物理处理器都分配一个逻辑处理器，因为我的电脑是4核的，所以上面的例子默认创建了4个逻辑处理器，所以这个例子中同时也有并行的调度。</p><p>上面多个goroutine运行在同一个进程里，共享内存数据，设计上遵循：<strong>不通过共享来通信，而通过通信来共享。</strong></p><h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><p>有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写时，就会处于相互竞争的状态，即并发中的资源竞争。<strong>我们对同一个资源的读写必须是原子化的，即同一时间只能有一个goroutine对共享资源进行读写操作</strong>。</p><p>共享资源竞争的问题，Go为我们提供了一个工具帮助我们检查，这个就是<code>go build -race</code>命令。我们在当前项目目录下执行这个命令，生成一个可以执行文件，然后再运行这个可执行文件，就可以看到打印出的检测信息。</p><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>sync包里提供了一种互斥型的锁<code>sync.Mutex</code>，可以控制哪些代码同一时段下，只能有一个goroutine访问，被sync互斥锁控制的这段代码范围，被称之为临界区。同时sync包还提供一种读写锁<code>sync.RWMutex</code>，设计有<code>RLock()</code>等四种方法，下面用经典的读者写者问题来举例RWMutex的用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mutex sync.RWMutex</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mutex.RLock()</span><br><span class="line">fmt.Println(content)</span><br><span class="line">mutex.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(text <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mutex.Lock()</span><br><span class="line">content += text</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">go</span> write(<span class="string">"hhh"</span>)</span><br><span class="line"><span class="keyword">go</span> read()</span><br><span class="line"><span class="keyword">go</span> write(<span class="string">"hhh"</span>)</span><br><span class="line"><span class="keyword">go</span> read()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h3><p>在多个goroutine并发中，我们不仅可以通过原子函数和互斥锁保证对共享资源的安全访问，消除竞争的状态，还可以通过使用通道，在多个goroutine发送和接受共享的数据，达到数据同步的目的。</p><p>goroutine间数据的通信机制为channel，可以与Unix shell中双向管道做类比：可以通过它发送或者接收值，<strong>这些值只能是channel类型</strong>。定义一个channel时，需要定义发送到channel的值的类型。<strong>必须使用make 创建channel：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>channel通过操作符<code>&lt;-</code>来接收和发送数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure><p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得Goroutines同步变的更加的简单，而不需要显式的lock。所谓阻塞，也就是如果读取（value := &lt;-ch）它将会被阻塞，直到有数据接收。其次，任何发送（ch&lt;-5）将会被阻塞，直到数据被读出。无缓冲channel是在多个goroutine之间同步很棒的工具。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>上面为Go默认的非缓存类型的channel，Go也允许指定channel的缓冲大小，即channel可以存储多少元素。</p><p><code>ch:= make(chan bool, 4)</code>创建了可以存储4个元素的bool 型channel。这个channel 中前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure><p>当 value = 0 时，channel 是无缓冲阻塞读写的，当value &gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。我们可以用最为经典的生产者消费者来举例buffered channels的用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(max <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; max; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"Send"</span>, num, <span class="string">": "</span>, i)</span><br><span class="line">ch &lt;- i</span><br><span class="line">time.Sleep(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(max <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; max; i++ &#123;</span><br><span class="line">v := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">"Receive"</span>, num, <span class="string">": "</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> produce(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> consumer(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> consumer(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> produce(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><code>for i := range c</code>能够不断的读取channel里面的数据，直到该channel被显式的关闭。</p><h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><p>我们可以通过内置函数<code>close</code>关闭channel，<strong>一般在生产方使用</strong>。关闭channel之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试channel是否被关闭。如果ok返回false，那么说明channel已经没有任何数据并且已经被关闭。</p><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>如果存在多个channel的时候，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听channel上的数据流动。</p><p><code>select</code>默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>select</code>里面还有default语法，<code>select</code>其实就是类似switch的功能，default就是当监听的channel都没有准备好的时候，默认执行的（select不再阻塞等待channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>有时候会出现goroutine阻塞的情况，为了避免整个程序进入阻塞，可以利用select来设置超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">"timeout"</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h3><p>runtime包中有几个处理goroutine的函数：</p><ul><li><p>Goexit</p><p>退出当前执行的goroutine，但是defer函数还会继续调用</p></li><li><p>Gosched</p><p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p></li><li><p>NumCPU</p><p>返回 CPU 核数量</p></li><li><p>NumGoroutine</p><p>返回正在执行和排队的任务总数</p></li><li><p>GOMAXPROCS</p><p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p></li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context。</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>如上面用到的，waitGroup尤其适用于多个goroutine协同做一件事情的时候，因为每个goroutine做的都是这件事情的一部分，只有全部的goroutine都完成，这件事情才算是完成，即wait模式。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>对于一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，Go提供了Context，即goroutine的上下文。</p><p><code>context.Background()</code> 返回一个空的Context，这个空的Context一般用于整个Context树的根节点。我们使用<code>context.WithCancel(parent)</code>函数，创建一个可取消的子Context，然后当作参数传给goroutine使用，这样就可以使用这个子Context跟踪这个goroutine。</p><p>在goroutine中，使用select调用<code>&lt;-ctx.Done()</code>判断是否要结束，如果接受到值的话，就可以返回结束goroutine了；如果接收不到，就会继续进行监控。</p><p><code>cancel</code>函数是由调用<code>context.WithCancel(parent)</code>函数生成子Context的时候返回的，，它是<code>CancelFunc</code>类型的。调用它就可以发出取消指令，然后我们的监控goroutine就会收到信号，就会返回结束。</p><p><code>Done</code>是Context接口常用的方法，如果Context取消的时候，我们就可以得到一个关闭的chan，关闭的chan是可以读取的，所以只要可以读取的时候，就意味着收到Context取消的信号了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控1】"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控2】"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控3】"</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(name,<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(name,<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中启动了3个监控goroutine进行不断的监控，每一个都使用了Context进行跟踪，当我们使用<code>cancel</code>函数通知取消时，这3个goroutine都会被结束。这就是Context的控制能力，它就像一个控制器一样，按下开关后，所有基于这个Context或者衍生的子Context都会收到通知，这时就可以进行清理操作了，最终释放goroutine，优雅的解决了goroutine启动后不可控的问题。</p><h4 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h4><p><code>Deadline</code>方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</p><p><code>Done</code>方法返回一个只读的chan，类型为<code>struct{}</code>，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过<code>Done</code>方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。</p><p><code>Err</code>方法返回取消的错误原因，因为什么Context被取消。Done和Err两者搭配起来就是常用经典用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line"> v, err := DoSomething(ctx)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"> <span class="keyword">return</span> ctx.Err()</span><br><span class="line"> <span class="keyword">case</span> out &lt;- v:</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>Value</code>方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;goroutine是Go并行设计的核心。goroutine算是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)。goroutine比thread更易用、更高效、更轻便。
    
    </summary>
    
    
      <category term="Go" scheme="https://stardust567.github.io/categories/Go/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Go" scheme="https://stardust567.github.io/tags/Go/"/>
    
      <category term="concurrency" scheme="https://stardust567.github.io/tags/concurrency/"/>
    
      <category term="goroutine" scheme="https://stardust567.github.io/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://stardust567.github.io/post/c018.html"/>
    <id>https://stardust567.github.io/post/c018.html</id>
    <published>2020-01-13T02:10:12.000Z</published>
    <updated>2020-01-13T03:50:15.207Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。<a id="more"></a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>一般来说，先写Dockerfile文件并用此来创建image文件：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t demo:0.0.1</span><br></pre></td></tr></table></figure><p>然后生成容器：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><p>不过Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）才能在本机localhost访问到。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>对于Vue前端，Dockerfile位于项目的docker文件夹下，同时有nginx.conf配置文件。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><code>FROM nginx:alpine</code></p><p><code>COPY ./nginx.conf /etc/nginx/conf.d/default.conf</code><br><code>COPY ./dist /usr/share/nginx/html</code></p><p>Docker 需要依赖于一个基础镜像进行构建运行容器，我们指定nginx的alpine版本作为基础镜像。使用<code>COPY</code> 指令从Docker主机复制内容和配置文件。不过记住，需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p><h4 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h4><blockquote><p>server {</p><p>  listen 80;</p><p>  location / {</p><p>   root /usr/share/nginx/html;</p><p>   index index.html;</p><p>  }</p><p>}</p></blockquote><p>在80端口监听，访问<code>/</code>相当于访问容器的<code>/usr/share/nginx/html</code></p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p><code>cd ..</code><br><code>yarn build</code><br><code>cd docker</code><br><code>mv ../dist ./dist</code><br><code>sudo docker login --username=stardust567 registry.cn-shanghai.aliyuncs.com</code><br><code>sudo docker build -t registry.cn-shanghai.aliyuncs.com/stardust567/infoweb:$1 ./</code><br><code>sudo docker push registry.cn-shanghai.aliyuncs.com/stardust567/infoweb:$1</code></p><p>在根目录编译vue项目于默认的dist文件夹下并将dist文件夹移入docker文件夹下，创建镜像并push上阿里云（$1为标签名）</p><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p>对于go后端，Dockerfile文件直接位于项目根目录下。</p><h3 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><code>FROM golang as build</code></p><p><code>ENV GOPROXY=https://goproxy.cn</code></p><p><code>ADD . /infoweb</code></p><p><code>WORKDIR /infoweb</code></p><p><code>RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o api_server</code></p><p><code>FROM alpine:3.7</code></p><p><code>ENV REDIS_ADDR=&quot;&quot;</code><br><code>ENV REDIS_PW=&quot;&quot;</code><br><code>ENV REDIS_DB=&quot;&quot;</code><br><code>ENV MysqlDSN=&quot;&quot;</code><br><code>ENV GIN_MODE=&quot;release&quot;</code><br><code>ENV PORT=3000</code></p><p><code>RUN echo &quot;http://mirrors.aliyun.com/alpine/v3.7/main/&quot; &gt; /etc/apk/repositories &amp;&amp; \</code><br>  <code>apk update &amp;&amp; \</code><br>  <code>apk add ca-certificates &amp;&amp; \</code><br>  <code>echo &quot;hosts: files dns&quot; &gt; /etc/nsswitch.conf &amp;&amp; \</code><br>  <code>mkdir -p /www/conf</code></p><p><code>WORKDIR /www</code></p><p><code>COPY --from=build /infoweb/api_server /usr/bin/api_server</code><br><code>ADD ./conf /www/conf</code></p><p><code>RUN chmod +x /usr/bin/api_server</code></p><p><code>ENTRYPOINT [&quot;api_server&quot;]</code></p><p>将当前目录下文件拷入docker并作为工作目录，在linux环境下编译go文件生成api_server文件。</p><p>再生成一个基础镜像并初始化一下并创建拷贝conf文件夹，将上个镜像的api_server拷贝并赋予权限，最后在启动容器时执行api_server文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。
    
    </summary>
    
    
      <category term="Docker" scheme="https://stardust567.github.io/categories/Docker/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Docker" scheme="https://stardust567.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Tips</title>
    <link href="https://stardust567.github.io/post/5f09.html"/>
    <id>https://stardust567.github.io/post/5f09.html</id>
    <published>2019-12-22T07:34:17.000Z</published>
    <updated>2020-05-26T08:10:29.055Z</updated>
    
    <content type="html"><![CDATA[<p>学习路上总会遇到各种坑，之前一直搞完就算了，总觉得很可惜，就有了记录<del>踩的各种坑</del>的想法……</p><p>未完待续（不断填坑）中……<a id="more"></a></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li><p>如果你add &amp; commit过完看命令行发现自己智障了还好没push上去。</p><blockquote><p>git reset —mixed HEAD^</p></blockquote></li><li><p>如果commit&amp;push后error: src refspec matser does not match any.</p><blockquote><p>git push —set-upstream origin master</p></blockquote></li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol><li><p>打开项目所在文件目录导出python库依赖requirements.txt</p><blockquote><p>pipreqs ./ —encoding=utf-8</p></blockquote><p>这样之后有人需要用这个项目的时候直接打开命令行输入以下即可：</p><blockquote><p>pip install -r requirements.txt</p></blockquote></li><li><p>解决matplotlib中文图例乱码问题</p><blockquote><p>plt.rcParams[‘font.sans-serif’]=[‘SimHei’]     # 用来正常显示中文标签<br>plt.rcParams[‘axes.unicode_minus’]=False  # 用来正常显示负号</p></blockquote></li><li><p>想判断x类型的时候，建议用<code>isinstance(x, 预判类型)</code>而不用<code>type(x)==预判类型</code>因为isinstance可以判断子类对象是否继承于父类，而type不可以。不过对于基本类型而言，type还是很好用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student = Student(<span class="string">"Jone"</span>, <span class="string">"UESTC"</span>) <span class="comment"># class Student(Person)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Student)==type(Person) <span class="comment"># True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Person, Student) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(student, Student) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Person, Student) <span class="comment"># False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Student, Person) <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p>做大量数据循环的时候建议使用xrange而非range，xrange本质是个生成器，而range是个list，当数据量很大的时候，range需要提前开辟一堆内存空间。</p></li><li><p>Python无明确的公共、私有或受保护的关键字来定义成员函数或属性，而是使用“_”和”__”来标识。</p><ol><li>单下划线的函数或属性，在类中可以调用和访问，类的实例可以直接访问，子类中可以访问；</li><li>双下划线的函数或属性，在类中可以调用和访问，类的实例不可以直接访问，子类不可访问。</li></ol><p>但是带<code>__</code>的还有内建方法，python中所有类默认继承object类，我们可以重写object类的原始属性和方法，比如在类中重写<code>def __str__(self):</code>后，再print这个类时会直接调用重写后的方法。</p></li></ol><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li><p>添加 Go Modules Replace的时候，replace配置项的路径只能是<code>~</code>根目录开头，<code>.</code>当前目录开头，<code>..</code>上级目录开头，这点在WSL上就还是安利后两者，毕竟在根目录下VScode估计找不到文件夹orz</p></li><li><p>为变量给予附属属性<code>json</code>，这样子在<code>c.JSON</code>(c *gin.Context)的时候就会自动转换格式，非常的便利。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol><li><p>Windows下用docker端口进行映射，但打开<code>localhost:port</code>无法访问对应的服务。</p><p> 因为docker是运行在Linux上的，在Windows中运行实际上还是在Windows下Linux环境中运行的docker。即服务中使用的localhost指的是这个Linux环境的地址，而非宿主环境Windows。我们可以通过命令<code>docker-machine ip defaul</code>找到这个Linux环境的IP地址，一般是<strong>192.168.99.100</strong>（比如我）</p></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol><li><p>如果是WSL的话，MySQL被设计为可以使用大写字母跨平台正常工作，其中数据库名称/表名和/或列为小写字母可能会给操作系统带来麻烦，并且可能会生成相同的二进制表文件。简单点，会出bug不建议WSL建议直接windows上MySQL，如果真的想WSL的话（比如我），当Cannot stat file /proc/1/fd/5: Operation not permitted时，不要慌，重启下bash然后输入：</p><blockquote><p>sudo service mysql start</p><p>sudo dpkg —configure -a</p></blockquote><p>然后你可能会像我一样发现Error: Access denied for user ‘root’@’localhost’莫慌：</p><blockquote><p>sudo mysql</p><p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;</p></blockquote><p>这样再进入的时候usr:root, psd:root 就ok了</p><blockquote><p>mysql -u root -p</p></blockquote><p>接下来就可以愉快地创建新用户，然后赋予并刷新权限了：</p><blockquote><p>mysql &gt;CREATE USER ‘newuser’@’localhost’ IDENTIFIED BY ‘password’;</p><p>mysql&gt; GRANT ALL PRIVILEGES ON <em> . </em> TO ‘newuser’@’localhost’;</p><p>mysql &gt;FLUSH PRIVILEGES;</p></blockquote></li><li><p>如果发现ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)那是因为没开服务，打开服务<code>sudo service mysql start</code>即可。</p></li><li><p>用pymysql时候(pymysql.err.InternalError) (1366, “Incorrect string value: ‘\\xE6\\xAD\\xA3\\xE5\\xB8\\xB8’中文编码问题，修改即可。 </p><blockquote><p>mysql&gt; alter table recruit convert to character set utf8mb4; </p></blockquote></li><li><p>用pymysql时候，想借MySQL函数<code>STR_TO_DATE</code>传DATE类型数据，记得年月日用%%而不是%：</p><blockquote><p>sql = ‘insert into recruit_info(title,time) VALUES (%s,STR_TO_DATE(%s, “%%Y-%%m-%%d”))’</p></blockquote></li><li><p>revoke时候出现ERROR 1141 (42000)是因为当初你怎么grant的就必须怎么revoke回来，无法有修改。</p></li><li><p>mysql默认root账户无法远程登录，哪怕你改名改密码也不行，会出现ERROR 1045 (28000) </p></li></ol><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><ol><li>打开<em>pgAdmin</em>如果出现无法连接并要求输入<code>postgres</code>密码的情况，请打开任务管理器&gt;服务，找到并启动<code>postgresql-x64-10</code>即可。</li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol><li>WSL下安装Redis的话，要记得修改/etc/redis/redis.conf这个文件，将<code>supervised no</code>修改为<code>supervised systemd</code>即可，ubuntu用<code>systemd</code>初始系统。</li><li>如果连不上，第一件事就是启动服务试试，<code>sudo service redis-server start</code></li></ol><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><ol><li>刚开始我在修改代码中途发现自己没下<code>vue-router</code>强停后npm install结果errno -4048 npm ERR! syscall rename，解决方法<code>npm cache clean --force</code>后npm install即可。</li></ol><h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><ol><li>用tree直接导出当前目录下的目录结构：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -L 2 &gt; test.txt</span><br></pre></td></tr></table></figure></li></ol><ol><li>不想每次都输服务器密码（懒）怎么办：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id USER_NAME@IP_ADDRESS</span><br></pre></td></tr></table></figure></li></ol><ol><li>linux用密钥登录出现 <em>Permissions 0777 are too open.</em> 时可以加个<code>sudo</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssh -i keyfile &lt;user&gt;@ip</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Ctrl+C 使当前命令Stopped并置于后台。<code>jobs</code>查看后台命令。<code>fg %1</code>使后台命令1在前台继续执行，<code>bg %1</code>使后台命令1在后台继续执行，相当于加上<code>&amp;</code>。</p></li><li><p><code>&amp;</code>和<code>nohup</code>都可以使命令后台执行，nohup即no hang up，在用户退出后依旧可以继续执行。</p></li><li><p>linux用vim忘记sudo后无法退出，强制退出用<code>:q!</code>但还是先另存为<code>:w new_filename</code>好一点。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习路上总会遇到各种坑，之前一直搞完就算了，总觉得很可惜，就有了记录&lt;del&gt;踩的各种坑&lt;/del&gt;的想法……&lt;/p&gt;
&lt;p&gt;未完待续（不断填坑）中……
    
    </summary>
    
    
      <category term="tips" scheme="https://stardust567.github.io/categories/tips/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Tips" scheme="https://stardust567.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Go与Web</title>
    <link href="https://stardust567.github.io/post/6e5d.html"/>
    <id>https://stardust567.github.io/post/6e5d.html</id>
    <published>2019-12-08T01:31:11.000Z</published>
    <updated>2020-02-18T03:41:47.659Z</updated>
    
    <content type="html"><![CDATA[<p>Go日记的Web篇外传正式开张了，可喜可贺、可喜可贺！</p><p>这篇简单介绍下Go的Web基础，有计网知识或者写过前后端应该会很好上手。</p><a id="more"></a><h1 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h1><h2 id="web工作方式的几个概念"><a href="#web工作方式的几个概念" class="headerlink" title="web工作方式的几个概念"></a>web工作方式的几个概念</h2><p><strong>Request：</strong>用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息<br><strong>Response：</strong>服务器需要反馈给客户端的信息<br><strong>Conn：</strong>用户的每次请求链接<br><strong>Handler：</strong>处理请求和生成返回信息的处理逻辑</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>使用go语言可以采用<code>net/http</code>包进行web搭建，like this：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行web.exe，此时在9090端口开始监听http链接请求<br>打开<a href="http://localhost:9090" target="_blank" rel="noopener">http://localhost:9090</a>即可看到浏览器页面输出<code>Hello astaxie!</code></p><p>我们可以对比<localhost:9090 ?url_long="111&url_long=222">下terminal的输出：</localhost:9090></p><div class="table-container"><table><thead><tr><th>map[]<br>path /<br>scheme<br>[]<br>map[]<br>path /favicon.ico<br>scheme<br>[]</th><th>map[url_long:[111 222]]<br>path /<br>scheme<br>[111 222]<br>key: url_long<br>val: 111222<br>map[]<br>path /favicon.ico<br>scheme<br>[]</th></tr></thead><tbody><tr><td><a href="http://localhost:9090" target="_blank" rel="noopener">http://localhost:9090</a></td><td><a href="http://localhost:9090/?url_long=111&amp;url_long=222" target="_blank" rel="noopener">http://localhost:9090/?url_long=111&amp;url_long=222</a></td></tr></tbody></table></div><h2 id="http包运行机制"><a href="#http包运行机制" class="headerlink" title="http包运行机制"></a>http包运行机制</h2><p><strong>http包执行流程</strong>：<br><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/3.3.http.png?raw=true" alt="web流程"></p><ol><li>创建Listen Socket, 监听指定端口, 等待客户端请求。</li><li>Listen Socket接受客户端请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。</li><li>处理客户端请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。</li></ol><p><strong>Go是如何让Web运行起来：</strong>如何监听端口？如何接收客户端请求？如何分配handler？</p><p>Go通过函数<code>ListenAndServe</code>来处理，即例子中<code>err := http.ListenAndServe(&quot;:9090&quot;, nil)</code><br>具体如下：先初始化一个server对象，然后调用函数<code>net.Listen(&quot;tcp&quot;, addr)</code>，即底层用TCP协议搭建了一个服务，然后监控我们设置的端口。</p><p>下面代码来自Go的http包的源码，可以看到整个的http处理过程：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                log.Printf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c, err := srv.newConn(rw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> c.serve()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>监控之后如何接收客户端的请求？</strong></p><p>上面代码执行监控端口之后，调用函数<code>srv.Serve(net.Listener)</code>处理接收客户端的请求信息。</p><p>这个函数里面起了一个<code>for{}</code>，首先通过Listener接收请求，其次创建一个Conn，最后单独开了一个goroutine，把这个请求的数据当做参数扔给这个conn去服务：<code>go c.serve()</code>体现高并发，用户的每一次请求都是在一个新的goroutine去服务，互不影响。</p><p><strong>如何具体分配到相应的函数来处理请求呢？</strong></p><p>conn首先会解析request:<code>c.readRequest()</code>,然后获取相应的handler:<code>handler := c.server.Handler</code>，也就是我们刚才在调用函数<code>err := http.ListenAndServe(&quot;:9090&quot;, nil)</code>时候的第二个参数，传递nil即为空，那么默认获取<code>handler = DefaultServeMux</code>,这个变量就是一个路由器，用来匹配url跳转到其相应的handle函数，这个变量的设置，在main的第一句<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>里，相当于注册了请求<code>/</code>的路由规则，当请求uri为”/“，路由就会转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部感觉就是sayhelloName方法的callback，最后将信息写入response反馈到client。</p><p><strong>http连接处理的具体流程可以如下显示：</strong></p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/3.3.illustrator.png?raw=true" alt="http连接处理流程"></p><h2 id="Go的http包详解"><a href="#Go的http包详解" class="headerlink" title="Go的http包详解"></a>Go的http包详解</h2><p>上面是过个系统性的流程（类似复习计网的感觉）接下来详谈http包：</p><p>先谈下Go的http包的两个核心功能：<strong>Conn、ServeMux</strong></p><h3 id="Conn的goroutine"><a href="#Conn的goroutine" class="headerlink" title="Conn的goroutine"></a>Conn的goroutine</h3><p>Go为了实现高并发和高性能, 使用goroutines处理Conn的读写事件,<br>这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。</p><p>Go在等待客户端请求里面是这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></table></figure><p>client的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，保证了每个请求的独立性。</p><h3 id="ServeMux的自定义"><a href="#ServeMux的自定义" class="headerlink" title="ServeMux的自定义"></a>ServeMux的自定义</h3><h4 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h4><p>之前描述conn.server时，其实内部是调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。该路由器的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex   <span class="comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有host信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下muxEntry的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    explicit <span class="keyword">bool</span>   <span class="comment">// 是否精确匹配</span></span><br><span class="line">    h        Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">    pattern  <span class="keyword">string</span>  <span class="comment">//匹配字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下Handler的定义，标准的interface，但实际使用时并不需要显示继承该接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  <span class="comment">// 路由实现器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在http包里定义了一个类型<code>HandlerFunc</code>,我们定义的函数<code>sayhelloName</code>就是这个HandlerFunc调用之后的结果<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>，这个类型默认实现了ServeHTTP接口，即我们调用了HandlerFunc(f),强制类型转换f成为HandlerFunc类型，这样f就拥有了ServeHTTP方法。不过这个使用时可以不管，但学习时候还是清楚一下比较好（小声）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体请求的分发"><a href="#具体请求的分发" class="headerlink" title="具体请求的分发"></a>具体请求的分发</h4><p>路由器里面存储好了相应的路由规则之后，如何实现具体请求的分发？<br>默认的路由器实现了<code>ServeHTTP</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示路由器接收到请求之后，如果是<code>*</code>那么关闭链接，不然调用<code>mux.Handler(r)</code>返回对应设置路由的处理Handler，然后执行<code>h.ServeHTTP(w, r)</code>也就是调用对应路由的handler的ServerHTTP接口。</p><p>那么mux.Handler(r)怎么处理的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class="line">            _, pattern = mux.handler(r.Host, p)</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(p, StatusMovedPermanently), pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据用户请求的URL和路由器里面存储的map去匹配的，当匹配到之后返回存储的handler，调用这个handler的ServeHTTP接口就可以执行到相应的函数了。</p><p>以上是整个路由过程，Go其实支持外部实现的路由器 <code>ListenAndServe</code>的第二个参数就是用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了Handler接口就可以,我们可以在自己实现的路由器的ServeHTTP里面实现自定义路由功能。</p><p>如下代码所示，我们可以自己实现一个简易的路由器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMux <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MyMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.URL.Path == <span class="string">"/"</span> &#123;</span><br><span class="line">        sayhelloName(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello myroute!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := &amp;MyMux&#123;&#125;</span><br><span class="line">    http.ListenAndServe(<span class="string">":9090"</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go代码的执行流程"><a href="#Go代码的执行流程" class="headerlink" title="Go代码的执行流程"></a>Go代码的执行流程</h3><p>通过对http包的分析之后，梳理下整个的代码执行过程：</p><ul><li><p><strong>首先调用Http.HandleFunc：</strong></p><p>1   调用了DefaultServeMux的HandleFunc<br>2   调用了DefaultServeMux的Handle<br>3   往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则</p></li><li><p><strong>其次调用http.ListenAndServe(“:9090”, nil)：</strong></p><p>1   实例化Server<br>2   调用Server的ListenAndServe()<br>3   调用net.Listen(“tcp”, addr)监听端口<br>4   启动一个for循环，在循环体中Accept请求<br>5   对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()<br>6   读取每个请求的内容w, err := c.readRequest()<br>7   判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux<br>8   调用handler的ServeHttp<br>9   在这个例子中，下面就进入到DefaultServeMux.ServeHttp<br>10 根据request选择handler，并且进入到这个handler的ServeHTTP<br>  <code>mux.handler(r).ServeHTTP(w, r)</code><br>11 选择handler：<br>  A 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）<br>  B 如果有路由满足，调用这个路由handler的ServeHTTP<br>  C 如果没有路由满足，调用NotFoundHandler的ServeHTTP</p></li></ul><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>对于表单，写过前后端的朋友应该比较熟悉了，方便前后端数据交互。</p><p>表单是一个包含表单元素的区域。表单元素是允许用户在表单中（eg：文本域、下拉列表、单选框、复选框etc.）输入信息的元素。表单使用表单标签（\）定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">...</span><br><span class="line">input 元素</span><br><span class="line">...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="处理表单的输入"><a href="#处理表单的输入" class="headerlink" title="处理表单的输入"></a>处理表单的输入</h2><p>先来看一个表单递交的例子，我们有如下的表单内容，命名成文件login.gtpl(放入当前新建项目的目录里面)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面递交表单到服务器的<code>/login</code>，当用户输入信息点击登录之后，会跳转到服务器的路由<code>login</code>里面，我们首先要判断这个是什么方式传递过来，POST还是GET呢？</p><p>http包里面有一个很简单的方式就可以获取，在前面web例子的基础上来看看怎么处理login页面的form数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()       <span class="comment">//解析url传递的参数，对于POST则解析响应包的主体（request body）</span></span><br><span class="line">    <span class="comment">//注意:如果没有调用ParseForm方法，下面无法获取表单的数据</span></span><br><span class="line">    fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        log.Println(t.Execute(w, <span class="literal">nil</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">        fmt.Println(<span class="string">"username:"</span>, r.Form[<span class="string">"username"</span>])</span><br><span class="line">        fmt.Println(<span class="string">"password:"</span>, r.Form[<span class="string">"password"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/login"</span>, login)         <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取请求方法是通过<code>r.Method</code>来完成的，这是个字符串类型的变量，返回GET, POST, PUT等method信息。</p><p>login函数中我们根据<code>r.Method</code>来判断是显示登录界面还是处理登录逻辑。当GET方式请求时显示登录界面，其他方式请求时则处理登录逻辑，如查询数据库、验证登录信息等。</p><p>当我们在浏览器里面打开<code>http://127.0.0.1:9090/login</code>的时候，出现如下界面</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/4.1.login.png?raw=true" alt="img">    </p><p>如果你看到一个空页面，可能是你写的 login.gtpl 文件中有错误，请根据控制台中的日志进行修复。</p><p>我们输入用户名和密码之后发现在服务器端是不会打印出来任何输出的，为什么呢？默认情况下，Handler里面是不会自动解析form的，必须显式的调用<code>r.ParseForm()</code>后，你才能对这个表单数据进行操作。我们修改一下代码，在<code>fmt.Println(&quot;username:&quot;, r.Form[&quot;username&quot;])</code>之前加一行<code>r.ParseForm()</code>,重新编译，再次测试输入递交，现在是不是在服务器端有输出你的输入的用户名和密码了。</p><p><code>r.Form</code>里面包含了所有请求的参数，比如URL中query-string、POST的数据、PUT的数据，所以当你在URL中的query-string字段和POST冲突时，会保存成一个slice，里面存储了多个值，Go官方文档中说在接下来的版本里面将会把POST、GET这些数据分离开来。</p><p>现在我们修改一下login.gtpl里面form的action值<code>http://127.0.0.1:9090/login</code>修改为<code>http://127.0.0.1:9090/login?username=astaxie</code>，再次测试，服务器的输出username是不是一个slice。服务器端的输出如下：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/4.1.slice.png?raw=true" alt="img"></p><p><code>request.Form</code>是一个url.Values类型，里面存储的是对应的类似<code>key=value</code>的信息，下面展示了可以对form数据进行的一些操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">"name"</span>, <span class="string">"Ava"</span>)</span><br><span class="line">v.Add(<span class="string">"friend"</span>, <span class="string">"Jess"</span>)</span><br><span class="line">v.Add(<span class="string">"friend"</span>, <span class="string">"Sarah"</span>)</span><br><span class="line">v.Add(<span class="string">"friend"</span>, <span class="string">"Zoe"</span>)</span><br><span class="line"><span class="comment">// v.Encode() == "name=Ava&amp;friend=Jess&amp;friend=Sarah&amp;friend=Zoe"</span></span><br><span class="line">fmt.Println(v.Get(<span class="string">"name"</span>))</span><br><span class="line">fmt.Println(v.Get(<span class="string">"friend"</span>))</span><br><span class="line">fmt.Println(v[<span class="string">"friend"</span>])</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips</strong>: Request本身也提供了FormValue()函数来获取用户提交的参数。如r.Form[“username”]也可写成r.FormValue(“username”)。调用r.FormValue时会自动调用r.ParseForm，所以不必提前调用。r.FormValue只会返回同名参数中的第一个，若参数不存在则返回空字符串。</p></blockquote><h2 id="验证表单的输入"><a href="#验证表单的输入" class="headerlink" title="验证表单的输入"></a>验证表单的输入</h2><p>开发Web的一个原则就是，不能信任用户输入的任何信息，所以验证和过滤用户的输入信息就变得非常重要。<br>~（就如某软件安全设计老师所说）~</p><p>我们平常编写Web应用主要有两方面的数据验证，一个是在页面端的js验证(目前在这方面有很多的插件库，比如ValidationJS插件)，一个是在服务器端的验证，下面是如何在服务器端验证。</p><h3 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h3><p>通过len来获取数据的长度限定非空：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.Form[<span class="string">"username"</span>][<span class="number">0</span>])==<span class="number">0</span>&#123;</span><br><span class="line">    <span class="comment">//为空的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r.Form</code>对不同类型的表单元素的留空有不同的处理， 对于空文本框、空文本区域以及文件上传，元素的值为空值，而如果是未选中的复选框和单选按钮，则根本不会在r.Form中产生相应条目。所以建议通过<code>r.Form.Get()</code>来获取值，如果字段不存在，通过该方式获取的是空值。但<code>r.Form.Get()</code>只能获取单个的值，如果是map的值，必须通过上面的方式来获取。</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>如果我们是判断正整数，那么我们先转化成int类型，然后进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getint,err:=strconv.Atoi(r.Form.Get(<span class="string">"age"</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//数字转化出错了，那么可能就不是数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就可以判断这个数字的大小范围了</span></span><br><span class="line"><span class="keyword">if</span> getint &gt;<span class="number">100</span> &#123;</span><br><span class="line">    <span class="comment">//太大了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方式就是正则匹配的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^[0-9]+$"</span>, r.Form.Get(<span class="string">"age"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go实现的正则是<a href="http://code.google.com/p/re2/wiki/Syntax" target="_blank" rel="noopener">RE2</a>，所有的字符都是UTF-8编码的。</p></blockquote><h3 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h3><p>对于中文我们目前有两种方式来验证，可以使用 <code>unicode</code> 包提供的 <code>func Is(rangeTab *RangeTable, r rune) bool</code> 来验证，也可以使用正则方式来验证，这里使用最简单的正则方式，如下代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^\\p&#123;Han&#125;+$"</span>, r.Form.Get(<span class="string">"realname"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h3><p>通过正则验证数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^[a-zA-Z]+$"</span>, r.Form.Get(<span class="string">"engname"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电子邮件地址"><a href="#电子邮件地址" class="headerlink" title="电子邮件地址"></a>电子邮件地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;).([a-z]&#123;2,4&#125;)$`</span>, r.Form.Get(<span class="string">"email"</span>)); !m &#123;</span><br><span class="line">    fmt.Println(<span class="string">"no"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"yes"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(1[3|4|5|8][0-9]\d&#123;4,8&#125;)$`</span>, r.Form.Get(<span class="string">"mobile"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><p>如果我们想要判断表单里面<code>&lt;select&gt;</code>元素生成的下拉菜单中是否有被选中的项目。有些时候黑客可能会伪造这个下拉菜单不存在的值发送给你，那么如何判断这个值是否是我们预设的值呢？</p><p>我们的select可能是这样的一些元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"fruit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"apple"</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"pear"</span>&gt;</span>pear<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"banane"</span>&gt;</span>banane<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么我们可以这样来验证</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"apple"</span>,<span class="string">"pear"</span>,<span class="string">"banane"</span>&#125;</span><br><span class="line"></span><br><span class="line">v := r.Form.Get(<span class="string">"fruit"</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> item == v &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><p>如果我们想要判断radio按钮是否有一个被选中了，我们页面的输出可能就是一个男、女性别的选择，但是也可能一个15岁大的无聊小孩，一手拿着http协议的书，另一只手通过telnet客户端向你的程序在发送请求呢，你设定的性别男值是1，女是2，他给你发送一个3，你的程序会出现异常吗？因此我们也需要像下拉菜单的判断方式类似，判断我们获取的值是我们预设的值，而不是额外的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>女</span><br></pre></td></tr></table></figure><p>那我们也可以类似下拉菜单的做法一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> v == r.Form.Get(<span class="string">"gender"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>有一项选择兴趣的复选框，你想确定用户选中的和你提供给用户选择的是同一个类型的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"football"</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"basketball"</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"tennis"</span>&gt;</span>网球</span><br></pre></td></tr></table></figure><p>对于复选框我们的验证和单选有点不一样，因为接收到的数据是一个slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">string</span>&#123;<span class="string">"football"</span>,<span class="string">"basketball"</span>,<span class="string">"tennis"</span>&#125;</span><br><span class="line">a:=Slice_diff(r.Form[<span class="string">"interest"</span>],slice)</span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面这个函数<code>Slice_diff</code>包含在大佬<a href="https://github.com/astaxie/beeku" target="_blank" rel="noopener">astaxie</a>开源的一个库里面(操作slice和map的库)</p><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>Go里面提供了一个time的处理包，我们可以把用户的输入年月日转化成相应的时间，然后进行逻辑判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := time.Date(<span class="number">2009</span>, time.November, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Printf(<span class="string">"Go launched at %s\n"</span>, t.Local())</span><br></pre></td></tr></table></figure><p>获取time之后我们就可以进行很多时间函数的操作。具体的判断就根据自己的需求调整。</p><h3 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证15位身份证，15位的是全部数字</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;15&#125;)$`</span>, r.Form.Get(<span class="string">"usercard"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证18位身份证，18位前17位为数字，最后一位是校验位，可能为数字或字符X。</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;17&#125;)([0-9]|X)$`</span>, r.Form.Get(<span class="string">"usercard"</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预防XSS攻击"><a href="#预防XSS攻击" class="headerlink" title="预防XSS攻击"></a>预防XSS攻击</h2><p>动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成 XSS）的威胁，而静态站点则完全不受其影响。~（还记得期末把XSS写成CSS的绝望，缩写成XSS是为了和前端CSS区分）~</p><p>攻击者通常会在有漏洞的程序中插入JavaScript、VBScript、 ActiveX或Flash以欺骗用户。一旦得手，他们可以盗取用户帐户信息，修改用户设置，盗取/污染cookie和植入恶意广告等。</p><p>对XSS最佳的防护应该结合以下两种方法：一是验证所有输入数据，有效检测攻击(这个我们前面小节已经有过介绍)；另一个是对所有输出数据进行适当的处理，以防止任何已成功注入的脚本在浏览器端运行。</p><p>Go的html/template里面带有下面几个函数可以帮忙转义：</p><ul><li>func HTMLEscape(w io.Writer, b []byte) //把b进行转义之后写到w</li><li>func HTMLEscapeString(s string) string //转义s之后返回结果字符串</li><li>func HTMLEscaper(args …interface{}) string //支持多个参数一起转义，返回结果字符串</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"username:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">//输出到服务器端</span></span><br><span class="line">fmt.Println(<span class="string">"password:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"password"</span>)))</span><br><span class="line">template.HTMLEscape(w, []<span class="keyword">byte</span>(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">//输出到客户端</span></span><br></pre></td></tr></table></figure><p>如果输入的username是<code>&lt;script&gt;alert()&lt;/script&gt;</code>，浏览器上输出如下所示：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/4.3.escape.png?raw=true" alt="img"></p><h2 id="防止多次提交表单"><a href="#防止多次提交表单" class="headerlink" title="防止多次提交表单"></a>防止多次提交表单</h2><p>不知道你是否曾经看到过一个论坛或者博客，在一个帖子或者文章后面出现多条重复的记录，这些大多数是因为用户重复递交了留言的表单引起的。由于种种原因，用户经常会重复递交表单。通常这只是鼠标的误操作，如双击了递交按钮，也可能是为了编辑或者再次核对填写过的信息，点击了浏览器的后退按钮，然后又再次点击了递交按钮而不是浏览器的前进按钮。当然，也可能是故意的——比如，在某项在线调查或者博彩活动中重复投票。那我们如何有效的防止用户多次递交相同的表单呢？</p><p>解决方案是在表单中添加一个带有唯一值的隐藏字段。在验证表单时，先检查带有该唯一值的表单是否已经递交过了。如果是，拒绝再次递交；如果不是，则处理表单进行逻辑处理。另外，如果是采用了Ajax模式递交表单的话，当表单递交后，通过javascript来禁用表单的递交按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"football"</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"basketball"</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"interest"</span> <span class="attr">value</span>=<span class="string">"tennis"</span>&gt;</span>网球    </span><br><span class="line">用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"token"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123;.&#125;&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在模版里面增加了一个隐藏字段<code>token</code>，这个值我们通过MD5(时间戳)来获取唯一值，然后我们把这个值存储到服务器端(session控制，之后再说)，以方便表单提交时比对判定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//请求的是登陆数据，那么执行登陆的逻辑判断</span></span><br><span class="line">        r.ParseForm()</span><br><span class="line">        token := r.Form.Get(<span class="string">"token"</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">""</span> &#123;</span><br><span class="line">            <span class="comment">//验证token的合法性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在token报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"username length:"</span>, <span class="built_in">len</span>(r.Form[<span class="string">"username"</span>][<span class="number">0</span>]))</span><br><span class="line">        fmt.Println(<span class="string">"username:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">//输出到服务器端</span></span><br><span class="line">        fmt.Println(<span class="string">"password:"</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">"password"</span>)))</span><br><span class="line">        template.HTMLEscape(w, []<span class="keyword">byte</span>(r.Form.Get(<span class="string">"username"</span>))) <span class="comment">//输出到客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出到页面的源码如下：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/4.4.token.png?raw=true" alt="img"></p><p>我们看到token已经有输出值，你可以不断的刷新，可以看到这个值在不断的变化。这样就保证了每次显示form表单的时候都是唯一的，用户递交的表单保持了唯一性。</p><p>我们的解决方案可以防止非恶意的攻击，并能使恶意用户暂时不知所措，然后，它却不能排除所有的欺骗性的动机，对此类情况还需要更复杂的工作。</p><h2 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h2><p>要使表单能够上传文件，首先第一步就是要添加form的<code>enctype</code>属性，<code>enctype</code>属性有如下三种情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class="line">multipart/form-data      不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class="line">text/plain      空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure><p>所以，创建新的表单html文件, 命名为upload.gtpl, html代码应该类似于:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadfile"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"token"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123;.&#125;&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在服务器端，我们增加一个handlerFunc:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/upload"</span>, upload)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理/upload 逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"upload.gtpl"</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">        file, handler, err := r.FormFile(<span class="string">"uploadfile"</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%v"</span>, handler.Header)</span><br><span class="line">        f, err := os.OpenFile(<span class="string">"./test/"</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)  <span class="comment">// 此处假设当前目录下已存在test目录</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">        io.Copy(f, file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以看到，处理文件上传我们需要调用<code>r.ParseMultipartForm</code>，里面的参数表示<code>maxMemory</code>，调用<code>ParseMultipartForm</code>之后，上传的文件存储在<code>maxMemory</code>大小的内存里面，如果文件大小超过了<code>maxMemory</code>，那么剩下的部分将存储在系统的临时文件中。我们可以通过<code>r.FormFile</code>获取上面的文件句柄，然后实例中使用了<code>io.Copy</code>来存储文件。</p><blockquote><p>获取其他非文件字段信息的时候就不需要调用<code>r.ParseForm</code>，因为在需要的时候Go自动会去调用。而且<code>ParseMultipartForm</code>调用一次之后，后面再次调用不会再有效果。</p></blockquote><p>通过上面的实例我们可以看到我们上传文件主要三步处理：</p><ol><li>表单中增加enctype=”multipart/form-data”</li><li>服务端调用<code>r.ParseMultipartForm</code>,把上传的文件存储在内存和临时文件中</li><li>使用<code>r.FormFile</code>获取文件句柄，然后对文件进行存储等处理。</li></ol><p>文件handler是multipart.FileHeader,里面存储了如下结构信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Filename <span class="keyword">string</span></span><br><span class="line">    Header   textproto.MIMEHeader</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过上面的实例代码打印出来上传文件的信息如下</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/4.5.upload2.png?raw=true" alt="img"></p><h3 id="客户端上传文件"><a href="#客户端上传文件" class="headerlink" title="客户端上传文件"></a>客户端上传文件</h3><p>除了通过表单上传文件，然后在服务器端处理文件外，Go还支持模拟客户端表单功能支持文件上传：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"mime/multipart"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postFile</span><span class="params">(filename <span class="keyword">string</span>, targetUrl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    bodyBuf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    bodyWriter := multipart.NewWriter(bodyBuf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键的一步操作</span></span><br><span class="line">    fileWriter, err := bodyWriter.CreateFormFile(<span class="string">"uploadfile"</span>, filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error writing to buffer"</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件句柄操作</span></span><br><span class="line">    fh, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error opening file"</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fh.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iocopy</span></span><br><span class="line">    _, err = io.Copy(fileWriter, fh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contentType := bodyWriter.FormDataContentType()</span><br><span class="line">    bodyWriter.Close()</span><br><span class="line"></span><br><span class="line">    resp, err := http.Post(targetUrl, contentType, bodyBuf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    resp_body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(resp.Status)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(resp_body))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample usage</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    target_url := <span class="string">"http://localhost:9090/upload"</span></span><br><span class="line">    filename := <span class="string">"./astaxie.pdf"</span></span><br><span class="line">    postFile(filename, target_url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。</p><blockquote><p>如果还有其他普通字段例如username之类的需要同时写入，那么可以调用multipart的WriteField方法写很多其他类似的字段。</p></blockquote><h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><h2 id="database-sql接口"><a href="#database-sql接口" class="headerlink" title="database/sql接口"></a>database/sql接口</h2><p>Go与PHP不同的地方是Go官方没有提供数据库驱动，而是为开发数据库驱动定义了一些标准接口，开发者可以根据定义的接口来开发相应的数据库驱动，这样做有一个好处，只要是按照标准接口开发的代码， 以后需要迁移数据库时，不需要任何修改。</p><p>以下为Go定义的标准接口：</p><h3 id="sql-Register"><a href="#sql-Register" class="headerlink" title="sql.Register"></a>sql.Register</h3><p>这个存在于database/sql的函数是用来注册数据库驱动的，当第三方开发者开发数据库驱动时，都会实现init函数，在init里面会调用这个<code>Register(name string, driver driver.Driver)</code>完成本驱动的注册。</p><p>我们来看一下mymysql、sqlite3的驱动里面都是怎么调用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/mattn/go-sqlite3驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sql.Register(<span class="string">"sqlite3"</span>, &amp;SQLiteDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://github.com/mikespook/mymysql驱动</span></span><br><span class="line"><span class="comment">// Driver automatically registered in database/sql</span></span><br><span class="line"><span class="keyword">var</span> d = Driver&#123;proto: <span class="string">"tcp"</span>, raddr: <span class="string">"127.0.0.1:3306"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Register(<span class="string">"SET NAMES utf8"</span>)</span><br><span class="line">    sql.Register(<span class="string">"mymysql"</span>, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到第三方数据库驱动都是通过调用这个函数来注册自己的数据库驱动名称以及相应的driver实现。在database/sql内部通过一个map来存储用户定义的相应驱动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drivers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</span><br><span class="line"></span><br><span class="line">drivers[name] = driver</span><br></pre></td></tr></table></figure><p>因此通过database/sql的注册函数可以同时注册多个数据库驱动，只要不重复。</p><blockquote><p>在我们使用database/sql接口和第三方库的时候经常看到如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    import (</span><br><span class="line">&gt;        &quot;database/sql&quot;</span><br><span class="line">&gt;         _ &quot;github.com/mattn/go-sqlite3&quot;</span><br><span class="line">&gt;    )</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>新手都会被这个<code>_</code>所迷惑，其实这个就是Go设计的巧妙之处，我们在变量赋值的时候经常看到这个符号，它是用来忽略变量赋值的占位符，那么包引入用到这个符号也是相似的作用，这儿使用<code>_</code>的意思是引入后面的包名而不直接使用这个包中定义的函数，变量等资源。</p><p>我们在流程和函数一节中介绍过init函数的初始化过程，包在引入的时候会自动调用包的init函数以完成对包的初始化。因此，我们引入上面的数据库驱动包之后会自动去调用init函数，然后在init函数里面注册这个数据库驱动，这样我们就可以在接下来的代码中直接使用这个数据库驱动了。</p></blockquote><h3 id="driver-Driver"><a href="#driver-Driver" class="headerlink" title="driver.Driver"></a>driver.Driver</h3><p>Driver是一个数据库驱动的接口，他定义了一个method： Open(name string)，这个方法返回一个数据库的Conn接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Open(name <span class="keyword">string</span>) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回的Conn只能用来进行一次goroutine的操作</strong>，即不能把这个Conn应用于多个goroutine里面。</p><p>如下代码会出现错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">go</span> goroutineA (Conn)  <span class="comment">//执行查询操作</span></span><br><span class="line"><span class="keyword">go</span> goroutineB (Conn)  <span class="comment">//执行插入操作</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这样的代码可能会使Go不知道某个操作究竟是由哪个goroutine发起的,从而导致数据混乱，比如可能会把goroutineA里面执行的查询操作的结果返回给goroutineB从而使B错误地把此结果当成自己执行的插入数据。</p><p>第三方驱动都会定义这个函数，它会解析name参数来获取相关数据库的连接信息，解析完成后，它将使用此信息来初始化一个Conn并返回它。</p><h3 id="driver-Conn"><a href="#driver-Conn" class="headerlink" title="driver.Conn"></a>driver.Conn</h3><p>Conn是一个数据库连接的接口定义，这个Conn只能应用在一个goroutine里面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    Prepare(query <span class="keyword">string</span>) (Stmt, error)</span><br><span class="line">    Close() error</span><br><span class="line">    Begin() (Tx, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prepare函数返回与当前连接相关的执行Sql语句的准备状态，可以进行查询、删除等操作。</p><p>Close函数关闭当前的连接，执行释放连接拥有的资源等清理工作。因为驱动实现了database/sql里面建议的conn pool，所以不用再去实现缓存conn之类的，这样会容易引起问题。</p><p>Begin函数返回一个代表事务处理的Tx，通过它你可以进行查询,更新等操作，或者对事务进行回滚、递交。</p><h3 id="driver-Stmt"><a href="#driver-Stmt" class="headerlink" title="driver.Stmt"></a>driver.Stmt</h3><p>Stmt是一种准备好的状态，和Conn相关联，只能应用于一个goroutine中，不能应用于多个goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">    NumInput() <span class="keyword">int</span></span><br><span class="line">    Exec(args []Value) (Result, error)</span><br><span class="line">    Query(args []Value) (Rows, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Close函数关闭当前的链接状态，但是如果当前正在执行query，query还是有效返回rows数据。</p><p>NumInput函数返回当前预留参数的个数，当返回&gt;=0时数据库驱动就会智能检查调用者的参数。当数据库驱动包不知道预留参数的时候，返回-1。</p><p>Exec函数执行Prepare准备好的sql，传入参数执行update/insert等操作，返回Result数据</p><p>Query函数执行Prepare准备好的sql，传入需要的参数执行select操作，返回Rows结果集</p><h3 id="driver-Tx"><a href="#driver-Tx" class="headerlink" title="driver.Tx"></a>driver.Tx</h3><p>事务处理一般就两个过程，递交或者回滚。数据库驱动里面也只需要实现这两个函数就可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tx <span class="keyword">interface</span> &#123;</span><br><span class="line">    Commit() error</span><br><span class="line">    Rollback() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数一个用来递交一个事务，一个用来回滚事务。</p><h3 id="driver-Execer"><a href="#driver-Execer" class="headerlink" title="driver.Execer"></a>driver.Execer</h3><p>这是一个Conn可选择实现的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec(query <span class="keyword">string</span>, args []Value) (Result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个接口没有定义，那么在调用DB.Exec,就会首先调用Prepare返回Stmt，然后执行Stmt的Exec，然后关闭Stmt。</p><h3 id="driver-Result"><a href="#driver-Result" class="headerlink" title="driver.Result"></a>driver.Result</h3><p>这个是执行Update/Insert等操作返回的结果接口定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">interface</span> &#123;</span><br><span class="line">    LastInsertId() (<span class="keyword">int64</span>, error)</span><br><span class="line">    RowsAffected() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LastInsertId函数返回由数据库执行插入操作得到的自增ID号。</p><p>RowsAffected函数返回query操作影响的数据条目数。</p><h3 id="driver-Rows"><a href="#driver-Rows" class="headerlink" title="driver.Rows"></a>driver.Rows</h3><p>Rows是执行查询返回的结果集接口定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rows <span class="keyword">interface</span> &#123;</span><br><span class="line">    Columns() []<span class="keyword">string</span></span><br><span class="line">    Close() error</span><br><span class="line">    Next(dest []Value) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Columns函数返回查询数据库表的字段信息，这个返回的slice和sql查询的字段一一对应，而不是返回整个表的所有字段。</p><p>Close函数用来关闭Rows迭代器。</p><p>Next函数用来返回下一条数据，把数据赋值给dest。dest里面的元素必须是driver.Value的值除了string，返回的数据里面所有的string都必须要转换成[]byte。如果最后没数据了，Next函数最后返回io.EOF。</p><h3 id="driver-RowsAffected"><a href="#driver-RowsAffected" class="headerlink" title="driver.RowsAffected"></a>driver.RowsAffected</h3><p>RowsAffected其实就是一个int64的别名，但是他实现了Result接口，用来底层实现Result的表示方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RowsAffected <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(RowsAffected)</span> <span class="title">LastInsertId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v RowsAffected)</span> <span class="title">RowsAffected</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br></pre></td></tr></table></figure><h3 id="driver-Value"><a href="#driver-Value" class="headerlink" title="driver.Value"></a>driver.Value</h3><p>Value其实就是一个空接口，他可以容纳任何的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>drive的Value是驱动必须能够操作的Value，Value要么是nil，要么是下面的任意一种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span></span><br><span class="line"><span class="keyword">float64</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">[]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">string</span>   [*]除了Rows.Next返回的不能是<span class="keyword">string</span>.</span><br><span class="line">time.Time</span><br></pre></td></tr></table></figure><h3 id="driver-ValueConverter"><a href="#driver-ValueConverter" class="headerlink" title="driver.ValueConverter"></a>driver.ValueConverter</h3><p>ValueConverter接口定义了如何把一个普通的值转化成driver.Value的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValueConverter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ConvertValue(v <span class="keyword">interface</span>&#123;&#125;) (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发的数据库驱动包里面实现这个接口的函数在很多地方会使用到，这个ValueConverter有很多好处：</p><ul><li>转化driver.value到数据库表相应的字段，例如int64的数据如何转化成数据库表uint16字段</li><li>把数据库查询结果转化成driver.Value值</li><li>在scan函数里面如何把driver.Value值转化成用户定义的值</li></ul><h3 id="driver-Valuer"><a href="#driver-Valuer" class="headerlink" title="driver.Valuer"></a>driver.Valuer</h3><p>Valuer接口定义了返回一个driver.Value的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Value() (Value, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多类型都实现了这个Value方法，用来自身与driver.Value的转化。</p><p>通过上面的讲解，你应该对于驱动的开发有了一个基本的了解，一个驱动只要实现了这些接口就能完成增删查改等基本操作了，剩下的就是与相应的数据库进行数据交互等细节问题了，在此不再赘述。</p><h3 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h3><p>database/sql在database/sql/driver提供的接口基础上定义了一些更高阶的方法，用以简化数据库操作,同时内部还建议性地实现一个conn pool。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    driver      driver.Driver</span><br><span class="line">    dsn         <span class="keyword">string</span></span><br><span class="line">    mu       sync.Mutex <span class="comment">// protects freeConn and closed</span></span><br><span class="line">    freeConn []driver.Conn</span><br><span class="line">    closed   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Open函数返回的是DB对象，里面有一个freeConn，它就是那个简易的连接池。它的实现相当简单或者说简陋，就是当执行Db.prepare的时候会<code>defer db.putConn(ci, err)</code>,也就是把这个连接放入连接池，每次调用conn的时候会先判断freeConn的长度是否大于0，大于0说明有可以复用的conn，直接拿出来用就是了，如果不大于0，则创建一个conn,然后再返回之。</p><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><p>PostgreSQL 是一个自由的对象-关系数据库服务器(数据库管理系统)，也是笔者在数据库课上学所学的数据库，所以就直接用它了。<em>TIPS:打开pgAdmin如果出现无法连接并要求输入postgres密码的情况，请打开任务管理器&gt;服务，找到并启动postgresql-x64-10即可</em></p><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>Go实现的支持PostgreSQL的驱动也很多，因为国外很多人在开发中使用了这个数据库。以下采用<a href="https://github.com/lib/pq" target="_blank" rel="noopener">github.com/lib/pq</a>驱动，它目前使用的人最多，在github上也比较活跃。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>数据库建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    username <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    departname <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    Created <span class="built_in">date</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> userinfo_pkey PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WITH</span> (OIDS=<span class="literal">FALSE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userdeatail</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">integer</span>,</span><br><span class="line">    intro <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">100</span>),</span><br><span class="line">    profile <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WITH</span>(OIDS=<span class="literal">FALSE</span>);</span><br></pre></td></tr></table></figure><p>看下面这个Go如何操作数据库表数据:增删改查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"user=astaxie password=astaxie dbname=test sslmode=disable"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    stmt, err := db.Prepare(<span class="string">"INSERT INTO userinfo(username,departname,created) VALUES($1,$2,$3) RETURNING uid"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    res, err := stmt.Exec(<span class="string">"astaxie"</span>, <span class="string">"研发部门"</span>, <span class="string">"2012-12-09"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pg不支持这个函数，因为他没有类似MySQL的自增ID</span></span><br><span class="line">    <span class="comment">// id, err := res.LastInsertId()</span></span><br><span class="line">    <span class="comment">// checkErr(err)</span></span><br><span class="line">    <span class="comment">// fmt.Println(id)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lastInsertId <span class="keyword">int</span></span><br><span class="line">    err = db.QueryRow(<span class="string">"INSERT INTO userinfo(username,departname,created) VALUES($1,$2,$3) returning uid;"</span>, <span class="string">"astaxie"</span>, <span class="string">"研发部门"</span>, <span class="string">"2012-12-09"</span>).Scan(&amp;lastInsertId)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    fmt.Println(<span class="string">"最后插入id ="</span>, lastInsertId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    stmt, err = db.Prepare(<span class="string">"update userinfo set username=$1 where uid=$2"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    res, err = stmt.Exec(<span class="string">"astaxieupdate"</span>, <span class="number">1</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    affect, err := res.RowsAffected()</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(affect)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    rows, err := db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">var</span> department <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">var</span> created <span class="keyword">string</span></span><br><span class="line">        err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)</span><br><span class="line">        checkErr(err)</span><br><span class="line">        fmt.Println(uid)</span><br><span class="line">        fmt.Println(username)</span><br><span class="line">        fmt.Println(department)</span><br><span class="line">        fmt.Println(created)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    stmt, err = db.Prepare(<span class="string">"delete from userinfo where uid=$1"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    res, err = stmt.Exec(<span class="number">1</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    affect, err = res.RowsAffected()</span><br><span class="line">    checkErr(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(affect)</span><br><span class="line"></span><br><span class="line">    db.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostgreSQL是通过<code>$1</code>,<code>$2</code>这种方式来指定要传递的参数，而不是MySQL中的<code>?</code>，另外在sql.Open中的dsn信息的格式也与MySQL的驱动中的dsn格式不一样，所以在使用时请注意它们的差异。还有pg不支持LastInsertId函数，因为PostgreSQL内部没有实现类似MySQL的自增ID返回，其他的代码几乎是一模一样。</p><h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><p>MongoDB是一个高性能，开源，无模式的文档型数据库，是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，采用的是类似json的bjson格式来存储数据，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>目前Go支持mongoDB比较好的驱动有<a href="http://labix.org/mgo" target="_blank" rel="noopener">mgo</a>，这个驱动非常的简明好用，但是作者弃坑了orz<br>官方推出了新的驱动<a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial" target="_blank" rel="noopener">mongo-driver</a>，虽然繁琐一点，但支持了事务的处理，并且是官方的。</p><p>安装方面个人还是建议从github上clone下来然后本地<code>go install go.mongodb.org/mongo-driver</code><br>这里吐槽一下，由于网络原因，不能够直接访问 golang.org，但我们还有镜像啊 <a href="https://github.com/golang" target="_blank" rel="noopener">Golang - Github</a></p><p>安装之后会有个warning，这不要紧，我们自己test一下以下的实例代码（当然请先打开mongo）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"go.mongodb.org/mongo-driver/mongo"</span></span><br><span class="line">    <span class="string">"go.mongodb.org/mongo-driver/mongo/options"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set client options</span></span><br><span class="line">clientOptions := options.Client().ApplyURI(<span class="string">"mongodb://localhost:27017"</span>)</span><br><span class="line"><span class="comment">// Connect to MongoDB</span></span><br><span class="line">client, err := mongo.Connect(context.TODO(), clientOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check the connection</span></span><br><span class="line">err = client.Ping(context.TODO(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Connected to MongoDB!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接后，获取<code>test</code>数据库中集合的句柄：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection := client.Database(<span class="string">"test"</span>).Collection(<span class="string">"trainers"</span>)</span><br></pre></td></tr></table></figure><p>一般需要保持连接到MongoDB的客户端，以便应用程序可以使用连接池，而不是为每个查询打开和关闭连接。</p><p>当然如果应用程序不再需要连接，也可以关闭连接<code>client.Disconnect()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = client.Disconnect(context.TODO())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Connection to MongoDB closed."</span>)</span><br></pre></td></tr></table></figure><h3 id="在Go中使用BSON对象"><a href="#在Go中使用BSON对象" class="headerlink" title="在Go中使用BSON对象"></a>在Go中使用BSON对象</h3><p>MongoDB中的JSON文档以称为BSON（二进制编码的JSON）的二进制表示形式存储。与其他将JSON数据存储为简单字符串和数字的数据库不同，BSON编码扩展了JSON表示形式，以包括其他类型，例如int，long，date，float point和decimal128。这使应用程序更容易可靠地处理，排序和比较数据。go驱动用两种类型来表示BSON数据，D和Raw，接下来我们主要使用D类型。</p><p> The <code>D</code> family consists of four types:</p><ul><li><code>D</code>: A BSON document, which is used in situations where order matters, such as MongoDB commands.</li><li><code>M</code>: An unordered map. It is the same as <code>D</code>, except it does not preserve order.</li><li><code>A</code>: A BSON array.</li><li><code>E</code>: A single element inside a <code>D</code>.</li></ul><p>这是一个使用<code>D</code>类型构建的过滤器文档的示例，该类型可用于查找<code>name</code>字段与Alice或Bob匹配的文档：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bson.D&#123;&#123;</span><br><span class="line">    <span class="string">"name"</span>, </span><br><span class="line">    bson.D&#123;&#123;</span><br><span class="line">        <span class="string">"$in"</span>, </span><br><span class="line">        bson.A&#123;<span class="string">"Alice"</span>, <span class="string">"Bob"</span>&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><p>连接到数据库后，就该开始增删查改了：</p><h4 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h4><p>首先，创建一些新<code>Trainer</code>结构（就是个自定义的结构体）以插入数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ash := Trainer&#123;<span class="string">"Ash"</span>, <span class="number">10</span>, <span class="string">"Pallet Town"</span>&#125;</span><br><span class="line">misty := Trainer&#123;<span class="string">"Misty"</span>, <span class="number">10</span>, <span class="string">"Cerulean City"</span>&#125;</span><br><span class="line">brock := Trainer&#123;<span class="string">"Brock"</span>, <span class="number">15</span>, <span class="string">"Pewter City"</span>&#125;</span><br></pre></td></tr></table></figure><p>插入单个文档，用<code>collection.InsertOne()</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insertResult, err := collection.InsertOne(context.TODO(), ash)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Inserted a single document: "</span>, insertResult.InsertedID)</span><br></pre></td></tr></table></figure><p>需要一次插入多个文档，<code>collection.InsertMany()</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trainers := []<span class="keyword">interface</span>&#123;&#125;&#123;misty, brock&#125;</span><br><span class="line"></span><br><span class="line">insertManyResult, err := collection.InsertMany(context.TODO(), trainers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Inserted multiple documents: "</span>, insertManyResult.InsertedIDs)</span><br></pre></td></tr></table></figure><h4 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h4><p><code>collection.UpdateOne()</code>更新单个文档。它需要先匹配再更新，可以用以下<code>bson.D</code>类型构建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.D&#123;&#123;<span class="string">"name"</span>, <span class="string">"Ash"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">update := bson.D&#123;</span><br><span class="line">    &#123;<span class="string">"$inc"</span>, bson.D&#123;</span><br><span class="line">        &#123;<span class="string">"age"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，此代码将匹配名称为Ash的文档，并将Ash的age加1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updateResult, err := collection.UpdateOne(context.TODO(), filter, update)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Matched %v documents and updated %v documents.\n"</span>, updateResult.MatchedCount, updateResult.ModifiedCount)</span><br></pre></td></tr></table></figure><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p>查找单个文档，用<code>collection.FindOne()</code>。此方法返回单个结果，该结果可以解码为一个值。</p><p>用<code>filter</code>在更新查询中使用的相同变量来匹配名称为Ash的文档。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a value into which the result can be decoded</span></span><br><span class="line"><span class="keyword">var</span> result Trainer</span><br><span class="line"></span><br><span class="line">err = collection.FindOne(context.TODO(), filter).Decode(&amp;result)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Found a single document: %+v\n"</span>, result)</span><br></pre></td></tr></table></figure><p>要查找多个文档，用<code>collection.Find()</code>，此方法返回一个游标<code>Cursor</code>。</p><p> <code>Cursor</code>提供了一系列文档，可以通过它们一次迭代和解码一个文档。一旦<code>Cursor</code>用尽，应该关闭<code>Cursor</code>。<code>options</code>程序包设置一些操作选项，比如设置一个限制，以便仅返回2个文档。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass these options to the Find method</span></span><br><span class="line">findOptions := options.Find()</span><br><span class="line">findOptions.SetLimit(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here's an array in which you can store the decoded documents</span></span><br><span class="line"><span class="keyword">var</span> results []*Trainer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Passing bson.D&#123;&#123;&#125;&#125; as the filter matches all documents in the collection</span></span><br><span class="line">cur, err := collection.Find(context.TODO(), bson.D&#123;&#123;&#125;&#125;, findOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finding multiple documents returns a cursor</span></span><br><span class="line"><span class="comment">// Iterating through the cursor allows us to decode documents one at a time</span></span><br><span class="line"><span class="keyword">for</span> cur.Next(context.TODO()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a value into which the single document can be decoded</span></span><br><span class="line">    <span class="keyword">var</span> elem Trainer</span><br><span class="line">    err := cur.Decode(&amp;elem)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results = <span class="built_in">append</span>(results, &amp;elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cur.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the cursor once finished</span></span><br><span class="line">cur.Close(context.TODO())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Found multiple documents (array of pointers): %+v\n"</span>, results)</span><br></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>用<code>collection.DeleteOne()</code>或<code>collection.DeleteMany()</code>删除文档。传参<code>bson.D</code>作为个过滤器，该参数将匹配集合中的所有文档。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteResult, err := collection.DeleteMany(context.TODO(), bson.D&#123;&#123;&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Deleted %v documents in the trainers collection\n"</span>, deleteResult.DeletedCount)</span><br></pre></td></tr></table></figure><h1 id="session和数据存储"><a href="#session和数据存储" class="headerlink" title="session和数据存储"></a>session和数据存储</h1><h2 id="session-amp-cookie"><a href="#session-amp-cookie" class="headerlink" title="session &amp; cookie"></a>session &amp; cookie</h2><p>当用户来到微博登陆页面，输入用户名和密码之后点击“登录”后浏览器将认证信息POST给远端的服务器，服务器执行验证逻辑，如果验证通过，则浏览器会跳转到登录用户的微博首页，在登录成功后，服务器如何验证我们对其他受限制页面的访问呢？因为HTTP协议是无状态的，所以很显然服务器不可能知道我们已经在上一次的HTTP请求中通过了验证。当然，最简单的解决方案就是所有的请求里面都带上用户名和密码，这样虽然可行，但大大加重了服务器的负担（对于每个request都需要到数据库验证），也大大降低了用户体验(每个页面都需要重新输入用户名密码，每个页面都带有登录表单)。既然直接在请求中带上用户名与密码不可行，那么就只有在服务器或客户端保存一些类似的可以代表身份的信息了，所以就有了cookie与session。</p><p><strong>cookie</strong>，简而言之就是在<strong>本地计算机保存</strong>一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。</p><p><strong>session</strong>，简而言之就是在<strong>服务器上保存</strong>用户操作的历史信息。服务器使用session id来标识session，session id由服务器负责产生，保证随机性与唯一性，相当于一个随机密钥，避免在握手或传输中暴露用户真实密码。但该方式下，仍然需要将发送请求的客户端与session进行对应，所以可以借助cookie机制来获取客户端的标识（即session id），也可以通过GET方式将id提交给服务器。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie是由浏览器维持的，存储在客户端的一小段文本信息，伴随着用户请求和页面在Web服务器和浏览器之间传递。用户每次访问站点时，Web应用程序都可以读取cookie包含的信息。浏览器设置里面有cookie隐私数据选项，打开它，可以看到很多已访问网站的cookies，如下图所示：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/6.1.cookie.png?raw=true" alt="img"></p><p>cookie是有时间限制的，根据生命期不同分成两种：会话cookie和持久cookie；</p><p>如果不设置过期时间，则表示这个cookie生命周期为从创建到浏览器关闭止，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p><p>如果设置了过期时间(setMaxAge(60<em>60</em>24))，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。 　　</p><h4 id="Go设置cookie"><a href="#Go设置cookie" class="headerlink" title="Go设置cookie"></a>Go设置cookie</h4><p>Go语言中通过net/http包中的SetCookie来设置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.SetCookie(w ResponseWriter, cookie *Cookie)</span><br></pre></td></tr></table></figure><p>w表示需要写入的response，cookie是一个struct，让我们来看一下cookie对象是怎么样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span></span><br><span class="line">    Value      <span class="keyword">string</span></span><br><span class="line">    Path       <span class="keyword">string</span></span><br><span class="line">    Domain     <span class="keyword">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxAge=0 means no 'Max-Age' attribute specified.</span></span><br><span class="line"><span class="comment">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span></span><br><span class="line"><span class="comment">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span></span><br><span class="line">    MaxAge   <span class="keyword">int</span></span><br><span class="line">    Secure   <span class="keyword">bool</span></span><br><span class="line">    HttpOnly <span class="keyword">bool</span></span><br><span class="line">    Raw      <span class="keyword">string</span></span><br><span class="line">    Unparsed []<span class="keyword">string</span> <span class="comment">// Raw text of unparsed attribute-value pairs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一个例子，如何设置cookie</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expiration := time.Now()</span><br><span class="line">expiration = expiration.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">cookie := http.Cookie&#123;Name: <span class="string">"username"</span>, Value: <span class="string">"astaxie"</span>, Expires: expiration&#125;</span><br><span class="line">http.SetCookie(w, &amp;cookie)</span><br></pre></td></tr></table></figure><h4 id="Go读取cookie"><a href="#Go读取cookie" class="headerlink" title="Go读取cookie"></a>Go读取cookie</h4><p>上面的例子演示了如何设置cookie数据，我们这里来演示一下如何读取cookie</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie, _ := r.Cookie(<span class="string">"username"</span>)</span><br><span class="line">fmt.Fprint(w, cookie)</span><br></pre></td></tr></table></figure><p>还有另外一种读取方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, cookie := <span class="keyword">range</span> r.Cookies() &#123;</span><br><span class="line">    fmt.Fprint(w, cookie.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过request获取cookie非常方便。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session，会话，其本来含义是指有始有终的一系列动作/消息，比如打电话是从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个session。然而当session一词与网络协议相关联时，它又往往隐含了“面向连接”和/或“保持状态”这样两个含义。</p><p>session在Web开发环境下的语义又有了新的扩展，它的含义是指一类用来在客户端与服务器端之间保持状态的解决方案。有时候Session也用来指这种解决方案的存储结构。</p><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。</p><p>但程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否包含了一个session标识－称为session id，如果已经包含一个session id则说明以前已经为此客户创建过session，服务器就按照session id把这个session检索出来使用(如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的session对象，但用户人为地在请求的URL后面附加上一个JSESSION的参数)。如果客户请求不包含session id，则为此客户创建一个session并且同时生成一个与此session相关联的session id，这个session id将在本次响应中返回给客户端保存。</p><p>session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>session和cookie目的相同，都是为了克服http协议无状态的缺陷，但完成的方法不同。session通过cookie，在客户端保存session id，而将用户的其他会话消息保存在服务端的session对象中，与此相对的，cookie需要将所有信息都保存在客户端。因此cookie存在着一定的安全隐患，例如本地cookie中保存的用户名密码被破译，或cookie被其他网站收集（例如：1. appA主动设置域B cookie，让域B cookie获取；2. XSS，在appA上通过javascript获取document.cookie，并传递给自己的appB）。</p><p>通过上面的一些简单介绍我们了解了cookie和session的一些基础知识，知道他们之间的联系和区别，做web开发之前，有必要将一些必要知识了解清楚，才不会在用到时捉襟见肘，或是在调bug时候如无头苍蝇乱转。接下来的几小节我们将详细介绍session相关的知识。</p><h2 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h2><h3 id="session创建过程"><a href="#session创建过程" class="headerlink" title="session创建过程"></a>session创建过程</h3><p>session的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问Web应用时，服务端程序会随需要创建session，这个过程可以概括为三个步骤：</p><ul><li>生成全局唯一标识符（sessionid）；</li><li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，当然这样会增加I/O开销，但是它可以实现某种程度的session持久化，也更有利于session的共享；</li><li>将session的全局唯一标示符发送给客户端。</li></ul><p>以上三个步骤中，最关键的是如何发送这个session的唯一标识这一步上。考虑到HTTP协议的定义，数据无非可以放到请求行、头域或Body里，所以一般来说会有两种常用的方式：cookie和URL重写。</p><ol><li>Cookie 服务端通过设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，另外一般包含session信息的cookie会将失效时间设置为0(会话cookie)，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大(一般体现在新建浏览器窗口的时候)；</li><li>URL重写 所谓URL重写，就是在返回给用户的页面里的所有的URL后面追加session标识符，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上session标识符，从而就实现了会话的保持。虽然这种做法比较麻烦，但是，如果客户端禁用了cookie的话，此种方案将会是首选。</li></ol><h3 id="Go实现session管理"><a href="#Go实现session管理" class="headerlink" title="Go实现session管理"></a>Go实现session管理</h3><p>通过上面session创建过程的讲解，读者应该对session有了一个大体的认识，但是具体到动态页面技术里面，又是怎么实现session的呢？下面我们将结合session的生命周期（lifecycle），来实现go语言版本的session管理。</p><h4 id="session管理设计"><a href="#session管理设计" class="headerlink" title="session管理设计"></a>session管理设计</h4><p>我们知道session管理涉及到如下几个因素</p><ul><li>全局session管理器</li><li>保证sessionid 的全局唯一性</li><li>为每个客户关联一个session</li><li>session 的存储(可以存储到内存、文件、数据库等)</li><li>session 过期处理</li></ul><p>接下来我将讲解一下我关于session管理的整个设计思路以及相应的go代码示例：</p><h4 id="Session管理器"><a href="#Session管理器" class="headerlink" title="Session管理器"></a>Session管理器</h4><p>定义一个全局的session管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    cookieName  <span class="keyword">string</span>     <span class="comment">//private cookiename</span></span><br><span class="line">    lock        sync.Mutex <span class="comment">// protects session</span></span><br><span class="line">    provider    Provider</span><br><span class="line">    maxlifetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(provideName, cookieName <span class="keyword">string</span>, maxlifetime <span class="keyword">int64</span>)</span> <span class="params">(*Manager, error)</span></span> &#123;</span><br><span class="line">    provider, ok := provides[provideName]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"session: unknown provide %q (forgotten import?)"</span>, provideName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Manager&#123;provider: provider, cookieName: cookieName, maxlifetime: maxlifetime&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go实现整个的流程应该也是这样的，在main包中创建一个全局的session管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"><span class="comment">//然后在init函数中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    globalSessions, _ = NewManager(<span class="string">"memory"</span>,<span class="string">"gosessionid"</span>,<span class="number">3600</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道session是保存在服务器端的数据，它可以以任何的方式存储，比如存储在内存、数据库或者文件中。因此我们抽象出一个Provider接口，用以表征session管理器底层存储结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Provider <span class="keyword">interface</span> &#123;</span><br><span class="line">    SessionInit(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">    SessionRead(sid <span class="keyword">string</span>) (Session, error)</span><br><span class="line">    SessionDestroy(sid <span class="keyword">string</span>) error</span><br><span class="line">    SessionGC(maxLifeTime <span class="keyword">int64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SessionInit函数实现Session的初始化，操作成功则返回此新的Session变量</li><li>SessionRead函数返回sid所代表的Session变量，如果不存在，那么将以sid为参数调用SessionInit函数创建并返回一个新的Session变量</li><li>SessionDestroy函数用来销毁sid对应的Session变量</li><li>SessionGC根据maxLifeTime来删除过期的数据</li></ul><p>那么Session接口需要实现什么样的功能呢？有过Web开发经验的读者知道，对Session的处理基本就 设置值、读取值、删除值以及获取当前sessionID这四个操作，所以我们的Session接口也就实现这四个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">interface</span> &#123;</span><br><span class="line">    Set(key, value <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">//set session value</span></span><br><span class="line">    Get(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//get session value</span></span><br><span class="line">    Delete(key <span class="keyword">interface</span>&#123;&#125;) error     <span class="comment">//delete session value</span></span><br><span class="line">    SessionID() <span class="keyword">string</span>                <span class="comment">//back current sessionID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上设计思路来源于database/sql/driver，先定义好接口，然后具体的存储session的结构实现相应的接口并注册后，相应功能这样就可以使用了，以下是用来随需注册存储session的结构的Register函数的实现。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> provides = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Provider)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register makes a session provide available by the provided name.</span></span><br><span class="line"><span class="comment">// If Register is called twice with the same name or if driver is nil,</span></span><br><span class="line"><span class="comment">// it panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, provider Provider)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> provider == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"session: Register provide is nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, dup := provides[name]; dup &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"session: Register called twice for provide "</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">    provides[name] = provider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局唯一的Session-ID"><a href="#全局唯一的Session-ID" class="headerlink" title="全局唯一的Session ID"></a>全局唯一的Session ID</h4><p>Session ID是用来识别访问Web应用的每一个用户，因此必须保证它是全局唯一的（GUID），下面代码展示了如何满足这一需求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">sessionId</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="session创建"><a href="#session创建" class="headerlink" title="session创建"></a>session创建</h4><p>我们需要为每个来访用户分配或获取与他相关连的Session，以便后面根据Session信息来验证操作。SessionStart这个函数就是用来检测是否已经有某个Session与当前来访用户发生了关联，如果没有则创建之。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionStart</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="params">(session Session)</span></span> &#123;</span><br><span class="line">    manager.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">""</span> &#123;</span><br><span class="line">        sid := manager.sessionId()</span><br><span class="line">        session, _ = manager.provider.SessionInit(sid)</span><br><span class="line">        cookie := http.Cookie&#123;Name: manager.cookieName, Value: url.QueryEscape(sid), Path: <span class="string">"/"</span>, HttpOnly: <span class="literal">true</span>, MaxAge: <span class="keyword">int</span>(manager.maxlifetime)&#125;</span><br><span class="line">        http.SetCookie(w, &amp;cookie)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class="line">        session, _ = manager.provider.SessionRead(sid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用前面login操作来演示session的运用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    sess := globalSessions.SessionStart(w, r)</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        t.Execute(w, sess.Get(<span class="string">"username"</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"username"</span>, r.Form[<span class="string">"username"</span>])</span><br><span class="line">        http.Redirect(w, r, <span class="string">"/"</span>, <span class="number">302</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作值：设置、读取和删除"><a href="#操作值：设置、读取和删除" class="headerlink" title="操作值：设置、读取和删除"></a>操作值：设置、读取和删除</h4><p>SessionStart函数返回的是一个满足Session接口的变量，那么我们该如何用他来对session数据进行操作呢？</p><p>上面的例子中的代码<code>session.Get(&quot;uid&quot;)</code>已经展示了基本的读取数据的操作，现在我们再来看一下详细的操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    sess := globalSessions.SessionStart(w, r)</span><br><span class="line">    createtime := sess.Get(<span class="string">"createtime"</span>)</span><br><span class="line">    <span class="keyword">if</span> createtime == <span class="literal">nil</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"createtime"</span>, time.Now().Unix())</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (createtime.(<span class="keyword">int64</span>) + <span class="number">360</span>) &lt; (time.Now().Unix()) &#123;</span><br><span class="line">        globalSessions.SessionDestroy(w, r)</span><br><span class="line">        sess = globalSessions.SessionStart(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">    ct := sess.Get(<span class="string">"countnum"</span>)</span><br><span class="line">    <span class="keyword">if</span> ct == <span class="literal">nil</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, (ct.(<span class="keyword">int</span>) + <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := template.ParseFiles(<span class="string">"count.gtpl"</span>)</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    t.Execute(w, sess.Get(<span class="string">"countnum"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看到，Session的操作和操作key/value数据库类似:Set、Get、Delete等操作</p><p>因为Session有过期的概念，所以我们定义了GC操作，当访问过期时间满足GC的触发条件后将会引起GC，但是当我们进行了任意一个session操作，都会对Session实体进行更新，都会触发对最后访问时间的修改，这样当GC的时候就不会误删除还在使用的Session实体。</p><h4 id="session重置"><a href="#session重置" class="headerlink" title="session重置"></a>session重置</h4><p>我们知道，Web应用中有用户退出这个操作，那么当用户退出应用的时候，我们需要对该用户的session数据进行销毁操作，上面的代码已经演示了如何使用session重置操作，下面这个函数就是实现了这个功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Destroy sessionid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">SessionDestroy</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.lock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">        manager.provider.SessionDestroy(cookie.Value)</span><br><span class="line">        expiration := time.Now()</span><br><span class="line">        cookie := http.Cookie&#123;Name: manager.cookieName, Path: <span class="string">"/"</span>, HttpOnly: <span class="literal">true</span>, Expires: expiration, MaxAge: <span class="number">-1</span>&#125;</span><br><span class="line">        http.SetCookie(w, &amp;cookie)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="session销毁"><a href="#session销毁" class="headerlink" title="session销毁"></a>session销毁</h4><p>我们来看一下Session管理器如何来管理销毁,只要我们在Main启动的时候启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    manager.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> manager.lock.Unlock()</span><br><span class="line">    manager.provider.SessionGC(manager.maxlifetime)</span><br><span class="line">    time.AfterFunc(time.Duration(manager.maxlifetime), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; manager.GC() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到GC充分利用了time包中的定时器功能，当超时<code>maxLifeTime</code>之后调用GC函数，这样就可以保证<code>maxLifeTime</code>时间内的session都是可用的，类似的方案也可以用于统计在线用户数之类的。</p><h2 id="存储session"><a href="#存储session" class="headerlink" title="存储session"></a>存储session</h2><p>上一节我们介绍了Session管理器的实现原理，定义了存储session的接口，这小节我们将示例一个基于内存的session存储接口的实现，其他的存储方式，读者可以自行参考示例来实现，内存的实现请看下面的例子代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/session"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pder = &amp;Provider&#123;list: list.New()&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SessionStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    sid          <span class="keyword">string</span>                      <span class="comment">//session id唯一标示</span></span><br><span class="line">    timeAccessed time.Time                   <span class="comment">//最后访问时间</span></span><br><span class="line">    value        <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">//session里面存储的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    st.value[key] = value</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(st.value, key)</span><br><span class="line">    pder.SessionUpdate(st.sid)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *SessionStore)</span> <span class="title">SessionID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> st.sid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock     sync.Mutex               <span class="comment">//用来锁</span></span><br><span class="line">    sessions <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element <span class="comment">//用来存储在内存</span></span><br><span class="line">    list     *list.List               <span class="comment">//用来做gc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionInit</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line">    v := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    newsess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class="line">    element := pder.list.PushBack(newsess)</span><br><span class="line">    pder.sessions[sid] = element</span><br><span class="line">    <span class="keyword">return</span> newsess, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionRead</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="params">(session.Session, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> element.Value.(*SessionStore), <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess, err := pder.SessionInit(sid)</span><br><span class="line">        <span class="keyword">return</span> sess, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionDestroy</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pder.sessions, sid)</span><br><span class="line">        pder.list.Remove(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionGC</span><span class="params">(maxlifetime <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        element := pder.list.Back()</span><br><span class="line">        <span class="keyword">if</span> element == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (element.Value.(*SessionStore).timeAccessed.Unix() + maxlifetime) &lt; time.Now().Unix() &#123;</span><br><span class="line">            pder.list.Remove(element)</span><br><span class="line">            <span class="built_in">delete</span>(pder.sessions, element.Value.(*SessionStore).sid)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pder *Provider)</span> <span class="title">SessionUpdate</span><span class="params">(sid <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    pder.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pder.lock.Unlock()</span><br><span class="line">    <span class="keyword">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class="line">        element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class="line">        pder.list.MoveToFront(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pder.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element, <span class="number">0</span>)</span><br><span class="line">    session.Register(<span class="string">"memory"</span>, pder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码实现了一个内存存储的session机制。通过init函数注册到session管理器中。这样就可以方便的调用了。我们如何来调用该引擎呢？请看下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/astaxie/session"</span></span><br><span class="line">    _ <span class="string">"github.com/astaxie/session/providers/memory"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当import的时候已经执行了memory函数里面的init函数，这样就已经注册到session管理器中，我们就可以使用了，通过如下方式就可以初始化一个session管理器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalSessions *session.Manager</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在init函数中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    globalSessions, _ = session.NewManager(<span class="string">"memory"</span>, <span class="string">"gosessionid"</span>, <span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">go</span> globalSessions.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预防session劫持"><a href="#预防session劫持" class="headerlink" title="预防session劫持"></a>预防session劫持</h2><p>session劫持是一种广泛存在的比较严重的安全威胁，在session技术中，客户端和服务端通过session的标识符来维护会话， 但这个标识符很容易就能被嗅探到，从而被其他人利用。它是中间人攻击的一种类型。</p><p>本节将通过一个实例来演示会话劫持，希望通过这个实例，能让读者更好地理解session的本质。</p><h3 id="session劫持过程"><a href="#session劫持过程" class="headerlink" title="session劫持过程"></a>session劫持过程</h3><p>我们写了如下的代码来展示一个count计数器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    sess := globalSessions.SessionStart(w, r)</span><br><span class="line">    ct := sess.Get(<span class="string">"countnum"</span>)</span><br><span class="line">    <span class="keyword">if</span> ct == <span class="literal">nil</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sess.Set(<span class="string">"countnum"</span>, (ct.(<span class="keyword">int</span>) + <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := template.ParseFiles(<span class="string">"count.gtpl"</span>)</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    t.Execute(w, sess.Get(<span class="string">"countnum"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count.gtpl的代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi. Now count:&#123;&#123;.&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后我们在浏览器里面刷新可以看到如下内容：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/6.4.hijack.png?raw=true" alt="img"></p><p>随着刷新，数字将不断增长，当数字显示为6的时候，打开浏览器(以chrome为例）的cookie管理器，可以看到类似如下的信息：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/6.4.cookie.png?raw=true" alt="img"></p><p>下面这个步骤最为关键: 打开另一个浏览器(这里我打开了firefox浏览器),复制chrome地址栏里的地址到新打开的浏览器的地址栏中。然后打开firefox的cookie模拟插件，新建一个cookie，把按上图中cookie内容原样在firefox中重建一份:</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/6.4.setcookie.png?raw=true" alt="img"></p><p>回车后，你将看到如下内容：</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/6.4.hijacksuccess.png?raw=true" alt="img"></p><p>可以看到虽然换了浏览器，但是我们却获得了sessionID，然后模拟了cookie存储的过程。这个例子是在同一台计算机上做的，不过即使换用两台来做，其结果仍然一样。此时如果交替点击两个浏览器里的链接你会发现它们其实操纵的是同一个计数器。不必惊讶，此处firefox盗用了chrome和goserver之间的维持会话的钥匙，即gosessionid，这是一种类型的“会话劫持”。在goserver看来，它从http请求中得到了一个gosessionid，由于HTTP协议的无状态性，它无法得知这个gosessionid是从chrome那里“劫持”来的，它依然会去查找对应的session，并执行相关计算。与此同时 chrome也无法得知自己保持的会话已经被“劫持”。</p><h3 id="session劫持防范"><a href="#session劫持防范" class="headerlink" title="session劫持防范"></a>session劫持防范</h3><h4 id="cookieonly和token"><a href="#cookieonly和token" class="headerlink" title="cookieonly和token"></a>cookieonly和token</h4><p>通过上面session劫持的简单演示可以了解到session一旦被其他人劫持，就非常危险，劫持者可以假装成被劫持者进行很多非法操作。那么如何有效的防止session劫持呢？</p><p>其中一个解决方案就是sessionID的值只允许cookie设置，而不是通过URL重置方式设置，同时设置cookie的httponly为true,这个属性是设置是否可通过客户端脚本访问这个设置的cookie，第一这个可以防止这个cookie被XSS读取从而引起session劫持，第二cookie设置不会像URL重置方式那么容易获取sessionID。</p><p>第二步就是在每个请求里面加上token，实现类似前面章节里面讲的防止form重复递交类似的功能，我们在每个请求里面加上一个隐藏的token，然后每次验证这个token，从而保证用户的请求都是唯一性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h := md5.New()</span><br><span class="line">salt:=<span class="string">"astaxie%^7&amp;8888"</span></span><br><span class="line">io.WriteString(h,salt+time.Now().String())</span><br><span class="line">token:=fmt.Sprintf(<span class="string">"%x"</span>,h.Sum(<span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">if</span> r.Form[<span class="string">"token"</span>]!=token&#123;</span><br><span class="line">    <span class="comment">//提示登录</span></span><br><span class="line">&#125;</span><br><span class="line">sess.Set(<span class="string">"token"</span>,token)</span><br></pre></td></tr></table></figure><h4 id="间隔生成新的SID"><a href="#间隔生成新的SID" class="headerlink" title="间隔生成新的SID"></a>间隔生成新的SID</h4><p>还有一个解决方案就是，我们给session额外设置一个创建时间的值，一旦过了一定的时间，我们销毁这个sessionID，重新生成新的session，这样可以一定程度上防止session劫持的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createtime := sess.Get(<span class="string">"createtime"</span>)</span><br><span class="line"><span class="keyword">if</span> createtime == <span class="literal">nil</span> &#123;</span><br><span class="line">    sess.Set(<span class="string">"createtime"</span>, time.Now().Unix())</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (createtime.(<span class="keyword">int64</span>) + <span class="number">60</span>) &lt; (time.Now().Unix()) &#123;</span><br><span class="line">    globalSessions.SessionDestroy(w, r)</span><br><span class="line">    sess = globalSessions.SessionStart(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>session启动后，我们设置了一个值，用于记录生成sessionID的时间。通过判断每次请求是否过期(这里设置了60秒)定期生成新的ID，这样使得攻击者获取有效sessionID的机会大大降低。</p><p>上面两个手段的组合可以在实践中消除session劫持的风险，一方面， 由于sessionID频繁改变，使攻击者难有机会获取有效的sessionID；另一方面，因为sessionID只能在cookie中传递，然后设置了httponly，所以基于URL攻击的可能性为零，同时被XSS获取sessionID也不可能。最后，由于我们还设置了MaxAge=0，这样就相当于session cookie不会留在浏览器的历史记录里面。</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC是远程过程调用Remote procedure call的简称，可以使运行远程代码就像本机代码一样而不用考虑通信编程以及开销。是分布式系统中不同节点间流行的通信方式，Go语言的标准库也提供了一个简单的RPC实现。</p><h2 id="net-rpc"><a href="#net-rpc" class="headerlink" title="net/rpc"></a>net/rpc</h2><p>Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>我们先构造一个HelloService类型，其中的Hello方法用于实现打印功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    *reply = <span class="string">"hello:"</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Hello方法必须满足<strong>Go语言的RPC规则</strong>：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法。</p><p>然后就可以将HelloService类型的对象注册为一个RPC服务，其中rpc.Register函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在“HelloService”服务空间之下。然后我们建立一个唯一的TCP链接，并且通过rpc.ServeConn函数在该TCP链接上为对方提供RPC服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端请求HelloService服务的代码，首先是通过rpc.Dial拨号RPC服务，然后通过client.Call调用具体的RPC方法。在调用client.Call时，第一个参数是用点号链接的RPC服务名字和方法名字，第二和第三个参数分别我们定义RPC方法的两个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由这个例子可以看出RPC的使用其实非常简单。</p><h3 id="Arith"><a href="#Arith" class="headerlink" title="Arith"></a>Arith</h3><p>这是go官网所给出的一个例子，A server wishes to export an object of type Arith:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">A, B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(args *Args, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">*reply = args.A * args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Divide</span><span class="params">(args *Args, quo *Quotient)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The server calls (for HTTP service):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">rpc.Register(arith)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>At this point, clients can see a service “Arith” with methods “Arith.Multiply” and “Arith.Divide”. To invoke one, a client first dials the server:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, serverAddress + <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then it can make a remote call:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronous call</span></span><br><span class="line">args := &amp;server.Args&#123;<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span></span><br><span class="line">err = client.Call(<span class="string">"Arith.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Arith: %d*%d=%d"</span>, args.A, args.B, reply)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asynchronous call</span></span><br><span class="line">quotient := <span class="built_in">new</span>(Quotient)</span><br><span class="line">divCall := client.Go(<span class="string">"Arith.Divide"</span>, args, quotient, <span class="literal">nil</span>)</span><br><span class="line">replyCall := &lt;-divCall.Done<span class="comment">// will be equal to divCall</span></span><br><span class="line"><span class="comment">// check errors, print, etc.</span></span><br></pre></td></tr></table></figure><p>这里暂时只做简单介绍（毕竟只是为了写MIT6.824的Labs）更多详情可以见官方文档 <a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="noopener">https://golang.org/pkg/net/rpc/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go日记的Web篇外传正式开张了，可喜可贺、可喜可贺！&lt;/p&gt;
&lt;p&gt;这篇简单介绍下Go的Web基础，有计网知识或者写过前后端应该会很好上手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://stardust567.github.io/categories/Go/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Go" scheme="https://stardust567.github.io/tags/Go/"/>
    
      <category term="Web" scheme="https://stardust567.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Go日记</title>
    <link href="https://stardust567.github.io/post/2766.html"/>
    <id>https://stardust567.github.io/post/2766.html</id>
    <published>2019-11-26T01:11:49.000Z</published>
    <updated>2020-02-06T01:16:52.106Z</updated>
    
    <content type="html"><![CDATA[<p> 记录下休学期间学习Go语言入门的一些想法、笔记和踩过的一些坑。</p><p>希望之后这个Go系列还会继续完善下去不被弃坑（小声）</p><a id="more"></a><h1 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h1><p>因为一些奇怪的原因我分别在Windows和Linux子系统上安装了Go。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">下载地址</a> 笔者现安装的版本是<code>go version go1.13.4 windows/amd64</code></p><p>安装完成后默认会在环境变量 Path 后添加 Go 安装目录下的 bin 目录 <code>C:\Go\bin\</code>，并添加环境变量 GOROOT，值为 Go 安装根目录 <code>C:\Go\</code>因为笔者电脑内存不够就放在了D盘，于是修改一通环境变量，最主要就是GOROOT目录下存在go.exe<del>以及你的代码放置区域要存在GOPATH里</del>（GOPATH在go提出GO MOD之后就没那么重要了)。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><em>强烈建议不要直接apt install而是去官网下载最新的版本手动安装</em></p><p>因为之前C++课程使用的VSCode接WSL确实用得舒服一点，就直接在WSL环境下ubuntu使用Go<br>第一次apt直接安装<code>sudo apt install golang-go</code>版本为<code>go version go1.10.4 linux/amd64</code>然后笔者觉得还是统一下会比较好一点（强迫症）于是去官网下了Linux的1.13版本解压在本地安装，然后因为卑微的C盘，于是把go文件夹放在了D盘，由于之Windows版本的Go放在D盘就给Linux版本文件夹重命名了一下，修改PATH：<br><code>export GOPATH=/mnt/e/Program/Go</code><br><code>export GOROOT=/mnt/d/Go_linux</code><br><code>export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code><br><code>source /etc/profile</code></p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>至此理论上就能跑了，不放心可以用<code>go version</code>检查版本<code>go env</code>检查环境变量。</p><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><p>用hello world信仰开头：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello, world 你好，世界 καλημ ́ρα κóσμ こんにちはせかい\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package &lt;pkgName&gt;</code>表明当前文件属于哪个包，包名<strong>main</strong>表明它是一个可独立运行的包，编译后会产生可执行文件。除了main包之外，其它的包最后都会生成<strong>*.a</strong>文件（包文件）并放置在<code>$GOPATH/pkg/$GOOS_$GOARCH</code>中。<br>每个可独立运行的Go程序，必定包含一个<code>package main</code>其中必含一个无参无return的入口函数<strong>main</strong>。</p><p>Go使用UTF-8字符串和标识符。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用<code>var</code>关键字是Go最基本的定义变量方式，Go把变量类型放在变量名后面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br><span class="line"><span class="comment">//定义三个变量，分别初始化相应值，编译器会根据初始化值自动推导相应类型</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    :=这个符号直接取代了var和type，但只能用在函数内部</span></span><br><span class="line"><span class="comment">    定义全局变量一般还是猜用var方式来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><p><code>_</code>是个特殊的变量名，任何赋予它的值都会被丢弃。eg.我们将值35赋予b，并同时丢弃34：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := 34, 35</span><br></pre></td></tr></table></figure><p><strong>Go对于已声明但未使用的变量会在编译阶段报错</strong>，eg.声明了<code>i</code>但未使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="keyword">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure><p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit，详情参考<a href="http://golang.org/ref/spec#Constants" target="_blank" rel="noopener">链接</a></p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Go中，布尔值的类型为bool，值是true或false，默认为false。</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="keyword">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="keyword">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>Go同时支持<code>int</code>和<code>uint</code>，两种类型长度相同，但具体长度取决于编译器的实现。<br>Go里面也有直接定义好位数的类型：<code>int8</code>, <code>int16</code>, <code>int32(rune)</code>, <code>int64</code>和<code>uint8(byte)</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。<br><strong>不同类型的变量之间不允许互相赋值或操作！</strong></p><p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p><p>复数默认类型是<code>complex128</code>（64位实数+64位虚数）也有<code>complex64</code>(32位实数+32位虚数)<br>复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go中的字符串都是采用UTF-8字符集编码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="keyword">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="keyword">string</span> = <span class="string">""</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">"no"</span>, <span class="string">"yes"</span>, <span class="string">"maybe"</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    frenchHello = <span class="string">"Bonjour"</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go中字符串不能当初char数组修改，例如下面的代码编译时会报错：cannot assign to s[0]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"hello"</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'c'</span></span><br></pre></td></tr></table></figure><p>真的需要修改，要将字符串 s 转换为 []byte 类型，修改后再转回 string 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s2)</span><br></pre></td></tr></table></figure><p>Go中可以使用<code>+</code>操作符来连接两个字符串<br>所以字符串虽不能更改，但可进行切片操作，故修改字符串也可写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">s = <span class="string">"c"</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br></pre></td></tr></table></figure><p>如果要声明一个多行的字符串怎么办？可以通过<code>` </code>来声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure><p><code>` </code> 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure><h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"emit macho dwarf: elf header corrupted"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">"Go_"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    pi <span class="keyword">float32</span></span><br><span class="line">    prefix <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><ul><li><strong>大写</strong>字母开头的变量是可导出的，也就是其它包可以读取的，是<strong>公有</strong>变量；</li><li><strong>小写</strong>字母开头的就是不可导出的，是<strong>私有</strong>变量。</li><li>大写字母开头的函数相当于<code>class</code>中的带<code>public</code>关键词的公有函数；</li><li>小写字母开头的函数相当于<code>private</code>关键词的私有函数。</li></ul><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="keyword">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">fmt.Printf(<span class="string">"The first one is %d\n"</span>, arr[<span class="number">0</span>])  <span class="comment">// 返回42</span></span><br><span class="line">fmt.Printf(<span class="string">"The last one is %d\n"</span>, arr[<span class="number">9</span>]) <span class="comment">// 未赋值默认返回0</span></span><br></pre></td></tr></table></figure><p>数组间的赋值是<strong>值的赋值</strong>，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 简短声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 简短声明，前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 采用`...`的方式Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;[<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>初始定义数组时并不知道数组长度，在Go里面这种数据结构叫slice。<br>slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fslice []<span class="keyword">int</span></span><br><span class="line">slice := []<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="keyword">byte</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>] <span class="comment">// a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>] <span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure><p>array方括号内写明数组长度或使用<code>...</code>自动计算长度，声明slice时，<strong>方括号内没有任何字符</strong>。</p><ul><li>slice的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></li><li>slice的默认结束位置是数组长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></li><li>如果从一个数组里面直接获取slice，可以这样<code>ar[:]</code>等价于<code>ar[0:len(ar)]</code></li></ul><p>slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值。</p><p>slice内置函数：</p><ul><li><code>len</code> 获取slice的长度</li><li><code>cap</code> 获取slice的最大容量</li><li><code>append</code> 向slice里追加一或多个元素，然后返回一个和修改后slice一样类型的slice</li><li><code>copy</code> 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li></ul><p>但当slice中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">// slice的容量10-2，即8</span></span><br><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>] <span class="comment">// 第三个参数可以指定容量</span></span><br><span class="line"><span class="comment">// 容量为7-2，即5。这样新的slice就没办法访问array最后三个元素</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map也就是Python中字典的概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">numbers[<span class="string">"one"</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"ten"</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">"第三个数字是: "</span>, numbers[<span class="string">"three"</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure><p>使用map过程中需要注意的几点：</p><ul><li>map无序，每次打印出的map会不一样，它不能通过index获取，而必须通过key获取</li><li>map长度不固定，和slice一样是引用类型，如果两个map同时指向一个底层，一个改变，另一个也相应改变</li><li>内置的<code>len</code>函数同样适用于map，返回map拥有的key的数量</li><li>map的值很方便修改，通过<code>numbers[&quot;one&quot;]=11</code>可以把key为one的字典值改为11</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用<strong>mutex lock</strong>机制</li></ul><p>map的初始化可以通过<code>key:val</code>的方式初始化值，同时map内置有判断是否存在<code>key</code>的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rating := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float32</span>&#123;<span class="string">"C"</span>:<span class="number">5</span>, <span class="string">"Go"</span>:<span class="number">4.5</span>, <span class="string">"Python"</span>:<span class="number">4.5</span>, <span class="string">"C++"</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">"C#"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"C# is in the map and its rating is "</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"We have no rating associated with C# in the map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">"C"</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure><h3 id="make、new操作（TODO）"><a href="#make、new操作（TODO）" class="headerlink" title="make、new操作（TODO）"></a>make、new操作（TODO）</h3><p>内建函数new和make是两个用于内存分配的原语，简单说new只分配内存，make用于slice，map，和channel的初始化。在Go语言中，如果一个局部变量在函数返回后仍然被使用，这个变量会从heap，而不是stack中分配内存。内建函数make(T, args)与new(T)的用途不一样。它只用来创建slice，map和channel，并且返回一个初始化的(而不是置零)，类型为T的值（而不是*T）。之所以有所不同，是因为这三个类型的背后引用了使用前必须初始化的数据结构。例如，slice是一个三元描述符，包含一个指向数据（在数组中）的指针，长度，以及容量，在这些项被初始化之前，slice都是nil的。对于slice，map和channel，make初始化这些内部数据结构，并准备好可用的值。记住make只用于map，slice和channel，并且不返回指针。要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is greater than 10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is less than 10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句里允许声明一个变量，变量作用域只能在该条件逻辑块内，有点类似python的<code>for i in range(100):</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x == <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is equal to 10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is greater than 10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is less than 10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"sum is equal to "</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure><p>有时我们可以省略一点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至更省略一点，看起来就像个while，配合continue和break用风味更佳</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据（真的很像python啊）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"map's key:"</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">"map's val:"</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 对于“声明而未被调用”的变量, 编译器会报错, 于是用<code>_</code>来丢弃不需要的返回值 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"map's val:"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"i is equal to 1"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">"i is equal to 2, 3 or 4"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">"i is equal to 10"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"All I know is that i is an integer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以在case最后加上<code>fallthrough</code>强制执行后面的case代码。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span> <span class="params">(output1 type1, output2 type2)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来个实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d + %d = %d\n"</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">"%d * %d = %d\n"</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，函数的声明还可以更人性化，可读性更强一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(add <span class="keyword">int</span>, Multiplied <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。<br>在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"And the number is: %d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>当传参到函数里时，实际是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上，而想直接传这个值本身就需要用到指针。</p><p>变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以我们需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">"x = "</span>, x)  <span class="comment">// 应该输出 "x = 3"</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">"x+1 = "</span>, x1) <span class="comment">// 应该输出 "x+1 = 4"</span></span><br><span class="line">    fmt.Println(<span class="string">"x = "</span>, x)    <span class="comment">// 应该输出 "x = 4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p><ul><li>传指针使得多个函数能操作同一个对象。</li><li>传指针比较轻量级 (8bytes)只传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上就会花费相对较多的系统开销（内存和时间）。所以当传递大结构体的时候，用指针是一个明智的选择。</li><li>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。<strong>（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</strong></li></ul><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go支持延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照<strong>逆序</strong>执行，最后该函数返回。</p><p>在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    file.Open(<span class="string">"file"</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用<code>defer</code>则会显得优雅很多，在<code>defer</code>后指定的函数会在函数退出前调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    file.Open(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i) <span class="comment">// 4 3 2 1 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，我们可以通过<code>type</code>来定义它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 type1, input2 type2 [, ...])</span> <span class="params">(result1 type1 [, ...])</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span> // 声明了一个函数类型</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="keyword">int</span>, f testInt)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"slice = "</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">"Odd elements of slice are: "</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">"Even elements of slice are: "</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数当做值和类型在写一些通用接口的时候非常有用，程序灵活性也会大大增加。</p><h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，而是使用了<code>panic</code>和<code>recover</code>机制。BUT<strong>代码中应当没有，或很少有<code>panic</code></strong>。</p><p>Panic</p><blockquote><p>是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。恐慌可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p></blockquote><p>Recover</p><blockquote><p>是一个内建的函数，可以让进入令人恐慌的流程中的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入恐慌，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p></blockquote><p>下面这个函数演示了如何在过程中使用<code>panic</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"no value for $USER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span>) <span class="params">(b <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go有两个保留的函数：<code>init</code>函数（能用于所有<code>package</code>）和<code>main</code>函数（只用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，都强烈建议在一个<code>package</code>中<strong>每个文件只写一个<code>init</code>函数</strong>。</p><p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以你不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p><p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那会在编译时将它们依次导入。若一个包被多个包同时导入，那它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次）。当一个包被导入时，如果该包还导入了其它的包，那会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话）依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话）最后执行<code>main</code>函数。</p><p><img src="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/images/2.3.init.png?raw=true" alt="main函数引入包初始化流程图"></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>用import命令来导入包文件，而我们经常看到的方式参考如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后我们代码里面可以通过如下的方式调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持用相对路径或者绝对路径来加载自己写的模块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> “./model” <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br><span class="line"><span class="keyword">import</span> “shorturl/model” <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure><p>上面展示了一些import常用的几种方式，但是还有一些特殊的import</p><ol><li><p>点操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">       . &quot;fmt&quot;</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></li></ol><p>   表示这个包导入之后，在调用这个包的函数时，可以省略前缀的包名，即调用<code>fmt.Println(&quot;hello world&quot;)</code>可以直接写成<code>Println(&quot;hello world&quot;)</code></p><ol><li><p>别名操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">       f &quot;fmt&quot;</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></li></ol><p>   顾名思义，调用包函数时前缀变成了我们的前缀，即<code>f.Println(&quot;hello world&quot;)</code></p><ol><li><p>_操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">       <span class="string">"database/sql"</span></span><br><span class="line">       _ <span class="string">"github.com/ziutek/mymysql/godrv"</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure></li></ol><p>   _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line"></span><br><span class="line">P.name = <span class="string">"Astaxie"</span>  <span class="comment">// 赋值"Astaxie"给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值"25"给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">"The person's name is %s"</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure><p>   除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p><ul><li><p>1.按照顺序提供初始化值</p><p>P := person{“Tom”, 25}</p></li><li><p>2.通过<code>field:value</code>的方式初始化，这样可以任意顺序</p><p>P := person{age:24, name:”Tom”}</p></li><li><p>3.当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为*person</p><p>P := new(person)</p></li></ul><h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a>struct的匿名字段</h2><p>   Go支持只提供类型，而不写字段名的方式，也就是<em>匿名字段</em>，也称为<em>嵌入字段</em>。</p><p>   当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">"Computer Science"</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">"His name is "</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">"His speciality is "</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">"AI"</span></span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">"His weight is"</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名字段就是这样，能够实现字段的继承。</strong></p><p>同时student还能访问Human这个字段作为字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">"Marcus"</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>所有的内置类型和自定义类型都是可以作为匿名字段。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="keyword">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">"Jane"</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">"Biology"</span>&#125;</span><br><span class="line">    <span class="comment">// 修改自定义类型skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="keyword">string</span>&#123;<span class="string">"anatomy"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"Her skills are "</span>, jane.Skills)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">"physics"</span>, <span class="string">"golang"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Her skills now are "</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">"Her preferred number is"</span>, jane.<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这种类似于继承的方式，真的非常人性化了。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>函数的另一种形态，带有接收者的函数，我们称为<code>method</code></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用Rob Pike的话来说就是：</p><blockquote><p>“A method is a function with an implicit first argument, called a receiver.”</p></blockquote><p>method的语法如下，注意不要和function弄混哦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (r ReceiverType) funcName(parameters) (results)</span><br></pre></td></tr></table></figure><p>下面我们用最开始的例子用method来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    c := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Area of r is: "</span>, r.area())</span><br><span class="line">    fmt.Println(<span class="string">"Area of c is: "</span>, c.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用method的时候重要注意几点</p><ul><li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li><li>method里面可以访问接收者的字段</li><li>调用method通过<code>.</code>访问，就像struct里面访问字段一样</li></ul><p>除了结构体这一比较特殊的自定义类型外，还可以在任意自定义类型中定义任意多的<code>method</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span></span><br><span class="line">    BLACK</span><br><span class="line">    BLUE</span><br><span class="line">    RED</span><br><span class="line">    YELLOW</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="keyword">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span> <span class="title">Volume</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">SetColor</span><span class="params">(c Color)</span></span> &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span> <span class="title">BiggestColor</span><span class="params">()</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span> <span class="title">PaintItBlack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strings := []<span class="keyword">string</span> &#123;<span class="string">"WHITE"</span>, <span class="string">"BLACK"</span>, <span class="string">"BLUE"</span>, <span class="string">"RED"</span>, <span class="string">"YELLOW"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"We have %d boxes in our set\n"</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">"The volume of the first one is"</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">"cm³"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The color of the last one is"</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">"The biggest one is"</span>, boxes.BiggestColor().String())</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Let's paint them all black"</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">"The color of the second one is"</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Obviously, now, the biggest one is"</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h3><p><code>SetColor</code>这个method，它的receiver是一个指向Box的指针，这不难理解。</p><p><em>Q:</em> 那<code>SetColor</code>函数里应该是<code>*b.Color=c</code>,而不是<code>b.Color=c</code>才对啊,因为需要读取到指针相应的值。</p><p><em>A:</em> 其实Go里面这两种方式都ok，当你用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值，多人性化。</p><p><em>Q:</em> 那<code>PaintItBlack</code>里面调用<code>SetColor</code>不应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>吗，因为<code>SetColor</code>的receiver是*Box，而不是Box。</p><p><em>A:</em> Yep，但这两种方式都可以，因为Go知道receiver是指针，就自动帮你转了。</p><p>也就是说：</p><blockquote><p>如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p></blockquote><p>类似的</p><blockquote><p>如果一个method的receiver是T，你可以在一个<em>T类型的变量P上面调用这个method，而不需要</em> P去调用这个method</p></blockquote><h3 id="method继承-amp-重写"><a href="#method继承-amp-重写" class="headerlink" title="method继承&amp;重写"></a>method继承&amp;重写</h3><p>如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method包括重写这个method。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line"></span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些内容，我们可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p><h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。<br>interface定义了一组方法，如果某个对象实现了某个接口的<strong>所有</strong>方法，则此对象实现了此接口。<br>interface可以被任意的对象实现，一个对象可以实现任意多个interface。</p><h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>一个interface变量可以存实现这个interface的任意类型的对象。</p><p>例如定义了一个Men interface类型的变量m，那么m可以存Human、Student或者Employee值。<br>因为m能够持有这三种类型的对象，那我们可以定义一个Men类型的slice<code>x := make([]Men, 3)</code>，这个slice可以被赋予实现了Men接口的任意结构的对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">"Mike"</span>, <span class="number">25</span>, <span class="string">"222-222-XXX"</span>&#125;, <span class="string">"MIT"</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">"Paul"</span>, <span class="number">26</span>, <span class="string">"111-222-XXX"</span>&#125;, <span class="string">"Harvard"</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">36</span>, <span class="string">"444-222-XXX"</span>&#125;, <span class="string">"Golang Inc."</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">"Tom"</span>, <span class="number">37</span>, <span class="string">"222-444-XXX"</span>&#125;, <span class="string">"Things Ltd."</span>, <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">"This is Mike, a Student:"</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">"November rain"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">"This is tom, an Employee:"</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">"Born to be wild"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">"Let's use a slice of Men and see what happens"</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface就是一组抽象方法的集合，必须由其他非interface类型实现，而不能自我实现。</p><h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。</p><p>空interface可以存储任意类型的数值，有点类似于C语言的void*类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">"Hello world"</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数；<br>如果一个函数返回interface{}，那么也就可以返回任意类型的值。</p><h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，那是不是可以通过定义interface参数，让函数接受各种类型的参数。比如<code>fmt.Println</code>可以接受任意类型的数据，即任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"❰"</span>+h.name+<span class="string">" - "</span>+strconv.Itoa(h.age)+<span class="string">" years -  ✆ "</span> +h.phone+<span class="string">"❱"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">"Bob"</span>, <span class="number">39</span>, <span class="string">"000-7777-XXX"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"This Human is : "</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>method：String实现了<code>fmt.Stringer</code>这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现Stringer接口。如果没有实现这个接口，fmt将以默认的方式输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">"The biggest one is"</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">"The biggest one is"</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure><p><em>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</em></p><h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>我们知道interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p><ul><li><p>Comma-ok断言</p><p>直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p><p>如果element里面确实存储了T类型的数值，ok返回true，否则返回false（但这样一般会引入大量if-else）</p></li><li><p>switch测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> (</span><br><span class="line">      <span class="string">"fmt"</span></span><br><span class="line">      <span class="string">"strconv"</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">type</span> List [] Element</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">      name <span class="keyword">string</span></span><br><span class="line">      age <span class="keyword">int</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"(name: "</span> + p.name + <span class="string">" - age: "</span>+strconv.Itoa(p.age)+ <span class="string">" years)"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">      list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">      list[<span class="number">1</span>] = <span class="string">"Hello"</span> <span class="comment">//a string</span></span><br><span class="line">      list[<span class="number">2</span>] = Person&#123;<span class="string">"Dennis"</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">          <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">                  fmt.Printf(<span class="string">"list[%d] is an int and its value is %d\n"</span>, index, value)</span><br><span class="line">              <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">                  fmt.Printf(<span class="string">"list[%d] is a string and its value is %s\n"</span>, index, value)</span><br><span class="line">              <span class="keyword">case</span> Person:</span><br><span class="line">                  fmt.Printf(<span class="string">"list[%d] is a Person and its value is %s\n"</span>, index, value)</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  fmt.Println(<span class="string">"list[%d] is of a different type"</span>, index)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong><code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</strong></p><h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像我们在学习Struct时学习的匿名字段。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p><p>源码包container/heap里面有这样的一个定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子就是io包下面的 io.ReadWriter ，它包含了io包下面的Reader和Writer两个interface：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>所谓反射就是能检查程序在运行时的状态，一般用到的包是reflect包<a href="http://golang.org/doc/articles/laws_of_reflection.html" target="_blank" rel="noopener">reflect包的实现原理</a></p><p>使用reflect一般分成三步：要去反射是一个类型的值(这些值都实现了空interface)，首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure><p>转化为reflect对象之后我们就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure><p>获取反射值能返回相应的类型和数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br></pre></td></tr></table></figure><p>最后，反射的字段必须是可修改的。如果下面这样写，会error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure><p>如果要修改相应的值，必须这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 记录下休学期间学习Go语言入门的一些想法、笔记和踩过的一些坑。&lt;/p&gt;
&lt;p&gt;希望之后这个Go系列还会继续完善下去不被弃坑（小声）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://stardust567.github.io/categories/Go/"/>
    
    
      <category term="GAP" scheme="https://stardust567.github.io/tags/GAP/"/>
    
      <category term="Tips" scheme="https://stardust567.github.io/tags/Tips/"/>
    
      <category term="Go" scheme="https://stardust567.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>21Projects-01MNIST</title>
    <link href="https://stardust567.github.io/post/adbc.html"/>
    <id>https://stardust567.github.io/post/adbc.html</id>
    <published>2019-09-24T14:34:41.000Z</published>
    <updated>2019-09-24T14:41:49.052Z</updated>
    
    <content type="html"><![CDATA[<p>有关MNIST数据集上进行softmax-交叉熵和简易CNN两种方法的知识点小整理。<a id="more"></a></p><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>])</span><br></pre></td></tr></table></figure><p>tf的占位符，用于传入外部数据</p><blockquote><p>placeholder(dtype, shape=None, name=None):</p><p>:param dtype: 数据类型<br>:param shape: 数据维度，None表无限制<br>:param name: 名称<br>:return: Tensor类型</p></blockquote><p>例子：TensorFlow中加载图片的维度为[batch, height, width, channels]</p><p>故placeholder的shape可写为[None, None, None, 3]</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = tf.Variable(tf.zeros([<span class="number">784</span>, <span class="number">10</span>]))</span><br></pre></td></tr></table></figure><p>tf变量需要初始值，一旦初始值确定，那么该变量的类型和形状就基本确定了</p><blockquote><p>Variable(initial_value=None, trainable=True, validate_shape=True, name=None):</p><p>:param initial_value:初始值，可以搭配tensorflow随机生成函数<br>:param trainable:默认该变量可被算法优化，不想该变量被优化，改为False<br>:param validate_shape:默认形状不接受更改，如需更改，改为False<br>:param name:给变量确定名称<br>:return: Tensor类型</p></blockquote><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.InteractiveSession()</span><br></pre></td></tr></table></figure><p>对上述结点进行计算的上下文，变量的值会保存在会话中。</p><h2 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h2><p>即归一化指数函数，将多分类中各个类别的评价分数转换为和为1的分布概率</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e348290cf48ddbb6e9a6ef4e39363568b67c09d3" alt="{\displaystyle \sigma (\mathbf {z} )_{j}={\frac {e^{z_{j}}}{\sum _{k=1}^{K}e^{z_{k}}}}}">    for <em>j</em> = 1, …, <em>K</em>.</p><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>一件事发生的可能性越小，其发生所带来的信息量越大；反之，一件发生概率为1的事发生，对我们来说毫无价值，获取到的信息量为0。</p><p>假设X是一个离散型随机变量，定义事件X=x0的信息量为：I(x0)=−log(p(x0))，其中p(x0)取值为[0, 1]</p><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>对于某个事件，熵反映了其所有可能性所带来的信息量，是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。</p><p>熵用来表示所有信息量的期望H(X)=−∑p(xi)*log(p(xi))</p><h4 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h4><p>即KL散度，如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用 KL 散度来衡量这两个分布的差异，即如果用P来描述目标问题，而不是用Q来描述目标问题，得到的信息增量。</p><p>在机器学习中，P表示样本真实分布，比如[1,0,0]（样本属于第一类）Q表示模型预测分布，比如[0.7,0.2,0.1] </p><p>对于离散随机变量，其概率分布P 和 Q的KL散度可按下式定义为D~KL~(P|Q) = ∑~i~P(x~i~)log(p(x~i~)/q(x~i~))其中D~KL~的值越小，表示q分布和p分布越接近。</p><h2 id="交叉熵-1"><a href="#交叉熵-1" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>相对熵中D~KL~(P|Q) =  ∑~i~P(x~i~)log[p(x~i~)/q(x~i~)] = ∑~i~P(x~i~)log(p(x~i~)) - ∑~i~P(x~i~)log(q(x~i~)) = -H(p(x)) + [-∑~i~P(x~i~)*log(q(x~i~))]</p><p>其中真实样本熵固定，所以直接用-∑~i~P(x~i~)*log(q(x~i~))作为优化指标（交叉熵）即可，即交叉熵越小越好。</p><h4 id="交叉熵VS均方根误差"><a href="#交叉熵VS均方根误差" class="headerlink" title="交叉熵VS均方根误差"></a>交叉熵VS均方根误差</h4><p>做分类问题时，为什么我们不用RSME而是交叉熵作损失函数呢？</p><ol><li>我们希望损失函数能做到，当预测值跟目标值越远时，修改参数后能减去一个更大的值，做到更加快速的下降。</li><li>函数更不容易陷入局部最优解。</li></ol><p>在做后向传播时，会出现（基于一个样本的情况，对于softmax下w，b偏导进行计算）：</p><ol><li>RSME在更新w，b时候，w,b的梯度跟激活函数的梯度成正比，激活函数梯度越大，w,b调整就越快，训练收敛就越快，但是Simoid函数在值非常高时候，梯度是很小的，比较平缓。</li><li>交叉熵在更新w,b时候，w,b的梯度跟激活函数的梯度没有关系了，bz已经表抵消掉了，其中bz-y表示的是预测值跟实际值差距，如果差距越大，那么w,b调整就越快，收敛就越快。</li></ol><h4 id="均方根误差VS平均绝对误差"><a href="#均方根误差VS平均绝对误差" class="headerlink" title="均方根误差VS平均绝对误差"></a>均方根误差VS平均绝对误差</h4><p>而在做回归问题时，我们的选择又该是什么样呢？</p><p>RSME：若出现误差较大的点，RSME将被调整以最小化这个离群数据点，但却是以牺牲其他正常数据点的预测效果为代价，这最终会降低模型的整体性能。</p><p>MAE：若出现误差较大的点，最小化MAE的预测为所有目标值的中位数。我们知道中位数对于离群点比平均值更鲁棒，这使得MAE比MSE更加鲁棒。但使用MAE损失（特别是对于神经网络）的一个大问题是它的梯度始终是相同的，这意味着即使对于小的损失值，其梯度也是大的。</p><h4 id="Log-Cosh-Loss"><a href="#Log-Cosh-Loss" class="headerlink" title="Log-Cosh Loss"></a>Log-Cosh Loss</h4><p>Log-cosh是用于回归任务的另一种损失函数，它比之前两种更加平滑。顾名思义，它采用 ∑~i~log(cosh(y~i~^p^-y~i~))作预测误差。Log-cosh Loss对于小的x来说，其大约等于 (x <strong> 2) / 2，而对于大的x来说，其大约等于 abs(x) - log(2)。这意味着logcosh的作用大部分与均方误差一样，但不会受到偶尔出现的极端不正确预测的强烈影响，</strong>且二阶可导**。</p><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_image = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>因为cnn需要在图片的像素矩阵上进行池化等操作，所以需要将原来的784*1向量转成28*28的矩阵（[-1, 28, 28, 1]中的-1形状的第一维大小是根据x自动确定的）</p><h3 id="tf-nn-conv2d"><a href="#tf-nn-conv2d" class="headerlink" title="tf.nn.conv2d()"></a>tf.nn.conv2d()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><p> <code>tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)</code></p><p>input：需要做卷积的输入图像(Tensor=[batch, in_height, in_width, in_channels])即[训练时一个batch的图片数量, 图片高, 图片宽, 图像通道数]，该Tensor要求类型为float32或float64</p><p>filter：CNN卷积核(Tensor=[filter_height, filter_width, in_channels, out_channels])即[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型<strong>与参数input相同</strong>，有一个地方需要注意，<strong>第三维in_channels，就是参数input的第四维</strong></p><p>strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4</p><p>padding：只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式</p><p>use_cudnn_on_gpu：bool类型，是否使用cudnn加速，默认为true</p><p>return：Tensor，就是我们常说的feature map</p><h3 id="tf-nn-max-pool"><a href="#tf-nn-max-pool" class="headerlink" title="tf.nn.max_pool()"></a>tf.nn.max_pool()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><p><code>tf.nn.max_pool(value, ksize, strides, padding, name=None)</code></p><p>value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape</p><p>ksize：池化窗口的大小，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1</p><p>strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]</p><p>padding：和卷积类似，可以取’VALID’ 或者’SAME’</p><p>return：Tensor=[batch, height, width, channels]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关MNIST数据集上进行softmax-交叉熵和简易CNN两种方法的知识点小整理。
    
    </summary>
    
    
      <category term="机器学习" scheme="https://stardust567.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="大三" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%B8%89/"/>
    
      <category term="机器学习" scheme="https://stardust567.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://stardust567.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="21Projects" scheme="https://stardust567.github.io/tags/21Projects/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫框架</title>
    <link href="https://stardust567.github.io/post/b2a.html"/>
    <id>https://stardust567.github.io/post/b2a.html</id>
    <published>2019-07-07T03:44:36.000Z</published>
    <updated>2020-05-09T03:40:59.318Z</updated>
    
    <content type="html"><![CDATA[<p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。</p><p>以下整理于自己业余写的简单爬虫 <a href="https://github.com/Stardust567/theGuardianNews" target="_blank" rel="noopener">theGuardianNews</a>路过朋友有兴趣可以看看。 <a id="more"></a></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建新Scrapy项目，在存储代码的目录下git bash<br><code>scrapy startproject news</code></p><p>这将创建一个名为<em>news</em>的目录，文件tree如下：</p><p>news<br>│  scrapy.cfg&emsp; &emsp; &emsp; # deploy configuration file<br>└─news&emsp; &emsp; &emsp; &emsp; &emsp; # project Python module, import your code from here<br>&emsp; │  items.py&emsp; &emsp; &emsp; # project items definition file<br>&emsp; │  middlewares.py&emsp; # project middlewares file<br>&emsp; │  pipelines.py&emsp; &emsp; # project pipelines file<br>&emsp; │  settings.py&emsp; &emsp; # project settings file<br>&emsp; │  __init__.py<br>&emsp; └─spiders&emsp; &emsp; &emsp; # a directory where you will later put your spiders<br>&emsp; &emsp; │  __init__.py</p><h2 id="编写Spiders"><a href="#编写Spiders" class="headerlink" title="编写Spiders"></a>编写Spiders</h2><p>定义Spider类用来从网站中提取信息。</p><ol><li>必须子类化 <code>scrapy.Spider</code>并定义要生成的初始请求</li><li>可选地如何跟踪页面中的链接</li><li>解析下载的页面内容以提取数据</li></ol><p>在news目录下cmd输入<code>scrapy genspider news theguardian.com</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">news</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"news"</span></span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">'https://www.theguardian.com/'</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="string">'''start_urls将默认执行yield scrapy.Request故可省略以下：</span></span><br><span class="line"><span class="string">    for url in urls:</span></span><br><span class="line"><span class="string">        yield scrapy.Request(url=url, callback=self.parse)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>parse()</code>方法通常解析响应，将抽取的数据提取为dicts，并查找要遵循的新URL并<code>Request</code>从中创建新的request()</p><h2 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h2><p>强烈安利用<code>scrapy shell url</code>的方式先在shell里试试，这样不会运行几次就被反爬。</p><p><code>::text</code>表示抽取标签内字符串，<code>::attr(title)</code>表示抽取title属性内容</p><p><code>extract()</code>为一个包含数据串的list，<code>extract_first()</code>为list的第一个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urls = response.css(<span class="string">'a[class="fc-item__link"]'</span>).css(<span class="string">'a[data-link-name="article"]'</span>).xpath(<span class="string">'@href'</span>).extract()</span><br><span class="line">title = response.css(<span class="string">'h1[class ="content__headline "]'</span>).css(<span class="string">'h1[itemprop="headline"]::text'</span>).extract()</span><br><span class="line">time = response.css(<span class="string">'time[itemprop = "datePublished"]::text'</span>).extract_first()</span><br><span class="line">category = response.css(<span class="string">'a[class ="subnav-link subnav-link--current-section"]::text'</span>).extract_first()</span><br><span class="line">tags = response.css(<span class="string">'a[class = "submeta__link"]::text'</span>).extract()</span><br><span class="line">content = response.css(<span class="string">'div[itemprop = "articleBody"]'</span>).css(<span class="string">'p::text'</span>).extract()</span><br></pre></td></tr></table></figure><h2 id="创建Item"><a href="#创建Item" class="headerlink" title="创建Item"></a>创建Item</h2><p>打开news文件夹下的items.py创建类NewsItem</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    time = scrapy.Field()</span><br><span class="line">    category = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br></pre></td></tr></table></figure><h2 id="设置Pipeline"><a href="#设置Pipeline" class="headerlink" title="设置Pipeline"></a>设置Pipeline</h2><p>Item pipeline组件有两个典型作用：1. 查重丢弃 ；2. 保存数据到文件或数据库中。</p><p>假设我们采用本地json存取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        title = item[<span class="string">'title'</span>]</span><br><span class="line">        <span class="keyword">if</span> title:</span><br><span class="line">            title_str = <span class="string">''</span>.join(title)</span><br><span class="line">            item[<span class="string">'title'</span>] = title_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>: // 如果title为空则跳过这个item</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        time = item[<span class="string">'time'</span>]</span><br><span class="line">        <span class="keyword">if</span> time:</span><br><span class="line">            item[<span class="string">'time'</span>] = time.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        category = item[<span class="string">'category'</span>]</span><br><span class="line">        <span class="keyword">if</span> category:</span><br><span class="line">            item[<span class="string">'category'</span>] = category.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        tags = item[<span class="string">'tags'</span>]</span><br><span class="line">        <span class="keyword">if</span> tags:</span><br><span class="line">            tags_str = <span class="string">','</span>.join(tags)</span><br><span class="line">            item[<span class="string">'tags'</span>] = tags_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        content = item[<span class="string">'content'</span>]</span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            content_str = <span class="string">''</span>.join(content)</span><br><span class="line">            item[<span class="string">'content'</span>] = content_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonWriterPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.file = codecs.open(<span class="string">'data_utf8.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">// 如果是中文需要utf8的话，<span class="keyword">import</span> codecs</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        line = json.dumps(dict(item), ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.file.write(line)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_closed</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><p>之后别忘了在setting中改一下<code>ITEM_PIPELINES</code>的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'news.pipelines.NewsPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'news.pipelines.JsonWriterPipeline'</span>: <span class="number">800</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们采用MongoDB，打开news文件夹下的pipelines.py创建类NewsPipline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        title = item[<span class="string">'title'</span>]</span><br><span class="line">        <span class="keyword">if</span> title:</span><br><span class="line">            title_str = <span class="string">''</span>.join(title)</span><br><span class="line">            item[<span class="string">'title'</span>] = title_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>: // 如果title为空则跳过这个item</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        time = item[<span class="string">'time'</span>]</span><br><span class="line">        <span class="keyword">if</span> time:</span><br><span class="line">            item[<span class="string">'time'</span>] = time.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        category = item[<span class="string">'category'</span>]</span><br><span class="line">        <span class="keyword">if</span> category:</span><br><span class="line">            item[<span class="string">'category'</span>] = category.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        tags = item[<span class="string">'tags'</span>]</span><br><span class="line">        <span class="keyword">if</span> tags:</span><br><span class="line">            tags_str = <span class="string">','</span>.join(tags)</span><br><span class="line">            item[<span class="string">'tags'</span>] = tags_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">        content = item[<span class="string">'content'</span>]</span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            content_str = <span class="string">''</span>.join(content)</span><br><span class="line">            item[<span class="string">'content'</span>] = content_str.replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Information was missing'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 链接数据库</span></span><br><span class="line">        client = pymongo.MongoClient(host=settings[<span class="string">'MONGO_HOST'</span>], port=settings[<span class="string">'MONGO_PORT'</span>])</span><br><span class="line">        self.db = client[settings[<span class="string">'MONGO_DB'</span>]]  <span class="comment"># 获得数据库的句柄</span></span><br><span class="line">        self.coll = self.db[settings[<span class="string">'MONGO_COLL'</span>]]  <span class="comment"># 获得collection的句柄</span></span><br><span class="line">        <span class="comment"># 数据库登录需要帐号密码的话</span></span><br><span class="line">        <span class="comment"># self.db.authenticate(settings['MONGO_USER'], settings['MONGO_PSW'])</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        postItem = dict(item)  <span class="comment"># 把item转化成字典形式</span></span><br><span class="line">        self.coll.insert(postItem)  <span class="comment"># 向数据库插入一条记录</span></span><br><span class="line">        <span class="keyword">return</span> item  <span class="comment"># 会在控制台输出原item数据，可以选择不写</span></span><br></pre></td></tr></table></figure><p>同样我们需要在setting中改一下<code>ITEM_PIPELINES</code>的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'news.pipelines.NewsPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'news.pipelines.MongoPipeline'</span>: <span class="number">800</span>,</span><br><span class="line">&#125;</span><br><span class="line">MONGO_HOST = <span class="string">"127.0.0.1"</span>  <span class="comment"># 主机IP</span></span><br><span class="line">MONGO_PORT = <span class="number">27017</span>  <span class="comment"># 端口号</span></span><br><span class="line">MONGO_DB = news_tutorial<span class="string">"  # 库名</span></span><br><span class="line"><span class="string">MONGO_COLL = "</span>news_items<span class="string">"  # collection名</span></span><br><span class="line"><span class="string"># MONGO_USER = "</span>simple<span class="string">" #用户名</span></span><br><span class="line"><span class="string"># MONGO_PSW = "</span>test<span class="string">" #用户密码</span></span><br></pre></td></tr></table></figure><h2 id="修改Spider"><a href="#修改Spider" class="headerlink" title="修改Spider"></a>修改Spider</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> news.items <span class="keyword">import</span> NewsItem</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_news</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = NewsItem()</span><br><span class="line">        ......<span class="comment"># 提取数据的过程</span></span><br><span class="line">        item[<span class="string">'title'</span>] = title</span><br><span class="line">        item[<span class="string">'time'</span>] = time</span><br><span class="line">        item[<span class="string">'category'</span>] = category</span><br><span class="line">        item[<span class="string">'tags'</span>] = tags</span><br><span class="line">        item[<span class="string">'content'</span>] = content</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>修改完的spider如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> news.items <span class="keyword">import</span> NewsItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeadSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'news'</span></span><br><span class="line">    allowed_domains = [<span class="string">'theguardian.com'</span>]</span><br><span class="line">    base_url = <span class="string">'https://www.theguardian.com/'</span></span><br><span class="line">    start_urls = []</span><br><span class="line">    topics = [<span class="string">'world'</span>, <span class="string">'science'</span>, <span class="string">'cities'</span>, <span class="string">'global-development'</span>,</span><br><span class="line">              <span class="string">'uk/sport'</span>, <span class="string">'uk/technology'</span>, <span class="string">'uk/business'</span>, <span class="string">'uk/environment'</span>, <span class="string">'uk/culture'</span>]</span><br><span class="line">    years = [<span class="number">2019</span>]</span><br><span class="line">    months = [<span class="string">'jan'</span>, <span class="string">'feb'</span>, <span class="string">'mar'</span>, <span class="string">'apr'</span>, <span class="string">'may'</span>, <span class="string">'jun'</span>,</span><br><span class="line">              <span class="string">'jul'</span>, <span class="string">'aug'</span>, <span class="string">'sep'</span>, <span class="string">'oct'</span>, <span class="string">'nov'</span>, <span class="string">'dec'</span>]</span><br><span class="line">    dates = range(<span class="number">1</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> topic <span class="keyword">in</span> topics:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> years:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> months:</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> dates:</span><br><span class="line">                    url = base_url + topic + <span class="string">'/'</span> + str(y) + <span class="string">'/'</span> + m + <span class="string">'/'</span> + <span class="string">'%02d'</span> % d + <span class="string">'/'</span> + <span class="string">'all'</span></span><br><span class="line">                    start_urls.append(url) </span><br><span class="line">                    <span class="comment"># 类似于 https://www.theguardian.com/uk/sport/2019/apr/01/all</span></span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        urls = response.css(<span class="string">'a[class="fc-item__link"]'</span>).css(<span class="string">'a[data-link-name="article"]'</span>).xpath(<span class="string">'@href'</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls: </span><br><span class="line">            <span class="comment"># 每个https://www.theguardian.com/uk/sport/2019/apr/01/all页面上的news连接</span></span><br><span class="line">            <span class="keyword">yield</span> Request(url, self.get_news)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_news</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = NewsItem()</span><br><span class="line">        title = response.css(<span class="string">'h1[class ="content__headline "]'</span>).css(<span class="string">'h1[itemprop="headline"]::text'</span>).extract()</span><br><span class="line">        <span class="keyword">if</span>(len(title)==<span class="number">0</span>): </span><br><span class="line">            <span class="comment"># 卫报的news页面有两种形式，如果第一种没抓到，就用模式二</span></span><br><span class="line">            title = response.css(<span class="string">'meta[itemprop="description"]'</span>).xpath(<span class="string">'@content'</span>).extract()</span><br><span class="line">        time = response.css(<span class="string">'time[itemprop = "datePublished"]::text'</span>).extract_first()</span><br><span class="line">        category = response.css(<span class="string">'a[class ="subnav-link subnav-link--current-section"]::text'</span>).extract_first()</span><br><span class="line">        tags = response.css(<span class="string">'a[class = "submeta__link"]::text'</span>).extract()</span><br><span class="line">        content = response.css(<span class="string">'div[itemprop = "articleBody"]'</span>).css(<span class="string">'p::text'</span>).extract()</span><br><span class="line">        <span class="keyword">if</span> (len(content) == <span class="number">0</span>):</span><br><span class="line">        content = title <span class="comment"># 有些news内容可能时视频或者其它非文本模式，这时我们用title作为content</span></span><br><span class="line">    </span><br><span class="line">        item[<span class="string">'title'</span>] = title</span><br><span class="line">        item[<span class="string">'time'</span>] = time</span><br><span class="line">        item[<span class="string">'category'</span>] = category</span><br><span class="line">        item[<span class="string">'tags'</span>] = tags</span><br><span class="line">        item[<span class="string">'content'</span>] = content</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p>打开news文件夹下的settings.py可以修改一些小细节便于我们爬取数据。</p><p>TIPS：加上<code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code>适用于爬取中文内容哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORT_ENCODING = <span class="string">'utf-8'</span> <span class="comment"># 修改编码为utf-8</span></span><br><span class="line">DOWNLOAD_TIMEOUT = <span class="number">10</span> <span class="comment"># 下载超时设定，超过10秒没响应则放弃当前URL</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'news.pipelines.NewsPipeline'</span>: <span class="number">300</span>, // 这个没改，参照pipe看个人选择</span><br><span class="line">&#125;</span><br><span class="line">CONCURRENT_REQUESTS = <span class="number">32</span> <span class="comment"># 最大并发请求数（默认16</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">0.01</span> <span class="comment"># 增加爬取延迟，降低被爬网站服务器压力</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="针对反爬"><a href="#针对反爬" class="headerlink" title="针对反爬"></a>针对反爬</h2><p>去奥斯汀访学（旅游）时候写的yelp爬虫 <a href="https://github.com/Stardust567/yelp" target="_blank" rel="noopener">yelpReview</a>路过朋友有兴趣可以看看。</p><ul><li>使用user agent池，轮流选择之一来作为user agent；池中包含常见的浏览器的user agent。</li><li>禁止cookies(参考 <a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/downloader-middleware.html#std:setting-COOKIES_ENABLED" target="_blank" rel="noopener"><code>COOKIES_ENABLED</code></a>)，有些站点会使用cookies来发现爬虫的轨迹。</li><li>设置下载延迟(2或更高)。参考 <a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/settings.html#std:setting-DOWNLOAD_DELAY" target="_blank" rel="noopener"><code>DOWNLOAD_DELAY</code></a> 设置。</li><li>如果可行，使用 <a href="http://www.googleguide.com/cached_pages.html" target="_blank" rel="noopener">Google cache</a> 来爬取数据，而不是直接访问站点。</li><li>使用IP池。例如免费的 <a href="https://www.torproject.org/" target="_blank" rel="noopener">Tor项目</a> 或付费服务(<a href="http://proxymesh.com/" target="_blank" rel="noopener">ProxyMesh</a>)。</li><li>使用分布式下载器(downloader)来绕过禁止(ban)，就只需要专注分析处理页面。eg: <a href="http://crawlera.com/" target="_blank" rel="noopener">Crawlera</a></li></ul><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>创建userAdminAnyDatabase角色，用来管理用户，可以通过这个角色来创建、删除用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> use admin</span></span><br><span class="line">switched to db admin</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createUser(</span></span><br><span class="line">...   &#123;</span><br><span class="line">...     user: "userAdmin",//用户名</span><br><span class="line">...     pwd: "123",//密码</span><br><span class="line">...     roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ]</span><br><span class="line">...   &#125;</span><br><span class="line">... )</span><br><span class="line">Successfully added user: &#123;</span><br><span class="line">    "user" : "dba",</span><br><span class="line">    "roles" : [</span><br><span class="line">        &#123;</span><br><span class="line">            "role" : "userAdminAnyDatabase",</span><br><span class="line">            "db" : "admin"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我怕忘了自己设置过的user和pwd各位游客可以不用在意（小声）</p><p>打开安装mongoDB环境的命令行，比如我之前是在Windows下安装的，故打开cmd输入<code>mongo</code>会有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MongoDB shell version v3.4.10-58-g9847179</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.4.10-58-g9847179</span><br></pre></td></tr></table></figure><p>然后我个人安利下可视化工具adminMongo下载轻松简单（主要是界面好看清爽）</p><p>打开adminMongo目录，<code>npm start</code>会有如下输入，根据提示打开<a href="http://localhost:1234即可" target="_blank" rel="noopener">http://localhost:1234即可</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> admin-mongo@0.0.23 start D:\adminMongo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> node app.js</span></span><br><span class="line"></span><br><span class="line">adminMongo listening on host: http://localhost:1234</span><br></pre></td></tr></table></figure><p>打开页面后，connection名字仅供参考（随便设）MongoDB连接字符串的格式可以是：<code>mongodb://&lt;user&gt;:&lt;password&gt;@127.0.0.1:&lt;port&gt;/&lt;db&gt;</code>指定<db>级别是可选的，一般<code>mongodb://:@127.0.0.1:27017</code>即可。<br>有关MongoDB连接字符串的更多信息，请参阅<a href="http://docs.mongodb.org/manual/reference/connection-string/" target="_blank" rel="noopener">正式的MongoDB文档</a>。</db></p><h2 id="写入依赖"><a href="#写入依赖" class="headerlink" title="写入依赖"></a>写入依赖</h2><p>打开项目所在文件目录，然后打开命令行输入即可得到requirements.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf-8</span><br></pre></td></tr></table></figure><p>这样之后有人需要用这个项目的时候直接打开命令行输入以下即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。&lt;/p&gt;
&lt;p&gt;以下整理于自己业余写的简单爬虫 &lt;a href=&quot;https://github.com/Stardust567/theGuardianNews&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theGuardianNews&lt;/a&gt;路过朋友有兴趣可以看看。
    
    </summary>
    
    
      <category term="Python" scheme="https://stardust567.github.io/categories/Python/"/>
    
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="爬虫" scheme="https://stardust567.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="scrapy" scheme="https://stardust567.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>软件安全设计</title>
    <link href="https://stardust567.github.io/post/811e.html"/>
    <id>https://stardust567.github.io/post/811e.html</id>
    <published>2019-06-03T01:42:45.000Z</published>
    <updated>2019-07-15T05:29:17.156Z</updated>
    
    <content type="html"><![CDATA[<p>这是一门针对安全过程模型、基于风险测试、威胁分析报告等谈漏洞讲威胁的学科。</p><a id="more"></a><h1 id="软件与软件安全"><a href="#软件与软件安全" class="headerlink" title="软件与软件安全"></a>软件与软件安全</h1><h2 id="信息安全与软件安全"><a href="#信息安全与软件安全" class="headerlink" title="信息安全与软件安全"></a>信息安全与软件安全</h2><h3 id="信息安全基本属性"><a href="#信息安全基本属性" class="headerlink" title="信息安全基本属性"></a>信息安全基本属性</h3><p> <strong>安全性、可用性、保密性、可控性、可靠性</strong></p><p>恰当的信息安全定义：信息具有保密性，完整性，可用性</p><h3 id="软件安全"><a href="#软件安全" class="headerlink" title="软件安全"></a>软件安全</h3><p> <strong>软件安全 </strong>：软件在恶意攻击下能够正确地完成其功能。<br> <strong>软件安全性 </strong>：软件不被恶意使用或者攻击进而造成用户信息资产损失的属性。包括：<br>（1） 可信性：保护敏感信息不被未授权用户访问<br>（2） 完整性：保护数据不被更改或破坏<br>（3） 可用性：确保资源被授权用户的使用<br> <strong>软件安全保护 </strong>：软件的完整性、可用性、可信性。<br>（1） 自身安全：防止软件丢失、被破坏、被篡改、被伪造<br>（2） 存储安全：可靠存储，保密存储，压缩存储，备份存储<br>（3） 通信安全：安全传输、加密传输、网络安全下载、完整下载<br>（4） 使用安全：防止非法用户授权访问，软件滥用，软件窃取，非法复制<br>（5） 运行安全：确保软件正常运行，功能正常<br> <strong>软件安全研究 </strong>：<br>如何设计、构造、验证和维护软件以保证其是安全的。<br>——改进和实现软件安全的 <strong>架构、工具、方法 </strong></p><h3 id="开放系统互连安全的体系架构ISO7498-2"><a href="#开放系统互连安全的体系架构ISO7498-2" class="headerlink" title="开放系统互连安全的体系架构ISO7498-2"></a>开放系统互连安全的体系架构ISO7498-2</h3><p>5种 <strong>安全服务 </strong>：<br>鉴别服务、访问控制、数据完整性、数据保密性、抗抵赖<br>8种 <strong>安全机制 </strong>：<br>加密、数字签名、访问控制、数据完整性、数据交换、业务流填充、路由控制、公证<br>5种 <strong>安全管理机制 </strong>：<br>可信功能度、安全标记、事件检测、安全审计跟踪、安全恢复</p><h2 id="软件安全重要概念"><a href="#软件安全重要概念" class="headerlink" title="软件安全重要概念"></a>软件安全重要概念</h2><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p> <strong>安全漏洞 </strong>：可能被入侵者恶意利用的属性，也称脆弱性。<label style="color:red">漏洞是软件的属性。</label><br> <strong>漏洞本质 </strong>：通过已授权的手段获取对资源的未经授权访问，或对系统造成损害。<br> <strong>安全事件 </strong>：当系统的某个漏洞被入侵者渗透而造成泄密时，其结果称一次安全事件。<br> <strong>脆弱状态 </strong>：从已授权的状态变换到未授权状态。<br> <strong>攻击 </strong>：以授权状态或脆弱状态开始，以受损状态为目标的状态变换。</p><h3 id="ISO9126质量特性"><a href="#ISO9126质量特性" class="headerlink" title="ISO9126质量特性"></a>ISO9126质量特性</h3><p><strong>1.功能性</strong><br> 准确性：功能精确度<br> 互操作性：与其它系统交互<br> 保密安全性：主要是权限和密码<br><strong>2.可靠性</strong><br> 成熟性：对内错误的隔离<br> 容错性：对外错误的隔离<br> 易恢复性：系统失效后的重新恢复<br><strong>3.易用性</strong><br> 易理解性；易学性；易操作性<br><strong>4.效率</strong><br> 时间特性：响应时间；资源利用性：所耗系统资源<br><strong>5.维护性</strong><br> 易分析性<br> 易改变性：降低修复问题的成本<br> 稳定性：避免由于软件修改而造成意外结果<br> 易测试性<br><strong>6.可移植性</strong><br> 适应性：无需变动就能适应不同环境<br> 易安装性<br> 共存性：公共环境中与其它软件分享公共资源<br> 易替换性：同样环境下，替代相同用途的产品</p><p><strong>缺陷</strong>：安全性是软件功能性的子属性-&gt;对安全的忽视</p><p> <strong>安全的代码 </strong>：能够抵抗恶意攻击的代码；安全的代码同时也是健壮的代码<br> <strong>安全性代码 </strong>：实现安全功能的代码<br> <strong>安全的程序 </strong>：安全隐含一定程度信任，实现了期望的机密性、完整性、可用性及其功能</p><h1 id="典型软件安全问题"><a href="#典型软件安全问题" class="headerlink" title="典型软件安全问题"></a>典型软件安全问题</h1><h2 id="安全问题来源"><a href="#安全问题来源" class="headerlink" title="安全问题来源"></a>安全问题来源</h2><ol><li>攻击者</li><li>软件存在的攻击路径－攻击面问题</li><li><strong>漏洞 </strong><label style="color:red">漏洞是软件的属性，也是软件安全威胁的根源。</label><br>产生原因：<br>（1） 软件或协议<strong>设计</strong>时的瑕疵<br>（2） 软件或协议<strong>实现</strong>中的弱点<br>（3） 软件本身的瑕疵——良好的、编写安全程序的的编程习惯。<br>（4） 系统和网络的<strong>错误配置</strong><br>可以分为：<br>（1） 设计漏洞：设计错误，往往发现于软件的安全功能特性中。<br>（2） 实现漏洞：实际编码中的安全缺陷。<br><strong>意外行为</strong>：即程序安全<strong>缺陷</strong>，由于程序<strong>脆弱性</strong>引起的不适当程序行为。分有意的和无意的两种<del>（废话）</del>常见缺陷：缓冲区溢出、未校验输入、 资源竞争、访问控制问题、认证、授权、加密缺陷。</li></ol><h2 id="安全设计问题"><a href="#安全设计问题" class="headerlink" title="安全设计问题"></a>安全设计问题</h2><ol><li>密码技术使用的败笔<br>（1）创建自己的密码技术or选用不当的密码技术<br>（2）依赖隐蔽式安全<br>（3）编写到程序中的密钥<br>（4）错误地处理私密信息</li><li>对用户及其许可权限进行跟踪的薄弱或缺失<br>会话管理、身份鉴别、授权的薄弱或缺失</li><li>有缺陷的输入验证<br>（1）未在安全的上下文环境中执行验证：如在服务器验证而未在客户端验证<br>（2）验证例程不集中：验证应尽可能靠近用户输入and验证应集中以便核实<br>（3）不安全的组件边界</li><li>薄弱的结构性安全<br>（1）过大的攻击面<br>（2）在过高权限级别上运行进程<br>（3）没有纵深防御<br>（4）失效时的处理不安全</li><li>其他<br>（1）代码和数据混在一起<br>（2）错将信任寄予外部系统<br>（3）不安全的默认值<br>（4）未做审计日志</li></ol><h2 id="C-C-安全问题"><a href="#C-C-安全问题" class="headerlink" title="C/C++安全问题"></a>C/C++安全问题</h2><p>问题1：没有安全的本地字符串类型and没有安全易用的字符串处理函数<br>以NULL终止符表示一个字符串的末尾 -&gt; 容易导致缓冲区溢出<br>问题2：缓冲区超限覆盖栈中的函数返回地址<br>栈溢出：函数返回地址在栈中位置紧接本地变量后，该变量缓冲区溢出会覆盖栈中返回地址。预防：精确控制输入变量长度；避免使用无界字符串；使用字符串缓冲区模块。<br>问题3：printf类型的格式化函数－格式化字符串攻击<br>sprintf(target, “Name: %s%s%s%s”);从栈中读取四个字符串，但事实上栈中不存在这四个字符串，程序读取栈中原本用于其他目的的值。<br>问题4：整数溢出<br>在C语言中，整数的正负标识是默认的；C语言没有任何措施预防整数溢出。</p><h2 id="平台实现安全问题"><a href="#平台实现安全问题" class="headerlink" title="平台实现安全问题"></a>平台实现安全问题</h2><p>平台：指程序在其中所运行的环境，包括OS及其交互组件。威胁多来自<strong>交互和OS</strong><br>平台问题1：符号链接<br>符号链接等效于其指向的文件，即攻击者可以借此启动系统中任何程序。<br>权限——必须检查该文件的符号链接，不可以基于文件名做任何安全方面的判定<br>平台问题2：目录遍历<br>CIFS文件共享协议，允许计算机通过网络访问彼此文件系统。攻击者可通过使用“..”向上追溯<br>平台问题3：字符转换<br>平台进行升级的时候可能会引入新的字符编码，可能会产生意料外的结果</p><h2 id="应用程序安全问题"><a href="#应用程序安全问题" class="headerlink" title="应用程序安全问题"></a>应用程序安全问题</h2><p>引起原因：<br>某个组件的恶意数据在其另一个组件中被当作了合法代码；对涉密信息的不当处理<br>问题1：SQL注入<br>在连接到<label style="color:red">数据库</label>的应用程序上执行自己所构造的查询。输入用户名’or’1=1，<label style="color:red">数据库</label>里执行Select * from sys_user where username=’’or’1=1’成功入侵<br>问题2：跨站点执行脚本<br>来自非受信环境的攻击者可在受信环境注入数据，使其在受信环境作为脚本予以执行。类似于我写了一个脚本在你电教务系统上跑，你以为是你电新功能就输了你的学号密码<del>收到了学号密码的我就能为所欲为为所欲为</del><br>跨站点执行脚本还可以用来访问数据，如用户cookies。<code>&lt;input type=&quot;text&quot; name=&quot;address1&quot; value=&quot;value1from&quot;&gt;</code>value后面的值是来自用户的输入，如果用户输入<code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code>那么就会变成<code>&lt;input type=&quot;text&quot;name=&quot;address1&quot; value=&quot;&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-&quot;&gt;</code>嵌入的JavaScript代码将会被执行。</p><h2 id="开发过程问题"><a href="#开发过程问题" class="headerlink" title="开发过程问题"></a>开发过程问题</h2><p>安全需求和前提条件的文档记录缺乏<br>交流和文档匮乏<br>缺少安全过程<br>部署上的薄弱性：执行部署的一般不属于开发团队，很可能会扩大权限</p><h2 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h2><p>The Open Web Application Security Project<br>A1-注入：发送的恶意数据可以欺骗解释器，执行计划外的命令或者在未被恰当授权时访问数据。<br>A2-失效的身份认证<br>A3-跨站脚本<br>A4-不安全的直接对象引用<br>A5-安全配置错误<br>A6-敏感信息泄漏<br>A7-功能级访问控制缺失<br>A8-跨站请求伪造：迫使用户浏览器向存在漏洞的web应用程序发送请求<br>A9-使用含有已知漏洞的组件<br>A10-未验证的重定向和转发</p><h1 id="安全软件工程"><a href="#安全软件工程" class="headerlink" title="安全软件工程"></a>安全软件工程</h1><h2 id="SSE-CMM"><a href="#SSE-CMM" class="headerlink" title="SSE-CMM"></a>SSE-CMM</h2><p>在CMM模型的基础上，通过对安全工程进行管理的途径将系统安全工程转变为一个具有良好定义的、成熟的、可测量的先进工程学科。发起者：国防部&amp;国家安全局</p><h3 id="开发目的"><a href="#开发目的" class="headerlink" title="开发目的"></a>开发目的</h3><p>降低开发和维护系统的花费；<br>提高工程进度和预算的一致性；<br>选择合适的承包者。</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>能力方面：</p><p>通用设施（增强执行过程能力的实现和制度化实施）-&gt; 公共特征（一组实施，管理和制度化过程的相同点 ）-&gt; 能力级别（共同工作的一组公共特征，主要增强执行一个过程的能力 ）<br>能力级别１――非正式执行<br>执行基本实施<br>能力级别２――计划与跟踪<br>计划、规范化、验证、跟踪执行<br>能力级别３――充分定义<br>定义标准过程、执行已定义的过程、协调安全实施<br>能力级别４――定量控制<br>建立可测的质量目标、客观地管理过程的执行<br>能力级别５――连续改进<br>改进组织能力、改进过程的有效性</p><p>域方面：<br>基础设施（工程和安全实施是安全工程过程中必须存在的性质，指出特殊过程区的目的并属于该过程区 ）-&gt; 过程区（每个过程区（PA）是一组相关安全工程过程的性质，当这些性质全部实施后则能达到过程区定义的目的）-&gt; 过程类（一组过程区指出活动的同一通用区）</p><h3 id="关于安全工程与评估"><a href="#关于安全工程与评估" class="headerlink" title="关于安全工程与评估"></a>关于安全工程与评估</h3><p>安全工程分三个基本过程：<strong>风险、工程、保证</strong><br>风险过程：确定产品或者系统的危险性，并对这些危险性进行优先级排序-<label style="color:red">风险信息</label><br>工程过程：针对危险性，安全工程过程与相关过程一起确定并实施解决方案-<label style="color:red">产品/服务</label><br>保证过程：建立起对解决方案的信任，并把这种信任传达给顾客-<label style="color:red">保证论据</label></p><p>SSAM（SSE-CMM评定方法）<br>——决定实施安全工程过程的能力；<br>——定义了安全工程环境便于评定；<br>——评定时巧妙使用了SSE-CMM体系结构中的两个方面。</p><h2 id="SDL安全开发生命周期模型"><a href="#SDL安全开发生命周期模型" class="headerlink" title="SDL安全开发生命周期模型"></a>SDL安全开发生命周期模型</h2><p>微软可信计算努力的一个组成部分<br>基于并行理念的标准软件开发过程<br>基于威胁建模和测试</p><h3 id="SDL概览"><a href="#SDL概览" class="headerlink" title="SDL概览"></a>SDL概览</h3><p>SDL从三个方面考虑软件安全的保障：<br><strong>设计安全</strong>: 保护软件自身及其处理的信息并抵御攻击，应从架构、设计和实现上考虑安全<br><strong>缺省安全</strong>: 设计者应假定安全缺陷将会出现。<br>为了使被攻击时损害降到最小，软件缺省状态应保证安全。比如，最小特权原则。<br><strong>提交安全</strong>: 工具和指南应随软件一起提供以帮助用户安全使用。软件更新应易提交。</p><h3 id="SDL过程"><a href="#SDL过程" class="headerlink" title="SDL过程"></a>SDL过程</h3><ol><li>教育和意识<ol><li>安全设计基础：受攻击面分析、深度防御、最小特权、安全默认配置</li><li>威胁建模：设计威胁建模、编码威胁建模、测试威胁建模</li></ol></li><li>项目启动：SDL覆盖应用，安全顾问及领导团队，BUG标准、BUG追踪中含安全、隐私类BUG</li><li>最佳设计阶段：<ol><li>常见安全设计原则，如最小特权，权限分离、最少公共机制等</li><li>受攻击面分析：枚举所有接口、协议以及可执行代码的过程。</li><li>受攻击面降低：代码中<label style="color:red">一定</label>存在漏洞，部分严重漏洞用户不得不去妥协。唯一解决的方法是<label style="color:red">将代码的利用率降至为零</label>。<br>  受攻击面降低的方法：综合考虑完美的安全与无法规避的风险，尽可能减少未经信任的用户可能接触到的代码比例：<br>  （1）降低默认执行的代码量<br>  （2）限制可访问到代码的人员范围<br>  （3）限定可访问到代码的人员身份<br>  （4）降低代码所需权限。</li></ol></li><li>产品风险评估：<ol><li>安全风险评估：安装、受攻击、移动代码（ActiveX）</li><li>隐私影响分级：分级1：存储或转发个人信息，儿童相关，不间断监控，安装新软件or改变文件类型的关联（改变IPEG解码）。分级2：传输匿名数据 。分级3：其余。</li><li>统一各种因素：确定安全与隐私风险后必须在日程中排出响应时间，减少客户风险。</li></ol></li><li>风险分析/威胁建模：<br> 优点：<br> （1）有助于整个风险管理过程<br> （2）进入编码阶段前发现系统威胁<br> （3）通过威胁建模重新验证其架构与设计<br> （4）进一步明确针对应用及环境采取相应的解决对策<br> （5）指导整个代码审核过程和渗透测试过程<br>  威胁建模过程：<br> （1）定义应用场景、收集外部依赖列表<br> （2）定义安全假设、创建外部安全备注<br> （3）绘制待建模应用的一个或多个数据流图<br> （4）确定威胁类型<br> （5）识别系统威胁、判断风险并规划消减措施</li><li>创建安全文档、工具：安装、使用、帮助、开发文档；禁止端口和不必要服务etc.</li><li>安全编码策略：使用最新版本编译器及其内置防御特性，使用源代码分析工具</li><li>安全测试策略：模糊测试、渗透测试、运行时测试、 重审威胁模型、重估受攻击模型</li><li>最后五个阶段<br> 安全推进活动：代码评审、安全测试、更新威胁模型<br> 最终安全评审：威胁模型评审、未修复安全BUG评审、工具使用有效性验证<br> 安全响应规划：建立安全的响应过程<br> 产品发布阶段：用户验收，确认SDL过程被正确执行<br> 安全响应执行：遵从计划尽可能补救</li></ol><h3 id="SDL缺陷"><a href="#SDL缺陷" class="headerlink" title="SDL缺陷"></a>SDL缺陷</h3><p><label style="color:red">SDL过程不能保证生产出绝对安全的软件</label>：<br>（1）开发团队一定会出错<br>（2）新漏洞一定会变化<br>（3）规则一定会变化</p><h1 id="软件安全测试"><a href="#软件安全测试" class="headerlink" title="软件安全测试"></a>软件安全测试</h1><h2 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h2><p>安全性测试：验证应用程序安全等级and识别潜在安全性缺陷。<br>安全指标不同测试策略不同。<br>目的：查找软件程序设计中的安全隐患and检查应用程序对非法侵入的防范能力。<br>法律问题：安全测试及工具应用必须得到授权；未明确授权下，不允许针对第三方系统进行穿透测试实验</p><h2 id="安全测试方法"><a href="#安全测试方法" class="headerlink" title="安全测试方法"></a>安全测试方法</h2><ol><li>静态测试：对源码进行安全扫描，与特有软件安全规则库匹对，找出潜在安全漏洞。<br> 编码阶段使用，适用早期代码开发阶段，而不是测试阶段。</li><li>动态测试：即<label style="color:red">渗透测试</label>使用自动化工具或人工方法模拟黑客输入进行攻击性测试，找出运行时存在的安全漏洞。<br> 真实有效，问题一般正确且严重。缺点：测试数据只能达有限的测试点，覆盖率低。</li><li>程序数据扫描：进行内存测试，发现许多诸如缓冲区溢出的漏洞，这类漏洞使用其他测试手段都难以发现。</li></ol><p>内容（测试点）：程序安全性测试、数据安全性测试<br>程序安全测试：用户权限、用户冲突、密码保护<br>网络安全测试：防护配置（系统补丁）、模拟非授权共计、检查漏洞、木马、外挂<br>数据安全测试：系统数据的机密性、完整性、管理性、独立性、可备份和恢复能力</p><h2 id="安全的常规测试方法"><a href="#安全的常规测试方法" class="headerlink" title="安全的常规测试方法"></a>安全的常规测试方法</h2><h3 id="基于风险的安全测试"><a href="#基于风险的安全测试" class="headerlink" title="基于风险的安全测试"></a>基于风险的安全测试</h3><p>安全测试目标：给定的时间和资源不变的情况下，尽可能多地找出最严重的安全缺陷。<br>威胁建模＝风险建模</p><ol><li>信息搜集<br>目的：熟悉程序的设计、了解程序访问入口点位置和需要保护的信息<br>（1）评审程序设计文档<br>（2）与设计人员和架构师会谈<br>了解组件框架、组件间主要数据流、程序外数据流（非受信数据，攻击性输入）<br>（3）在运行时用调试和诊断程序分析<br>运行时分析应用程序痕迹：网络端口、文件、注册表键值</li><li>威胁建模<br>目的：排定测试优先级，找出测试区域，发现系统弱点<ol><li>识别威胁路径<br>目的：识别应用程序级别最高的风险领域，确定相应的保护措施<br>（1）了解应用程序平台和编程语言的整体强度<br>（2）确定用户的访问类别<br>（3）建立并分析数据流图</li><li>识别威胁<br>目的：深入识别威胁路径的处理，理清与处理相关的每一种威胁。<br>该组件执行什么样的处理、如何确定身份、是否信任数据或其他组件、修改了什么数据、有何外部连接<br>在一个威胁路径上的9个高风险活动：<br>（1）数据解析、处理私密数据<br>（2）文件访问、数据库访问、网络访问<br>（3）生成子进程、同步或会话管理<br>（4）身份鉴别、授权</li><li>识别漏洞<br>目的：找出可能存在于组件中的实际漏洞。<br>对漏洞的可能缓解措施：<br>（1）数据验证测试<br>（2）资源监视<br>（3）关键功能的访问控制<br>搜寻漏洞的方法及途径：<br>（1）安全设计审查<br>（2）安全代码审查<br>（3）安全测试</li><li>风险分级——DREAD模型</li></ol></li><li>判定可利用性<br>目的：判断漏洞是否可被攻击者利用。<br>基本原则：开发中直接修补一个漏洞比浪费时间判定其是否会被利用容易。</li></ol><h3 id="白盒、黑盒和灰盒测试"><a href="#白盒、黑盒和灰盒测试" class="headerlink" title="白盒、黑盒和灰盒测试"></a>白盒、黑盒和灰盒测试</h3><ol><li>白盒测试可以看作是内部的攻击。<br>测试人员可以访问源代码和设计文档，可以进行威胁建模或逐行的代码检查。<br><strong>白盒测试是找出漏洞最为有效的方法。</strong></li><li>黑盒测试是白盒测试的补充。<br>以局外人身份攻击系统，使用工具检查系统的攻击面，并探查系统的内部信息。<br>方向工程团队利用黑盒测试验证隐蔽式安全方法的强度。</li><li>组合使用白盒测和黑盒测试。<br>白盒测试用于发现在设计和开发中详细说明的功能的缺陷；<br>黑盒测试在无法了解程序内部信息的时候找出缺陷。<br><strong>程序开发中的调试运行是典型的灰盒测试方法。</strong></li></ol><h2 id="安全漏洞分级"><a href="#安全漏洞分级" class="headerlink" title="安全漏洞分级"></a>安全漏洞分级</h2><p><strong>DREAD模型</strong>：进行威胁程度级别分析的有效技术<br>（1）潜在的破坏：如果该漏洞被利用，所产生的破坏程度<br>（2）再现性：探测并利用该漏洞所需要的努力要多久<br>（3）可利用性：是否需要身份鉴别或者特殊的知识<br>（4）受影响的用户：漏洞利用的影响面有多大<br>（5）可发现性：漏洞研究人员或黑客找出该漏洞的可能性<br>基于<label style="color:red">可利用性</label>提出<strong>TRAP模型</strong>：<br>（1）时间：某些漏洞可能需要长时间的探测才能利用。<br>比如解个密要算一千年，那风险肯定很低。<br>（2）可靠性/再现性：漏洞的严重程度依赖于可被攻击者利用的程度。<br>通常高级别漏洞的可靠性和可再现性高。<br>（3）访问：利用漏洞通常可以为攻击者提供更高的访问权。<br>（4）定位：攻击者必须要能与存在漏洞的应用程序交互，并访问到含该漏洞的代码。</p><h1 id="编写安全的代码"><a href="#编写安全的代码" class="headerlink" title="编写安全的代码"></a>编写安全的代码</h1><h2 id="SD3"><a href="#SD3" class="headerlink" title="SD3"></a>SD3</h2><p>Secure by Design, Default, Deployment</p><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><p>（1）安排具体的安全设计人员；进行安全教育；<br>（2）确保威胁分析已经完成；符合安全设计和编码的指导原则；<br>（3）尽可能修补安全编程指南上BUG；确保安全指南是逐步改进的；<br>（4）回归测试已修复缺陷；简化代码和安全模型；打包前完成穿透测试。</p><h3 id="缺省安全"><a href="#缺省安全" class="headerlink" title="缺省安全"></a>缺省安全</h3><p>（1）缺省状态下，不要设置所有的特点和功能；<br>（2）允许最小权限；恰当的资源保护。</p><h3 id="安全提交"><a href="#安全提交" class="headerlink" title="安全提交"></a>安全提交</h3><p>（1）确认程序给管理员提供了安全功能；尽可能提供高质量补丁；<br>（2）提供足够信息使用户安全的使用软件。</p><h2 id="安全规则"><a href="#安全规则" class="headerlink" title="安全规则"></a>安全规则</h2><p>（1）学习错误；最小化攻击面；<br>（2）使用深度防御；应用缺省安全；<br>（3）使用最小权限；基于错误计划；<br>（4）记住兼容性的倒退是痛苦的；<br>（5）假定外部系统是不安全的；<br>（6）<label style="color:red">切记安全的特性不等于安全特性；</label><br>（7）不要混合编码和数据；正确修复安全问题。</p><h3 id="学习错误"><a href="#学习错误" class="headerlink" title="学习错误"></a>学习错误</h3><p>学习错误从填写一个文档开始，文档内容：<br>产品名称；产品版本；联系人；BUG数据库编号；<br>脆弱性描述；脆弱性的隐含意义；<br>在产品的缺省安装中，这个问题是否存在？<br>设计，开发和测试人员能够做什么来防止这个缺陷？<br>修复的细节，包括代码的区别，如果可以填写。</p><h3 id="最小化攻击面"><a href="#最小化攻击面" class="headerlink" title="最小化攻击面"></a>最小化攻击面</h3><p>需要计算下面的内容：<br>（1）打开socket、命名管道、RPC端点的数量；<br>（2）服务的数量；缺省运行服务的数量；服务以提高权限运行的数量；<br>（3）ISAPI过滤器和应用的数量；动态WEB页面数量；加入管理员组帐号的数量；<br>（4）文件，目录和注册键值的数量，带有弱访问控制列表。</p><h1 id="一个信息系统的安全模型分析"><a href="#一个信息系统的安全模型分析" class="headerlink" title="一个信息系统的安全模型分析"></a>一个信息系统的安全模型分析</h1><h2 id="信息系统MIS及其特征"><a href="#信息系统MIS及其特征" class="headerlink" title="信息系统MIS及其特征"></a>信息系统MIS及其特征</h2><p>借助自动化数据处理手段进行管理的系统<br>由计算机硬件、软件<font size="2">（系统软件、应用软件、管理学软件包）</font>、数据库规程和人共同组成。</p><p>由人、计算机等组成的能进行管理信息的收集、传递、加工的信息系统。<br><strong>主要特征：</strong><br>（1）一定是依赖于计算机的；<br>（2）涉及了计算机的软件和硬件；<br>（3）实现数据的采集、传递、加工、处理功能。<br><strong>主要特性：</strong><br>（1）整体性：系统各部分一定以整体目标为目标，追求全局最优；<br>（2）目的性：一个系统一定具有明确目的标，并完成一定的功能；<br>（3）层次性：一个系统可分为若干层次和子系统；<br>（4）边界性：每个系统明显区别于其他系统，系统间有明确界限；<br>（5）关联性：系统包括若干元素，元素间存在一定关联性；<br>（6）环境性：系统处于一定的环境之中并受环境影响。<br><strong>主要类型：</strong><br>宏观的国家经济信息系统；面向基层的企事业管理信息系统；<br>事务型管理信息系统；办公型管理信息系统；专业型管理信息系统等；<br><strong>运行环境要素：</strong><br>（1）物理世界；<br>（2）管理者实体：拥有授权管理、变更、修复和使用系统的人或其他系统<br>其中一些被授权人可能缺乏有效管理系统的能力或具有恶意的目的；<br>（3）使用者：在使用界面接受系统服务的实体；<br>（4）提供者：在系统使用界面提供服务的实体；<br>（5）基础组织：对系统提供信息源、通信链接、能源、冷气等特定服务的实体；<br>（6）入侵者：企图超越其权限来变更或阻止服务，变更系统功能、性能或存取秘密信息的实体。</p><h2 id="信息系统的安全问题"><a href="#信息系统的安全问题" class="headerlink" title="信息系统的安全问题"></a>信息系统的安全问题</h2><p>ISO7498-2五种安全服务类型：<br>（1）身份鉴别；<br>（2）访问控制；<br>（3）数据保密；<br>（4）数据完整性；<br>（5）抗抵赖。</p><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>系统的使用者划分为：用户、系统管理员、信息主管（或企业主管）<br>系统划分为：用户界面逻辑、业务逻辑、异常检测机<br>系统安全功能：访问控制；抗抵赖；数据保密；身份鉴别；授权机制；日志审计；系统异常探测。</p><h3 id="用户界面逻辑"><a href="#用户界面逻辑" class="headerlink" title="用户界面逻辑"></a>用户界面逻辑</h3><p>用户界面逻辑部分：数据访问、登录控制。<br>系统启动时，用户首先登录系统，通过验证后才能数据访问。<br>登录控制主要功能：口令验证；口令修改；口令数据的加密；登录时间记录。<br>登录控制设计考虑：<br>（1）用户ID：从权限数据中提取相应用户名，回避重名，简化输入<br>用户号本身也可以增加一定的安全性。<br>（2）用户修改口令，<label style="color:red">而非系统管理员</label>：管理员授权，但口令由用户输入加密存到后端<br>避免系统管理员获取用户口令造成泄密。<br>（3）初始口令的安全：系统初次运行关键——初始口令的赋予，由信息主管（或其他高层）完成用户身份确认<br>要求用户初次登录时必须更改初始口令。<br>（4）口令安全：口令长度限制、字符集限制、有效期限制。<br>（5）用户封锁：用户多次登录失败后系统锁定用户操作，解锁必须由系统管理员完成。</p><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>业务逻辑部分：<br>（1）数据服务：完成特定数据的加密、解密，日志数据的存储，权限及用户信息的存储<br>（2）权限管理：完成用户的授权，包括两个部分：系统管理员和信息主管。<br>系统管理员负责日常权限管理、日志审计、系统状态监控、异常监测、用户锁定处理。<br>信息主管负责系统启动和初始授权。<br>（3）日志审计：对用户的操作行为进行跟踪，提供根据时间、用户、系统的检索手段。<label style="color:red">日志不能人工清除</label>，怕被管理员在后台清掉。log周期性自动清旧信息，保留最新信息。<br><strong>信息系统提高安全可信性的重要手段</strong>：合理并具有一定强度的日志设计。</p><h3 id="异常探测机"><a href="#异常探测机" class="headerlink" title="异常探测机"></a>异常探测机</h3><p>主要功能：分析日志、网络状态的安全监测、提供一定的日志文件保护机制<br>异常检测独立于业务逻辑的目的：<br>（1）独立程序便于进一步发展，有较大发展空间；<br>（2）位于业务和用户进程之外，能对其进行监控；<br>（3）不对信息系统运行发生干扰；<br>（4）作为系统的可选件而非强制。</p><h2 id="异常行为探测"><a href="#异常行为探测" class="headerlink" title="异常行为探测"></a>异常行为探测</h2><div class="table-container"><table><thead><tr><th style="text-align:center">区别内容</th><th style="text-align:center">异常探测机</th><th style="text-align:center">IDS</th></tr></thead><tbody><tr><td style="text-align:center">检测范围</td><td style="text-align:center">网络内部行为</td><td style="text-align:center">网络外部行为</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">软件</td><td style="text-align:center">硬件</td></tr><tr><td style="text-align:center">与系统关系</td><td style="text-align:center">可以存取系统数据</td><td style="text-align:center">不能存取系统数据</td></tr><tr><td style="text-align:center">保护目标</td><td style="text-align:center">信息系统</td><td style="text-align:center">网路</td></tr></tbody></table></div><h3 id="异常行为"><a href="#异常行为" class="headerlink" title="异常行为"></a>异常行为</h3><p>用户身份的攻击：针对用户的ID猜测用户身份。采用ID登录原因：方便输入&amp;安全性。猜测三次后用户被封锁。<br>口令攻击：已知用户身份来猜测口令。在系统设计中，当猜测三次后则封锁用户。<br>服务器异常访问：Sever PC和Web Sever等专用服务程序。类似局域网内DOS攻击。<br>数据库异常连接：主要通过特定端口访问DB，威胁来自<label style="color:red">合法或非法</label>的客户端程序。</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><h4 id="针对日志文件自身的攻击"><a href="#针对日志文件自身的攻击" class="headerlink" title="针对日志文件自身的攻击"></a>针对日志文件自身的攻击</h4><p>（1）日志数据的删除：系统不向用户提供日志修改功能。<br>合法用户不具有删除log的能力，只有超过log过期时间的日志数据才可删除。<br>非法用户受到异常探测机、操作系统、数据库系统的安全机制约束。<br>针对非法用户的攻击——<br>如果是单独的log，当系统启动后，该文件置于异常探测机的保护之下；<br>如果是数据库数据，则依赖于操作系统和数据库本身的保护机制。<br>（2）日志数据的修改：系统不向用户提供日志修改功能。<br>日志浏览需要授权，当系统管理员身份浏览日志时，该操作本身也将被写入日志。<br>由于单独的日志文件置于异常探测机的保护之下，所以可以避免合法用户的修改。<br>非法用户试图修改数据库中日志数据时，会受到操作系统和数据库系统的约束。</p><h4 id="日志数据审计和异常模式"><a href="#日志数据审计和异常模式" class="headerlink" title="日志数据审计和异常模式"></a>日志数据审计和异常模式</h4><p>（1）手动审计：提供必要的数据检索和查询的手段<br>可根据用户、授权人、时间段、功能等进行检索，以进行必要的分析和事件跟踪。<br>（2）自动审计和报警：根据日志数据，系统可自动完成的审计和报警功能<br>用户锁定；口令超期；异常时间访问；异常功能访问；异常授权</p><h3 id="网络异常探测机"><a href="#网络异常探测机" class="headerlink" title="网络异常探测机"></a>网络异常探测机</h3><p>网络异常探测机：针对来自网络的信息进行分析，提供对信息系统的保护报警。<br>探测器并不是通用的系统异常探测器。<br>（1）数据流量检测；<br>（2）服务器连接异常：连接数量异常、连接主机异常、连接端口异常。<br>（3）文件访问限制；<br>（4）日志文件保护。</p><h1 id="WEB应用安全"><a href="#WEB应用安全" class="headerlink" title="WEB应用安全"></a>WEB应用安全</h1><h2 id="WEB-APPLICATION"><a href="#WEB-APPLICATION" class="headerlink" title="WEB APPLICATION"></a>WEB APPLICATION</h2><p>采用HTTP协议完成通信<br>与后台WEB Server实现交互<br>与互联网服务器，包括Web Server，database server进行交互<br>位于中间层，进行数据交互或其他服务程序</p><p>WEB应用安全现状：<br>WEB应用安全实现非常困难<br>WEB应用环境包括多个系统<br>WEB应用大部分运行于INTERNET，具有更广的攻击面<br>WEB应用运行中，具有更多的临时决策以支持系统的运行，系统状态具有更多的可变性<br>许多支持系统没有得到恰当的保护</p><h2 id="微软WEB应用安全框架"><a href="#微软WEB应用安全框架" class="headerlink" title="微软WEB应用安全框架"></a>微软WEB应用安全框架</h2><h3 id="WEB应用安全建模"><a href="#WEB应用安全建模" class="headerlink" title="WEB应用安全建模"></a>WEB应用安全建模</h3><p>活动：Web 应用程序的威胁建模<br>目的：确定方案中相关威胁和漏洞，以帮助构建应用程序的安全设计。<br>输入： 主要用例和使用方案 、数据流 、数据架构 、部署关系图<br>输出： 威胁列表 、漏洞列表 </p><p>威胁建模：<br>步骤 1 ：确定安全目标。业务需求、安全策略、兼容性要求 -&gt; 主要安全目标<br>步骤 2 ：创建应用程序概述。列出重要特征和参与者有助于步骤 4 确定威胁。<br>步骤 3 ：分解应用程序。<br>部署关系图、用例、功能说明、数据流关系图 -&gt; 信任边界、入口点、出口点、数据流<br>（在网络层，每个服务代表了一个入口点）<br>步骤 4 ：确定威胁。使用步骤2&amp;3中的详细信息来确定相关威胁。<br>步骤 5 ：确定漏洞。检查应用程序的各层以确定与威胁有关的弱点。<br>使用漏洞类别来帮助关注最常出现错误的区域。 </p><p>输入验证：在进行其他处理前如何筛选、删除或拒绝输入<br>身份验证：一个实体验证另一个实体身份的过程，通过如用户名和密码的凭据进行<br>授权：提供对资源和操作的访问控制的方式<br>配置管理：处理运行身份、数据库连接、应用程序管理、设置保护<br>敏感数据：处理必须受到保护的所有数据，不管数据在内存、网络还是永久性存储中<br>会话：用户与Web 应用程序之间的一系列相关交互<br>加密：应用程序保证机密性和完整性的方式<br>参数操作：既指保护这些值不被篡改的方式，也指处理输入参数的方式<br>审核与记录：记录与安全相关的事件的方式</p><h2 id="一个WEB应用安全模型"><a href="#一个WEB应用安全模型" class="headerlink" title="一个WEB应用安全模型"></a>一个WEB应用安全模型</h2><p>威胁建模：一种用于理解和消除系统安全威胁的形式化的方法<br>（1）信息收集：定位文档、访问相关人员、探查系统<br>（2）分析：用户、构件，资产，动机、入口、弱点和威胁<br>（3）威胁消除：建立预算、排序处理、确立针对威胁的工作<br>消除的选择：大概率会忽略，毕竟入侵代价昂贵、安全代价昂贵，搞不好不能承受<br>消除的策略：移除入口点、减少攻击面、区分、最小优先权原则<br>消除的技巧：<br>1.建立子模型分支来减小复杂性<br>2.开发可重用的威胁模型库<br>3.先不做假定，消除多数明显的威胁会大大简化</p><h1 id="一个安全工程过程模型"><a href="#一个安全工程过程模型" class="headerlink" title="一个安全工程过程模型"></a>一个安全工程过程模型</h1><h2 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h2><p>1.安全目标定义：形成规范的文档，作为工程过程中的指导原则<br>2.敏感数据分析：确定涉及的敏感数据并分类，给出明确定义、敏感程度和保护措施<br>3.威胁分析：确定系统威胁来源，明确关键工程，部署，各部分及功能用户<br>4.安全设计：根据前三部分实现安全设计。包括架构，安全问题应对措施等<br>5.受攻击面分析：与安全设计对应，根据架构及敏感信息，对受攻击面<br>（端口，数据，文件）及攻击路径进行分析<br>6.安全实现：掌握安全实现方法，库及安全编码原则。针对安全目标，敏感数据，明确威胁的主要应对措施。<br>7.安全测试<br>8.安全维护</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一门针对安全过程模型、基于风险测试、威胁分析报告等谈漏洞讲威胁的学科。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://stardust567.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="软件安全" scheme="https://stardust567.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>System Call</title>
    <link href="https://stardust567.github.io/post/22713.html"/>
    <id>https://stardust567.github.io/post/22713.html</id>
    <published>2019-03-18T09:33:13.000Z</published>
    <updated>2020-05-02T09:00:56.133Z</updated>
    
    <content type="html"><![CDATA[<p>Linux内核中设置了一组用于实现各种系统功能的子程序，称为<em>系统调用（system call）</em>。同时它还提供些C语言函数库，这些库对系统调用进行包装和扩展。由于这些库函数与系统调用的关系非常紧密，习惯上把这些函数也称为系统调用。<em>本文是作者在大二写OS作业时整理的，安利文章<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part3/index.html" target="_blank" rel="noopener">系统调用跟我学</a>这篇写得真的很舒服，本文很多内容都源于此。</em><br><a id="more"></a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统资源分配的最小单位，由程序段数据段+PCB组成。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>系统中的每个进程都运行在某个进程的上下文中。上下文是由程序正确运行的所需的状态组成的。这个状态包括放在内存中的程序代码和数据，栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符。</p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>每个程序都有一片完整连续的逻辑地址空间，这些逻辑空间映射到离散的物理空间。在程序的运行过程，完成虚拟地址到物理地址的转换。进程的地址空间是分段的，存在所谓的数据段，代码段，bbs段，堆，栈等等。</p><p>对32位机器来说，虚拟的地址空间大小就是4G，可能实际物理内存大小才1G到2G（请回想虚拟内存知识点） </p><ul><li>从0xc000000000到0xFFFFFFFF共1G的大小是内核地址空间，余下的低地址3G空间则是用户地址空间。</li><li>Code VMA: 程序的代码段，CPU执行的机器指令部分。通常，这一段是可以共享的，即多线程共享进程的代码段。并且，此段是只读的，不能修改。</li><li>Data VMA: 程序的数据段，包含已初始化的全局和静态变量data段和未初始化的全局和静态变量bss段。</li><li>堆和栈: new或者malloc分配的空间在堆上，需要编程者维护，若没有主动释放堆上的空间，进程运行结束后会被释放。栈上的是函数栈临时的变量，还有程序的局部变量，自动释放。</li><li>共享库和mmap内容映射区：位于栈和堆之间，例如程序使用printf，函数共享库printf.o固定在某个物理内存位置上，让许多进程映射共享。mmap是一个系统函数，可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址。</li><li>命令行参数: 程序的命令行参数</li><li>环境变量：类似于Linux下的PATH，HOME等环境变量，子进程会继承父进程的环境变量。</li></ul><p><img src="https://i.loli.net/2020/04/25/RN7MsZekKYIGiwr.png" alt="OS系统调用_process_address_space.png"></p><h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p>在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程无法预测子进程什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或waitpid()系统调用取得子进程的终止状态。</p><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被系统init进程(pid=1)所收养，并由init进程对它们完成状态收集工作。</p><p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是运行在进程上下文的逻辑流。线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程，所以线程的粒度比进程小，线程由内核调度，也有自己的线程上下文，包括一个唯一的整数线程ID, 栈和栈指针，程序计数器，通用目的寄存器和条件码。但是，所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p><h3 id="内存空间-1"><a href="#内存空间-1" class="headerlink" title="内存空间"></a>内存空间</h3><p>每个线程独立的线程上下文：一个唯一的整数线程ID, 栈和栈指针，程序计数器，通用目的寄存器和条件码。</p><p>和其他线程共享的进程上下文的剩余部分：整个用户虚拟地址空间，那就是上图的只读代码段，读/写数据段，堆以及所有的共享库代码和数据区域，也共享所有打开文件的集合。</p><p>线程的寄存器是不共享的，通常栈区是被相应线程独立访问的，但可能出现一个线程去访问另一个线程中的栈区的情况。这是因为这个线程获得了指向另一个线程栈区的指针，那么它就可以读写这个栈的任何部分。</p><h4 id="线程崩溃"><a href="#线程崩溃" class="headerlink" title="线程崩溃"></a>线程崩溃</h4><p>线程有自己的 stack，但是没有单独的 heap 和 address space。只有进程有自己的 address space，而这个 space 中经过合法申请的部分叫做 process space。Process space 之外的地址都是非法地址。当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。</p><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>当一个程序启动时，就有一个进程被操作系统创建，与此同时一个线程也立刻运行，该线程为程序的<strong>主线程</strong>（Main Thread）。它是程序开始时就执行的，之后创建的线程都是这个主线程的子线程。每个进程至少都有一个主线程，如main函数。</p><p>线程不像进程，一个进程中的线程之间没有父子之分，都是平级关系。理论上，某个线程的退出不会影响其他线程。但是当main执行完之后，return会使编译器调用进程退出的代码exit()，exit() 会让整个进程over终止，那所有线程自然都会退出。</p><p>exit() 会让整个进程over终止，那所有线程自然都会退出。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程Coroutine，作用是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行。协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。</p><p>一个线程可以拥有多个协程。协程不被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</p><p>比如python中的<code>yield</code>就是个经典的使用协程的例子，执行到<code>yield</code>后将暂停在这里，直到下一次被启动。</p><h1 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h1><p>一般情况下进程不能访问内核所占内存也不能调用内核函数，但有一般就会有例外，系统调用就是例外。它的原理是进程先用适当的值填充寄存器，然后调用一个特殊的指令，该指令会跳到事先定义的内核中的一个位置<em>（该位置用户进程可读但不可写）</em>。<br>Intel CPU中，这个由中断0x80实现。硬件知道一旦你跳到<em>这个位置（system_call）</em>，你就不再是限制模式下运行的用户，而“成为”了操作系统的内核<del>接下来你就可以为所欲为</del>。这个过程会检查系统调用号，该号码告诉内核进程请求哪种服务。然后查看<em>系统调用表(sys_call_table)</em>找到所调用的内核函数入口地址。接着调用函数，等返回后做一些系统检查，最后返回到进程（或到其他进程，如果这个进程时间用尽）。</p><p><strong>进程是可并发执行的程序在一个数据集合上的运行过程。</strong></p><p>为防止和正常的返回值混淆，系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。若系统调用失败，可以读出errno的值来锁定问题。errno不同数值所代表的错误消息定义在errno.h中，可以通过命令<code>man 3 errno</code>来察看它们。<br>需要注意的是，errno的值只在函数发生错误时设置，如果函数不发生错误，errno的值就无定义，并不会被置为0。另外，在处理errno前最好先把它的值存入另一个变量，因为在错误处理过程中，即使像printf()这样的函数出错时也会改变errno的值。</p><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h2><p>在2.4.4版内核中，getpid是第20号系统调用，其在Linux函数库中的原型是：</p><blockquote><p><code>#include&lt;sys/types.h&gt; /* 提供类型pid_t的定义 */</code><br><code>#include&lt;unistd.h&gt; /* 提供函数的定义 */</code><br><code>pid_t getpid(void);</code></p><p>getpid的作用很简单，就是返回当前进程的进程ID<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The current process ID is %d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The current process ID is 1980</p><p><em>注意，该程序的定义里并没包含头文件sys/types.h，这是因为我们在程序中没有用到pid_t类型，pid_t类型即为进程ID的类型。事实上，在i386架构上（就是我们一般PC计算机的架构），pid_t类型是和int类型完全兼容的，我们可以就把它当做个整形，比如用”%d”把它打印出来。</em></p></blockquote><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>在2.4.4版内核中，fork是第2号系统调用，其在Linux函数库中的原型是：</p><blockquote><p><code>#include&lt;sys/types.h&gt; /* 提供类型pid_t的定义 */</code><br><code>#include&lt;unistd.h&gt; /* 提供函数的定义 */</code><br><code>pid_t fork(void);</code></p><p>fork系统调用的作用是复制一个进程。当一个进程调用它，完成后就出现两个几乎一模一样的进程，我们也由此得到了一个新进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;    </span><br><span class="line">    <span class="comment">/*此时仅有一个进程*/</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="comment">/*此时已经有两个进程在同时运行*/</span></span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"I am the child process, my process ID is %d\n"</span>,getpid());</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"I am the parent process, my process ID is %d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>I am the parent process, my process ID is 1991<br>I am the child process, my process ID is 1992</p><p>看这个程序的时候，头脑中必须首先了解一个概念：在语句pid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的代码部分完全相同，将要执行的下一条语句都是if(pid==0)<br>两个进程中，原先就存在的那个被称作“父进程”，新出现的那个被称作“子进程”。父子进程的区别除了进程标志符PID不同外，变量pid的值也不相同，pid存放的是fork的返回值。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值(当前的进程数已经达到了系统规定的上限<em>这时errno的值被设置为EAGAIN</em>或系统内存不足<em>这时errno的值被设置为ENOMEM</em>）。</li></ol></blockquote><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p><em>Question</em>:既然所有新进程都是由fork产生的，而且由fork产生的子进程和父进程几乎完全一样，那岂不是意味着系统中所有的进程都应该一模一样了吗？而且，就我们的常识来说，当我们执行一个程序的时候，新产生的进程的内容应就是程序的内容才对。是我们理解错了吗？<br>实际上在Linux中，exec指的是一组函数，一共有6个，分别是：</p><blockquote><p><code>#include &lt;unistd.h&gt;</code><br><code>int execl(const char *path, const char *arg, ...);</code><br><code>int execlp(const char *file, const char *arg, ...);</code><br><code>int execle(const char *path, const char *arg, ..., char *const envp[]);</code><br><code>int execv(const char *path, char *const argv[]);</code><br><code>int execvp(const char *file, char *const argv[]);</code><br><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></p><p><em>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</em></p></blockquote><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。</p><p>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。</p><p>现在我们应该明白了，Linux下是如何执行新程序的，每当有进程认为自己不能为系统和拥护做出任何贡献了，他就可以发挥最后一点余热，调用任何一个exec，让自己以新的面貌重生；或者，更普遍的情况是，如果一个进程想执行另一个程序，它就可以fork出一个新进程，然后调用任何一个exec，这样看起来就好像通过执行应用程序而产生了一个新进程一样。</p><p>事实上第二种情况被应用得如此普遍，以至于Linux专门为其作了优化，我们已经知道，fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，这些辛辛苦苦拷贝来的东西又会被立刻抹掉，这看起来非常不划算，于是人们设计了一种<em>写时拷贝（copy-on-write）</em>技术<code>vfork()</code>，使得fork结束后并不立刻复制父进程的内容，而是复制相关指针，等到了真正实用的时候才复制指向的内容，这样如果下一条语句是exec，它就不会白白作无用功了，也就提高了效率。</p><p>在学习它们之前，先来了解一下我们习以为常的main函数。</p><blockquote><p><code>int main(int argc, char *argv[], char *envp[])</code></p><p>参数argc指出了运行该程序时命令行参数的个数，数组argv存放了所有的命令行参数，数组envp存放了所有的环境变量。环境变量指的是一组值，从用户登录后就一直存在，很多应用程序需要依靠它来确定系统的一些细节，我们最常见的环境变量是PATH，它指出了应到哪里去搜索应用程序，如/bin；HOME也是比较常见的环境变量，它指出了我们在系统中的个人目录。环境变量一般以字符串”XXX=xxx”的形式存在，XXX表示变量名，xxx表示变量的值。</p></blockquote><p>值得一提的是，argv数组和envp数组存放的都是指向字符串的指针，这两个数组都以一个NULL元素表示数组的结尾。</p><p>我们可以通过以下这个程序来观看传到argc、argv和envp里的都是什么东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n### ARGC ###\n%d\n"</span>, argc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n### ARGV ###\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(*argv)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *(argv++));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n### ENVP ###\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(*envp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *(envp++));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>cc main.c -o main</code>然后运行，故意加几个没有任何作用的命令行参数<code>./main -xx 000</code> </p><blockquote><p>### ARGC ###<br>3<br>### ARGV ###<br>./main<br>-xx<br>000<br>### ENVP ###<br>PWD=/home/lei<br>REMOTEHOST=dt.laser.com<br>HOSTNAME=localhost.localdomain<br>QTDIR=/usr/lib/qt-2.3.1<br>LESSOPEN=|/usr/bin/lesspipe.sh %s<br>KDEDIR=/usr<br>USER=lei<br>LS_COLORS=<br>MACHTYPE=i386-redhat-linux-gnu<br>MAIL=/var/spool/mail/lei<br>INPUTRC=/etc/inputrc<br>LANG=en_US<br>LOGNAME=lei<br>SHLVL=1<br>SHELL=/bin/bash<br>HOSTTYPE=i386<br>OSTYPE=linux-gnu<br>HISTSIZE=1000<br>TERM=ansi<br>HOME=/home/lei<br>PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/lei/bin<br>_=./main</p></blockquote><p>我们看到，程序将”./main”作为第1个命令行参数，所以共有3个命令行参数。这可能与平时习惯的说法有些不同。<br>现在回过头来看一下exec函数族，先把注意力集中在execve上：</p><blockquote><p><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></p></blockquote><p>对比一下main函数的完整形式，就会发现这两个函数里的argv和envp是完全一一对应的关系。execve第1个参数path是被执行应用程序的完整路径，第2个参数argv就是传给被执行应用程序的命令行参数，第3个参数envp是传给被执行应用程序的环境变量。<br>留心看一下这6个函数还可以发现，前3个函数都是以execl开头的，后3个都是以execv开头的，它们的区别在于，execv开头的函数是以”char *argv[]”这样的形式传递命令行参数，而execl开头的函数采用了我们更容易习惯的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是一样的。</p><p>在全部6个函数中，只有execle和execve使用了char *envp[]传递环境变量，其它的4个函数都没有这个参数，这并不意味着它们不传递环境变量，这4个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而execle和execve会用指定的环境变量去替代默认的那些。</p><p>还有2个以p结尾的函数execlp和execvp，咋看起来，它们和execl与execv的差别很小，事实也确是如此，除execlp和execvp之外的4个函数都要求，它们的第1个参数path必须是一个完整的路径，如”/bin/ls”；而execlp和execvp的第1个参数file可以简单到仅仅是一个文件名，如”ls”，这两个函数可以自动到环境变量PATH制定的目录里去寻找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *envp[]=&#123;<span class="string">"PATH=/tmp"</span>,</span><br><span class="line">            <span class="string">"USER=lei"</span>,</span><br><span class="line">            <span class="string">"STATUS=testing"</span>,</span><br><span class="line">            <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *argv_execv[]=&#123;<span class="string">"echo"</span>, <span class="string">"excuted by execv"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *argv_execvp[]=&#123;<span class="string">"echo"</span>, <span class="string">"executed by execvp"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *argv_execve[]=&#123;<span class="string">"env"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execl(<span class="string">"/bin/echo"</span>, <span class="string">"echo"</span>, <span class="string">"executed by execl"</span>, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execl"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">"echo"</span>, <span class="string">"echo"</span>, <span class="string">"executed by execlp"</span>, <span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execlp"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execle(<span class="string">"/usr/bin/env"</span>, <span class="string">"env"</span>, <span class="literal">NULL</span>, envp)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execle"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execv(<span class="string">"/bin/echo"</span>, argv_execv)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execv"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execvp(<span class="string">"echo"</span>, argv_execvp)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execvp"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(execve(<span class="string">"/usr/bin/env"</span>, argv_execve, envp)&lt;<span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Err on execve"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序里调用了2个Linux常用的系统命令，echo和env。echo会把后面跟的命令行参数原封不动的打印出来，env用来列出所有环境变量。</p><p>由于各个子进程执行的顺序无法控制，所以有可能出现一个比较混乱的输出—各子进程打印的结果交杂在一起，而不是严格按照程序中列出的次序。</p><blockquote><p>executed by execl<br>PATH=/tmp<br>USER=lei<br>STATUS=testing<br>executed by execlp<br>excuted by execv<br>executed by execvp<br>PATH=/tmp<br>USER=lei<br>STATUS=testing</p><p>果然不出所料，execle输出的结果跑到了execlp前面。</p></blockquote><p>在平时的编程中，如果用到了exec函数族，一定记得要加错误判断语句。因为与其他系统调用比起来，exec很容易受伤，被执行文件的位置，权限等很多因素都能导致该调用的失败。最常见的错误是：</p><ul><li>找不到文件或路径，此时errno被设置为ENOENT；</li><li>数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；</li><li>没有对要执行文件的运行权限，此时errno被设置为EACCES。</li></ul><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>在2.4.4版内核中，exit是第1号调用，其在Linux函数库中的原型是：</p><blockquote><p><code>#include&lt;stdlib.h&gt;</code><br><code>void exit(int status);</code></p><p>这个系统调用是用来终止一个进程的。无论在程序中的什么位置，只要执行到exit系统调用，进程就会停止剩下的所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this process will exit!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"never be displayed!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this process will exit!</p><p>进程在<code>exit(0)</code>处直接终止，并不会打印后面的printf。exit带有一个整型的参数status，可以用这个参数传递进程结束时的状态，比如正常结束的为0。</p></blockquote><h2 id="exit-1"><a href="#exit-1" class="headerlink" title="_exit"></a>_exit</h2><p>_exit在Linux函数库中的原型是：</p><blockquote><p><code>#include&lt;unistd.h&gt;</code><br><code>void _exit(int status);</code></p><p>和exit比较一下，<code>exit()</code>函数定义在stdlib.h中，而<code>_exit()</code>定义在unistd.h中。<br>但两者真正的区别在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，也就是所谓的“清理I/O缓冲”。<br>举个例子，如果同样的两行printf，加上不同的终止调用，会发生什么：<br><code>main(){</code><br><code>printf(&quot;output begin\n&quot;);</code><br><code>printf(&quot;content in buffer&quot;);</code><br><code>exit(0); # _exit(0);</code><br><code>}</code></p><p><code>exit(0)</code>会完成两句printf,但<code>_exit(0)</code>可能完成第一句printf就终止了。这应该不难理解，系统先把前两个printf存入buff，然后一边I/O一边往后执行，如果是<code>_exit(0)</code>不管缓存死活，那就直接结束了啊。<br>但是exit后的进程并不是就灰飞烟灭了，它有个让人毛骨悚然的名字，<em>僵尸进程（Zombie）</em></p></blockquote><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>下面简单介绍下进程的状态：分linux内核代码定义的状态和常用状态。<br>由Linux内核代码宏定义出的“TASK_REPORT”：</p><blockquote><p><code>/* get_task_state() */</code><br><code>#define TASK_REPORT    (TASK_RUNNING | TASK_INTERRUPTIBLE |</code><br><code>TASK_UNINTERRUPTIBLE | __TASK_STOPPED |&gt;</code><br><code>__TASK_TRACED | EXIT_ZOMBIE | EXIT_DEAD)</code></p><p>可以得到七个基本的进程状态，即：<br><strong>R运行状态TASK_RUNNING</strong>进程要么正在执行，要么正要准备执行。<br><strong>S可中断睡眠状态TASK_INTERRUPTIBLE</strong>进程被阻塞，直到某个条件变为真。条件一旦达成，进程的状态就被设置为TASK_RUNNING。<br><strong>D不可中断睡眠状态TASK_UNINTERRUPTIBLE</strong>进程不会立即响应信号。这种状态一般用于内核某些不能被打断的进程，比如等待磁盘或网络I / O的设备驱动程序使用。<br><strong>T停止状态__TASK_STOPPED</strong>可以通过发送SIGSTOP信号给进程来停止进程，可以发送SIGCONT信号让进程继续运行<br><strong>t追踪状态__TASK_TRACED</strong>进程被debugger等进程监视。处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。<br><strong>Z僵尸状态EXIT_ZOMBIE</strong>进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息。此时进程几乎的所有资源将被回收，没有任何可执行代码，也不能被调度，仅留下task_struct结构（以及少数资源）记载了些供人凭吊的信息。<br><strong>X死亡状态EXIT_DEAD</strong>进程的最终状态，即将被销毁，ls都没了的那种。<br>常用的状态转换图：<br><img src="https://i.loli.net/2019/03/18/5c8fa09144527.jpg" alt=""></p></blockquote><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait的函数原型是：</p><blockquote><p><code>#include &lt;sys/types.h&gt; /* 提供类型pid_t的定义 */</code><br><code>#include &lt;sys/wait.h&gt;</code><br><code>pid_t wait(int *status)</code></p><p>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。<br>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉（多数情况如此），我们就可以设定这个参数为NULL:<code>pid = wait(NULL);</code>如果成功，wait会返回被收集的子进程的PID，如果调用进程没有子进程，调用就会失败，此时wait返回-1<em>errno被置为ECHILD</em>。<br>如果想知道status，那就准备个int指针，也可以<code>int status</code>然后传<code>wait(&amp;status)</code>这时就可以调用专门的<em>宏（macro）</em>来获取信息：</p><ol><li>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</li><li>WEXITSTATUS(status) 这个宏用来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5<em>（注意，如果进程不是正常退出的，也就是说，WIFEXITED返回0，这个值就毫无意义）</em></li></ol></blockquote><h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>waitpid的函数原型是：</p><blockquote><p><code>#include &lt;sys/types.h&gt; /* 提供类型pid_t的定义 */</code><br><code>#include &lt;sys/wait.h&gt;</code><br><code>pid_t waitpid(pid_t pid,int *status,int options)</code></p><p>just多了pid和options两个参数：</p><ul><li>参数 pid 为欲等待的子进程的识别码：<ul><li>pid &lt; -1 ；等待进程组 ID 为 pid 绝对值的进程组中的任何子进程；</li><li>pid = -1 ；等待任何子进程，此时 waitpid() 相当于 wait()。实际上，wait()就是 pid = -1、options = 0 的waitpid()</li><li>pid = 0 ；等待进程组 ID 与当前进程相同的任何子进程（也就是等待同一个进程组中的任何子进程）；</li><li>pid &gt; 0 ；等待任何子进程 ID 为 pid 的子进程，只要指定的子进程还没有结束，waitpid() 就会一直等下去。</li></ul></li><li>参数 options提供一些额外的选项来控制 waitpid()：<ul><li>WNOHANG；如果没有任何已经结束了的子进程，则马上返回，不等待；</li><li>WUNTRACED；如果子进程进入暂停执行的情况，则马上返回，但结束状态不予理会；</li><li>也可以将这两个选项组合起来使用，使用 OR 操作</li><li>如果不想使用这两个选项，也可以直接把 options 设为0，则 waitpid() 会一直等待，直到有进程退出</li></ul></li><li>waitpid()的返回值，有三种：<ul><li>正常返回时，waitpid() 返回收集到的子进程的PID；</li><li>如果设置了 WNOHANG，而调用 waitpid() 时，没有发现已退出的子进程可收集，则返回0；</li><li>如果调用出错，则返回 -1，这时erron 会被设置为相应的值以指示错误所在。（当 pid 所指示的子进程不存在，或此进程存在，但不是调用进程的子进程， waitpid() 就会返回出错，这时 erron 被设置为 ECHILD）</li></ul></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pc, pr;</span><br><span class="line">         </span><br><span class="line">    pc=fork();</span><br><span class="line">    <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)     <span class="comment">/* 如果fork出错 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error occured on forking.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc==<span class="number">0</span>)&#123;     <span class="comment">/* 如果是子进程 */</span></span><br><span class="line">        sleep(<span class="number">10</span>);  <span class="comment">/* 睡眠10秒 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果是父进程 */</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        pr=waitpid(pc, <span class="literal">NULL</span>, WNOHANG);  <span class="comment">/* WNOHANG参数:waitpid不会在这等待 */</span></span><br><span class="line">        <span class="keyword">if</span>(pr==<span class="number">0</span>)&#123;          <span class="comment">/* 如果没有收集到子进程 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No child exited\n"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(pr==<span class="number">0</span>);              <span class="comment">/* 没有收集到子进程，就回去继续尝试 */</span></span><br><span class="line">    <span class="keyword">if</span>(pr==pc)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"successfully get child %d\n"</span>, pr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"some error occured\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>No child exited<br>successfully get child 1526</p><p>我们让父进程和子进程分别睡眠了10秒钟和1秒钟，代表它们分别作了10秒钟和1秒钟的工作。父子进程都有工作要做，父进程利用工作的简短间歇察看子进程的是否退出，如退出就收集它。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进程短暂的一生：</p><p>随着fork，一个新进程出生，但它这时只是老进程的一个克隆。<br>然后随着exec，新进程脱胎换骨，离家独立，开始了为人民服务的职业生涯。<br>人有生老病死，进程也一样，它可以是自然死亡，即运行到main函数的最后一个”}”，从容离去；也可以是自杀，自杀有2种方式，一种是调用exit函数，一种是在main函数内使用return，无论哪一种方式，它都可以留下遗书，放在返回值里保留下来；它还甚至能可被谋杀，被其它进程通过另外一些方式结束他的生命。<br>进程死掉以后，会留下一具僵尸，wait和waitpid充当了殓尸工，把僵尸推去火化，使其最终归于无形。</p><p>这就是进程完整的一生。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux内核中设置了一组用于实现各种系统功能的子程序，称为&lt;em&gt;系统调用（system call）&lt;/em&gt;。同时它还提供些C语言函数库，这些库对系统调用进行包装和扩展。由于这些库函数与系统调用的关系非常紧密，习惯上把这些函数也称为系统调用。&lt;em&gt;本文是作者在大二写OS作业时整理的，安利文章&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part3/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统调用跟我学&lt;/a&gt;这篇写得真的很舒服，本文很多内容都源于此。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Sys" scheme="https://stardust567.github.io/categories/Sys/"/>
    
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="OS" scheme="https://stardust567.github.io/tags/OS/"/>
    
      <category term="进程" scheme="https://stardust567.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="系统调用" scheme="https://stardust567.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>恋与L</title>
    <link href="https://stardust567.github.io/post/16623.html"/>
    <id>https://stardust567.github.io/post/16623.html</id>
    <published>2019-02-14T12:17:39.000Z</published>
    <updated>2019-06-08T08:17:04.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>&emsp;&emsp;初遇L是在我中考后的那个暑假，那时候不知道是哪里来的好学之心，竟然去报了个初升高的衔接班。爸妈看我这么有志气的样子感觉也没什么太正当的理由来阻拦我，就顺着我的意交钱让我上了。当然后来我高考完再寻思这事<em>（其实我真正寻思这事是在高一，那时候内心疯狂吐槽为什么不好好过个没作业的假期）</em><a id="more"></a>真真切切觉得这事儿除了能提高你点自信心外好像就真的没什么用处。刚到个陌生环境大家都不太适应，但是你竟然把前几个月要学的东西草草学了一遍，哎这你就有了一个能吹水，哦不，是能提高自信的机会了，当然这事也是因人而异，可能我会这么想多半是因为我天赋有限，白白糟蹋了钱财和大好的假期机会。<br>&emsp;&emsp;在那个衔接班上，坐在我前面的就是L。这里给L取个名字吧，随意一点取的话，就叫路嘉琪吧。（虽然我说是很随意，但其实还是经历过某种深思熟虑的，<del>绝对不是因为输入法蹦出来就随便选了这么草率的，</del>嗯）第一次见她就觉着这个女孩子的发质非常好<del>（？？？我绝对没有什么特殊的恋发癖）</del>，当然这并不是在给我上课卷她头发找借口，只是陈述一下第一眼的直观感受。她那时扎了个干净利索的马尾，但长度绝对能自然垂到肩下，发量很足，长发在末梢倒不显散乱。稍显弧度的马尾下是张非常白净的脸，记忆里是种瓷白，像玉石的温润中透着股月牙的皙白，如果能轻轻戳一下的话，说不定会是凉凉微滑的瓷器手感。标准的杏脸加上不错的五官，再配上她显出的那种富养大小姐的感觉，大方里流露点江南水乡蕴出来的温婉味道……我现在倒也说不清楚这是那时真切的第一印象还是我后期回忆里不断修正加工层层滤镜后的“第一印象”，总之就是好感MAX吧。<br>&emsp;&emsp;过了一开始的新奇劲儿，之后大家平常的介绍然后熟识，像这种衔接班也就上个一个月左右。这一个月的日子像是平时，只是换了批老师和同学，平日里该笑该闹还是继续。依稀记得上课的那个学校里栽了很多竹子，一节节地蹿上了好几层楼，视线偏转一下就能看见一墙又一墙的爬山虎，风吹的时候一层层撩在人心上，让心儿痒得直颤。等好不容易熬到下课，我一般会去走廊上摘几片够得到的竹叶，上课了就把弄着竹叶玩儿，顺便留一片别在路嘉琪的马尾上。这种情况一般是不会被发现的，毕竟我的手法愈趋娴熟，而她的发量又着实比较充足。但人生在世总会遇到些说不清道不明的意外，偶尔被发现后她也只会回过头瞪着我几秒，毕竟我算准了上课时间她也不能做出什么过激的举动，等下课了，大家也就忘了这事儿，还像以往那样随意地谈天说地，聊着各种奇奇怪怪的话题。而随着这个衔接班的结束，中考录取结果也下来了，我和她不在同一所高中，她被我高中所谓的兄弟学校<del>（我一直很好奇为什么不叫姐妹花学校）</del>录取了。当时一边在心里小声哼着“啊~好朋友，再见~再见”一边做着不深不浅的道别，只是想着大概是没什么机会再见了，咱们，山高路远，就此别过。浑然不知后面还会和路嘉琪再扯上点意料之外的事。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>&emsp;&emsp;刚踏入高中校园的我有点点激动，这个高中很符合我的设想。整个校园很大（和我大二所在的校区一样大）各种徽派的设计也很得体，那股单纯的兴奋劲儿比我刚进大学校园还要冲（<del>第四声</del>）还要足。虽然高中是寄宿制，但大部分学生还是会选择走读即只中午在校午休。寝室是个标准六人间的配置，一般只会住四个人左右不会住满。最初的室友有三个人，名字也随意点，分别是大鲍、涵姐和骚翔。简单介绍下，大鲍是个身材魁梧，肤色偏黑，沉默寡言的壮硕男生，为人老实，热爱看书。平时虽不多言，但一出口，必属骚中佳句。涵姐整个人就有些浪里滑条的感觉，平时虽然骚浪了一点，但人却不差。除了那张浪里浪气的脸，各方面也是均值往上跑了。骚翔人如其名，一个“骚”字，论骚我也认识了不少人，但至今没人能骚得过他，以至于给我幼小的纯洁心灵留下了一道道崩坏三观的刻印。骚翔看上去就像个新疆的混血，是偏烤羊肉串的那种，不过到底是哪一族的混血他不愿主动说，我们也不好意思问，这个问题便就此作罢，只能在心中随意想想。当熟悉了我这三位室友的作风，不禁仰头长叹，本来一个正值大好年华的青葱少年，却被命运给安排上了这三个明骚暗骚的人，<del>竟然还稍微有些期待？</del>总之就这样展开了我第一段<del>激情四射的</del>宿舍生活。就比如军训的时候，作为一名纯洁正直，不蔓不枝的男子高中生，午休期间我肯定是不愿和他们三个同流合污相互扯淡的，那么睡觉无疑是我可以选择的最佳回避方式。但谁料，哪怕我睡了也无法暂停他们恶魔般的骚气步伐。涵姐见我侧卧在床半天没有动静，“你这不会就睡觉了吧？”，见我毫无回应之后索性放开了连念我名字后两字数十遍，想来大概和某种复杂的传教索魂仪式相似，嗯“我喊你声你敢应吗”的那种。“咦？”只见涵姐俯卧在床摸了摸自己的脸颊“这喊多了就成‘学姐’了，以后就叫学姐好吧”。其余两人略一思索，不约而同地觉得这个称呼十分贴切，真真是一场美妙的缘分，呃不是，室友情。就这样，我在睡梦中就有了这个贯穿我高中直至现在的外号。这声“学姐”被各式各样的人吐槽调侃过，像同学朋友就不说了，被班主任和各科老师，父母和亲戚……他们发现的来源主要有以下几种：在校几乎所有学生都喊我“学姐”不论男女（微笑脸）上课总会有人嘴贱喊出声叫老师听见，就像自己只是喝了口水般理所理当（微笑脸X2）网上评论直接“学姐”来“学姐”去，我爸妈真的想不知道都难（微笑脸X3）就这样慢慢的，“学姐”这个称号已经完美融入到我的人设里，成为了我生命中不可或缺的一份子（微笑脸X4）。<br>&emsp;&emsp;正式上课后，我和那么多在题海里沉浮的少男少女并没什么二异，一个没什么太大爱好也没什么太多想法的的高一学生，整天就像被洗脑般脑中只有个高考的模糊影子，然后告诉你照着这个影子疯狂追就完事了，但丝毫没有人来告诉你追到了后要干什么，也没人告诉你这个影子后面会有那么多更加张牙舞爪的影子要你一个人去独自面对。不过嘛，那个时候的我们是没那个心思去思虑未来的，每天只顾着和周边人扯淡，关心些乱七八糟的事，以及在杂乱的烦心之余尽力学习一下意思意思。就在这样的肆意挥发荷尔蒙，哦不是，是散发青春气息的步子里，我跌跌撞撞地走了一个学期，谈不上多开心但整个生活确是像色调明亮的油画般充满了少年气，好似有股糯黄的酥糖味。而就在这个中二的骑士想要翻开下一学期的日历前，因为一件小事儿，路嘉琪找到了我。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>&emsp;&emsp;是件很小的事，但借此为契机，我和她在网上慢慢熟络，渐渐抛开原先有的那点小拘谨，好感像颗种子在我尚未察觉之际已经慢慢吐出怒绿的幼芽。从原先的如果什么时候在线就随便聊聊（事实上她的QQ显示是全天在线的，至少每次不论我什么时候上线她都一定是在的）到每天固定的些时间点互相聊些什么，一般是我听她说，然后给点不温不火的建议与想法。啧现在想想我那个时候的回答应该可傻逼了，不过好在她应该只是想找个人可以安安静静地听她的各种烦忧，所以在这样的网聊节奏下，我和她的关系倒是越走越近，至少在我看来是更近些的。近到或者让我自以为是到，每天会不经意说出和她的聊天而觉得平常，这样的结果就是激起了我前座的狗血八卦之魂。我前座小黑是个偏瘦的女生，叫她小黑纯粹是因为她肤色偏黑一点，就这么随口叫下来了。小黑是那种人前疯来跑去，但内里有点忧郁寡淡，<del>有时候还敏感事多的那种</del>。不过她学了那么多年的舞，身材和气质还是有的。我这么帮她说话起源得归咎她给我的那张贺卡，那时候刚高中没什么事儿的孩子总喜欢互赠各种贺卡，别人的贺卡大都是些无关疼痒但微微暖心的小祝福，小黑的偏是什么“我也很喜欢纳兰容若的词”和“你平时都是笑的样子只是表面”这样的话，事实证明，千万不要和中二病说这些，如果你不想和他们扯上关系的话。这些话对中二病的杀伤力无疑是巨大的，所以之后关于她的事，初印象总还不错。她就追问了我路嘉琪的名字，然后诡异的事发生了，路嘉琪是小黑的初中闺蜜……嗯？？？这是什么神仙孽缘，啊不是，肯定是天造地设的缘分啊这次。<br>&emsp;&emsp;就这样，白天找小黑聊着路嘉琪初中的事，晚上和路嘉琪随意地谈天说地，聊人生聊理想，当时只觉得日子过得像神仙一样，管他的高考学习，我只要能每天都和她聊上天就好了，再说我成绩也，也还过得去嘛，这种事情也肯定不会影响学习的啦。反正每天晚上找父母借到手机就往卫生间跑，用各种什么拉肚子啊泡澡怎么可能没有bgm这样的烂理由延长用手机的时间来和她聊天。</p><blockquote><p>她发“我来当你的树洞好了，有什么话都可以对我说哦”，</p><blockquote><p>我回“嗯嗯，你也是，有什么事情都直接和我说好了”。</p></blockquote><p>“你想考什么学校啊”，</p><blockquote><p>“我啊，没怎么想过，应该是像北航这样的学校吧”。</p></blockquote><p>“那很好啊”，</p><blockquote><p>“你呢？”。</p></blockquote><p>“我想去上海或者江浙那边的学校，具体还没想好”，</p><blockquote><p>“不急，才高一嘛，像我想好了估计也考不上，北航好像挺难考的”。</p></blockquote><p>“你可是学霸啊，要好好加油啊”，</p><blockquote><p>“嗯嗯，一定，你也是！”。</p></blockquote><p>……</p></blockquote><p>&emsp;&emsp;就这样，每晚我都躲在卫生间里偷着乐，现在想想，一个小男孩背靠着厕所的墙壁蹲在地上抱着宛若至宝的手机，看着屏幕上的字傻笑却不敢发出声的样子，真的是多亏了爸妈给我的无限信任。不过有点，和路嘉琪聊天的时候也不是没说过小黑的事，但她的回应就比较平淡了，和我想的有点不太一样，不过当时的我也没多想就继续乐呵着和她扯别的话题了。</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>&emsp;&emsp;某个下午体育课我在操场问起小黑，“她的话应该比较受欢迎吧，初中有谈过恋爱吗？”，“嗯有”，“哎哎，是什么样的啊”，“嗯，她初中会经常性地用小刀割腕，留下了很多印子”，“？？？啊？”，小黑看了眼惊诧非常的我，淡淡地说“我觉得你看到的她只是很表面的她”小黑说完轻叹口气，撇过头继续回我的问题，“然后她的男朋友在她某次想用小刀划自己的时候，把刀抢过对着自己的手腕划了一刀，和她说以后如果再想割的话，我陪你一起割。她好像挺感动的，后来就在一起了。不过中考后发生了些事情，好像分手了，她也删掉了初中所有人的联系方式。”，“……”当时我有点说不出话来，所有的气力都卡在喉咙里发不出一点声音。我到现在为止的生活都很普通，普通地学习，普通地长大，普通地在老师父母设置好的轨迹上咕噜咕噜滚着。这样普通的我不能理解为什么会真的有人会选择自残，去尝试割腕。这对我的冲击一如多年后当我得知，有某个我很钦佩的很优秀的朋友选择用自杀结束自己年轻的生命和未知的前途的时候，从未想过这样的事会发生在自己的身边，所以当发生的时候所带来的冲击和动摇无疑是巨大的。小黑看我良久不说话，偏头看向我，“学姐，我觉得你做不到”，“为什么要选择和她一起割啊，不应该想办法让她不再伤害自己才对吗”我有点激动，夹着猝不及防的三观动摇，对她的心疼，还有自己的不服气。小黑回过头确是又叹了口气，“唉，所以你……不过或许你这样理想主义的真的能帮到她也不一定”，不过我当时的想法倒是：为什么你老是在叹气啊喂，我有那么不行吗喂。有些沮丧的我伸着头望了望周围，柔和偏橘的阳光打下来，整个操场以及操场上的人都好像被浇了层薄蜜，稍微有点闪，我下意识低了低头。“你喜欢她吗？”耳边突然传来小黑的声音，我有点慌乱，“啊？我不知道，应该没有吧，只是朋友而已，比较好的朋友而已”，“那如果她和别的男生走在一起，拥抱打kiss，你也不会难受？”，“可能会有一点吧，但……”小黑不等我说完就走开了，只留下一句“你慢慢想吧”，剩我一个呆呆站在操场上。慢慢想？我想个鬼啊，这种事我怎么知道。<br>&emsp;&emsp;当晚，我还是和路嘉琪没心没肺地聊着天，只是在心里暗暗下决定，一定要帮她。<em>（当时真的就是这么想的啊，现在想想人家根本就没什么好要我帮的，倒不如说每天聊聊天就已经很好了，但那个时候中二的我，嗯，总喜欢一厢情愿地沉浸在自己的想象里）</em>第二天小黑倒也没再提那事，只是对我来说始终有个刺大大咧咧地刺在那儿。中午回到寝室，室友们正在用他们扯淡的想象展现着大鲍家是多么有钱，比如 “哎以后去当大鲍家的扫地嘚~给你配几把黄金镶钻扫把”，“啧，镶钻怎么配得上大鲍的身价，那肯定要全是钻石打造的才行”，“噢~这是我考虑不周了，再配个钻石拖把，拖出来的地那是要比钻石还要亮”……之后骚翔见我进来不说话，“哦豁，学姐你竟然不说话，是不是看不起大鲍的家产，你看你头顶马上就会有无数个红点”。我的内心：兄弟我正在思考一些很哲学，呃不，是很重要的问题，你这样我很跳戏啊喂。等我翻身爬上床后，大鲍看我靠墙的背影说“你们看学姐这个角度看好像个女生啊”，骚翔马上就接“学姐本来不就是个女生嘛”，在我刚想反驳的时候，我就看见涵姐直接过来一边爬我的梯子一边淫笑着“嘿嘿嘿那我们来确认一下不就好了”，骚翔看到后不甘示弱，因为我和他床在同一边，他在尝试着能不能直接跨过来……接下来，虽然我奋力抵抗，但终究是腹背受敌最后败下阵来。然后那天中午我们三个男生（大鲍还是比较好的，安安心心睡在自己床上）挤在一张小小寝室单人床里，竟然各自都睡着了，让我感受到了我高中宿舍床板质量之高。不过和他们这么闹过之后，心情倒是放开了很多。跟着楼梯和人流向上走的时候，我决定向路嘉琪表明自己的心意。（我后来发现我好像还蛮喜欢这种自爆式告白的哎（微笑X</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>&emsp;&emsp;这是个中二病一厢情愿最后什么也没能做到的故事。没能让她变得开心一点，不仅什么都做不到还给她徒增了很多烦闷。对当时的我来说，尽力想去帮别人但最后适得其反，给了我很深的打击，加上之前三观上的动摇，我开始对我本应普通的生活产生了怀疑。看着自己还未开出花朵的幼苗灰败地枯死，像是游荡到了某条寂静没有生灵的河流中，随着水波慢慢浮沉。但哪怕心里难受得只想缩成一团藏进角落，还是有些回忆像荧星点点悬浮在脑海中，不忍让它们散去。在你触碰到美好的时候就应该想到，任何事情都不可能只有美好。此时的欢愉和彼时的苦痛不断交织，在你决定享受喜悦的时候，就该做好面对以后未知苦难的准备，就像<em>“她那时候还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格”</em>，出来混，迟早是要还的。还是希望L会更开心一点吧。总之，随着这场无声的号角吹响然后顷刻覆灭的戏剧过后，没多久就迎来了高一的暑假，假期混混模联，做做义卖，以及最本职最头疼的暑假作业，倒是给高一画上了个还挺正常兼正经的句号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;初遇L是在我中考后的那个暑假，那时候不知道是哪里来的好学之心，竟然去报了个初升高的衔接班。爸妈看我这么有志气的样子感觉也没什么太正当的理由来阻拦我，就顺着我的意交钱让我上了。当然后来我高考完再寻思这事&lt;em&gt;（其实我真正寻思这事是在高一，那时候内心疯狂吐槽为什么不好好过个没作业的假期）&lt;/em&gt;
    
    </summary>
    
    
      <category term="恋爱物语" scheme="https://stardust567.github.io/categories/%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="随记" scheme="https://stardust567.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="恋爱物语" scheme="https://stardust567.github.io/tags/%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>恋与序</title>
    <link href="https://stardust567.github.io/post/9391.html"/>
    <id>https://stardust567.github.io/post/9391.html</id>
    <published>2019-02-12T05:32:34.000Z</published>
    <updated>2020-01-11T02:20:52.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>&emsp;&emsp;14年，那时的我在中考之后脱离了低阶中二，怀着高阶的中二和以各种动漫和轻小说为蓝本构建的美好高中幻想（比如天降个超级好看的小姐姐什么的……<del>当然这种事情我现在大二了也依旧在幻想就是了</del>），踏入了所在城市最好的高中之一。<a id="more"></a>所谓“高阶的中二”，考完中考的那个假期由于无聊，就随意找了部看上去还不错的动漫，见了里面粉毛的女主，顿时惊为天人，励志要做一个像男主那样“亚撒西”的人，然后去找一个像女主的小姐姐<em>（好了不用滋醒我，我知道不可能了）</em>。由此，就开始了我漫长却又极具“趣味性”和戏剧性的感情经历。<br>&emsp;&emsp;其实还别说，去学着日漫男主的样子混，只要你能学得像，总会有世界剧本女主的人出现在你眼前，这时候大概会出现两种情况，一是鉴于各种原因，你在她的剧本里只是个路过的路人乙，而路人的戏份总不会有太多。二是鉴于各种原因，你并不会那么理所当然的认为她是女主或者说你的<em>the one</em>，但由于很符合你目前心中的各种设定，总是一层一层地荡着好感，然后好感一圈圈转成棉花糖把自己裹在里面。同时，可能是混得太像那么回事儿了吧，我收到了至今为止都是我觉得对我赞誉最高的一句话<em>“那时候的你仿佛是闪着光的”</em>，以至于哪怕后来我真的很想努力去做个能为某个人照点亮光的人的时候，没能做到所带来的挫败感是无比巨大的，巨大到后来的我再想从自己身上找到点光就像是从被拧干的毛巾里寻找能沁住自己的水流一般，百般无奈后只能靠铺开摊在脸上找点湿润聊以自慰与自嘲。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序章&quot;&gt;&lt;a href=&quot;#序章&quot; class=&quot;headerlink&quot; title=&quot;序章&quot;&gt;&lt;/a&gt;序章&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;14年，那时的我在中考之后脱离了低阶中二，怀着高阶的中二和以各种动漫和轻小说为蓝本构建的美好高中幻想（比如天降个超级好看的小姐姐什么的……&lt;del&gt;当然这种事情我现在大二了也依旧在幻想就是了&lt;/del&gt;），踏入了所在城市最好的高中之一。
    
    </summary>
    
    
      <category term="恋爱物语" scheme="https://stardust567.github.io/categories/%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="随记" scheme="https://stardust567.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="恋爱物语" scheme="https://stardust567.github.io/tags/%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Hidden Markov Model</title>
    <link href="https://stardust567.github.io/post/19116.html"/>
    <id>https://stardust567.github.io/post/19116.html</id>
    <published>2018-12-14T06:23:45.000Z</published>
    <updated>2020-05-27T00:31:01.368Z</updated>
    
    <content type="html"><![CDATA[<p>Hidden Markov Model(HMM)是一种关于时序的概率模型，最初由 L. E. Baum 和其它一些学者发表在一系列的统计学论文中，随后在语言识别，自然语言处理以及生物信息等领域体现了很大的价值。本文通过个人的理解以及《统计学习方法》 中的公式推导对HMM的定义及其三个基本问题进行了简单的介绍。<a id="more"></a></p><h2 id="Markov-model"><a href="#Markov-model" class="headerlink" title="Markov model"></a>Markov model</h2><p> 在介绍隐马尔可夫模型前我们先来介绍一下基础的马尔可夫链。马尔可夫链是一个随机模型描述序列可能的事件，其中每个事件的概率仅取决于在先前事件获得的状态 。粗略地说，以系统的当前状态为条件，其未来和过去的状态是相互独立的。<br> 马尔可夫链的节点是状态，边是<strong>转移概率</strong>，是template CPD（条件概率分布）的一种有向状态转移表达。马尔可夫过程可以看做是一个自动机 ，以一定的概率在各个状态之间跳转。接下来以一阶马尔可夫链（first-order Markov chain）举例，N 次观测的序列的联合概率分布为：</p><script type="math/tex; mode=display">p(x_1,...,x_n)=p(x_1)\prod_{i=2}^n p(x_n|x_{n-1}) \quad</script><p> 由于每个事件发生的概率仅于前一件事件有关，即有：</p><script type="math/tex; mode=display">p(x_n |x_1,…,x_{n-1} )=p(x_n |x_{n-1})</script><p> 下面介绍马尔可夫链的一个重要性质，<strong>当n趋向于无穷时，p（Xn）趋向于一个定值。</strong>首先将每个事件的转移概率相整合成一个转移概率矩阵，假设每个事件的发生概率只与前一个事件的状态有关，共计n个状态的话，我们可以用一个n*n的矩阵P来表示转移概率，即 当我们有初始状态矩阵 时（ 表示初始状态为第i个状态的概率）则第n个状态的概率矩阵为 通过线性代数知识将转移概率矩阵做对角化，可得无穷个P矩阵相乘为一个常数，即马尔可夫链的极限收敛定理，马尔可夫链的这一性质对于其实际运用有重要的意义与作用。</p><h2 id="HMM定义"><a href="#HMM定义" class="headerlink" title="HMM定义"></a>HMM定义</h2><p> 在正常的马尔可夫模型中，状态对于观察者来说是直接可见的。这样状态的转换概率便是全部的参数。而在实际情况中，较为本质的状态转换通常是较为<strong>隐性即无法实际观测的</strong>，但是受该状态影响的变量是我们所可以观测的，由此，我们来介绍隐马尔可夫模型。在隐马尔可夫模型中，状态并不是直接可见的，但受状态影响的某些变量则是可见的。每一个隐性状态对于可观测的显性状态都有一概率分布，我们将这个概率称之为<strong>发射概率</strong>。<br> 由此，如果我们有n个隐性状态的状态集合Q和有m个显性状态的观测集合V的话，假设I是长度为T的状态序列，O是对应的观测序列。我们就可设置转移一个$n \times n$的转移概率矩阵A和一个$m \times n$的发射概率矩阵B，π是初始状态概率向量：</p><p>$n \times n$的转移概率矩阵A:<br> $ \qquad a_{ij}=P(i_{t+1}=q_j│i_t=q_i ) \qquad i=1,…,N;j=1,…,N$</p><p>$m \times n$的发射概率矩阵B:<br> $ \qquad b_j (k)=P(o_t=v_k│i_t=q_j ) \qquad k=1,…,M;j=1,…,N$</p><p>π是初始状态概率向量:<br> $ \qquad π_i=P(i_1=q_i) \qquad i=1,…,N;j=1,…,N$</p><p> 状态转移概率矩阵A与初始状态概率向量π确定了隐藏的马尔可夫链，生成不可观测的状态序列。发射概率矩阵B确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列。隐马尔可夫模型就是由基本的A,B,π三个矩阵或向量加上具体的状态集合Q和观测序列V所构成的。<br> 接下来我以维基百科上的一个经典例子来作为算法实际运用的实例 ：</p><blockquote><p>“Consider two friends, Alice and Bob, who live far apart from each other and who talk together daily over the telephone about what they did that day. Bob is only interested in three activities: walking in the park, shopping, and cleaning his apartment. The choice of what to do is determined exclusively by the weather on a given day. Alice has no definite information about the weather, but she knows general trends. Based on what Bob tells her he did each day, Alice tries to guess what the weather must have been like.<br>Alice believes that the weather operates as a discrete Markov chain. There are two states, “Rainy” and “Sunny”, but she cannot observe them directly, that is, they are hidden from her. On each day, there is a certain chance that Bob will perform one of the following activities, depending on the weather: “walk”, “shop”, or “clean”. Since Bob tells Alice about his activities, those are the observations. The entire system is that of a hidden Markov model (HMM).<br>Alice knows the general weather trends in the area, and what Bob likes to do on average. In other words, the parameters of the HMM are known. 。”</p></blockquote><p> 这段稍显繁琐的文字可以转换成一张较为简洁易懂的状态转换图，如下：<br><img src="https://i.loli.net/2018/12/14/5c1350d47ce76.png" alt=""></p><h2 id="HMM基本问题"><a href="#HMM基本问题" class="headerlink" title="HMM基本问题"></a>HMM基本问题</h2><ol><li>概率计算问题：给定模型λ(A,B,π)和观测序列O,计算在模型λ下观测序列O出现的概率P(O|λ)为多少。</li><li>学习问题：己知观测序列O,估计模型参数λ(A,B,π)使得在该模型下观测序列概率P(O|λ)最大。即用极大似然估计的方法估计参数。</li><li>预测问题：也称为解码（decoding)问题。已知模型λ(A,B,π)和观测序列O，求对给定观测序列条件概率P(I|O)最大的状态序列I。即给定观测序列，求最有可能的对应的状态序列。</li></ol><h3 id="概率计算"><a href="#概率计算" class="headerlink" title="概率计算"></a>概率计算</h3><ol><li><h4 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h4>给定模型，求给定长度为T的观测序列的概率，直接计算法思路是枚举所有的长度T的状态序列，计算该状态序列与观测序列的联合概率（隐状态发射到观测），再用全概率公式对所有枚举项求和。在状态种类为N的情况下，一共有N^T种排列组合，每种组合计算联合概率的计算量为T，总的复杂度为O(T*N^T)，并不可取。</li><li><h4 id="前向计算"><a href="#前向计算" class="headerlink" title="前向计算"></a>前向计算</h4><p><strong>前向算法的介绍</strong><br>前向计算中最为重要的一步的就是前向概率的设定，对于给定隐马尔可夫模型λ(A,B,π)，定义到时刻t为止的观测序列为O且状态为 的概率为前向概率，记作</p><script type="math/tex; mode=display">α_t (i)=P(o_1,o_2,…,o_t,i_t=q_i |λ)</script><p>对于每一个时间点上的状态，都是用一个长度为n的概率矩阵来标记，转移到下一个状态前需要满足当前状态的观测值和已知观测序列一致，达成这个条件后即可正常转移到下一个状态，依次下去我们便可以递推地求得下一个前向概率及观测序列概率P(O|λ)</p><ul><li>初值<script type="math/tex; mode=display">α_1 (i)=π_i b_i (o_1 ) \qquad i=1,…,N</script>前向概率的定义中一共限定了两个条件，一是到当前为止的观测序列，另一个是当前的状态。所以初值的计算也有两项（观测和状态），一项是初始状态概率，另一项是发射到当前观测的概率。</li><li>递推对t=1,2…T-1<script type="math/tex; mode=display">\alpha_{t+1} (i)=[\sum_{j=1}^N \alpha_t (j) a_{ji}] b_i(o_{t+1}) \qquad i=1,…,N</script>每次递推同样由两部分构成，括号中是当前状态为i且观测序列的前t个符合要求的概率，括号外的是状态i发射观测t+1的概率。</li><li>终止<script type="math/tex; mode=display">P(O|λ)=\sum_{i=1}^N[α_T (i)] \qquad i=1,…,N</script></li></ul><p>由于到了时间T，一共有N种状态发射了最后那个观测，所以最终的结果要用全概率公式将这些概率加起来。<br>由于每次递推都是在前一次的基础上进行的，所以降低了复杂度。</p><h5 id="前向算法实例"><a href="#前向算法实例" class="headerlink" title="前向算法实例"></a>前向算法实例</h5><p>以之前天气的例子来说明前向算法，HMM模型可以写成：</p><script type="math/tex; mode=display">A=\begin{bmatrix} 0.7 & 0.3 \\\\ 0.4 & 0.6 \\\\ \end{bmatrix}</script><script type="math/tex; mode=display">B=\begin{bmatrix} 0.1 & 0.4 & 0.5 \\\\ 0.6 & 0.3 & 0.1 \\\\ \end{bmatrix}</script><script type="math/tex; mode=display">π=[0.6,0.4]^T</script><script type="math/tex; mode=display">O=（散步，购物，扫除）</script><p>假如我们想计算在（0.6,0.4）的初始状态下鲍比在未来三天分别按顺序做散步，购物，扫除的概率是多大，按照前向概率法计算，步骤如下：</p><ul><li>计算初值——初始状态下散步的前向概率：<br>$\alpha_1 (1)=π_1 b_1 (o_1 )=0.06$<br>$\alpha_1 (2)=π_2 b_2 (o_1 )=0.24$</li><li>递推计算——本质还是转移概率乘上发射概率：<br>$\alpha_2 (1)=\sum_{j=1}^2[\alpha_1 (j) a_{j1} ] b_1 (o_2 )=(0.042+0.096)×0.4=0.0552$<br>$\alpha_2 (2)=\sum_{j=1}^2[\alpha_1 (j) a_{j2} ] b_2 (o_2 )=(0.018+0.144)×0.3=0.0198$<br>$\alpha_3 (1)=\sum_{j=1}^2[\alpha_3 (j) a_{j1} ] b_1 (o_3 )=(0.03864+0.00792)×0.5=0.02328$<br>$\alpha_3 (2)=\sum_{j=1}^2[\alpha_3 (j) a_{j2} ] b_2 (o_3 )=(0.01656+0.01188)×0.5=0.01422$ </li><li>终止：<br>$P(O│λ)=\sum_{i=1}^N[\alpha_T (i)]=0.03750 $</li></ul></li><li><h4 id="后向计算"><a href="#后向计算" class="headerlink" title="后向计算"></a>后向计算</h4><p>后向计算与前向计算相类似，只是定义了后向概率，再次不多做赘述。</p></li></ol><h3 id="Baum-Welch算法"><a href="#Baum-Welch算法" class="headerlink" title="Baum-Welch算法"></a>Baum-Welch算法</h3><p>假设给定训练数据只包含S个长度为T的观测序列O而没有对应的状态序列，目标是学习隐马尔可夫模型λ(A,B,π)的参数。我们将观测序列数据看作观测数据O，状态序列数据看作不可观测的隐数据I，那么隐马尔可夫模型事实上是一个含有隐变量的概率模型：</p><script type="math/tex; mode=display">P(O│λ)=\sum [P(O│I,λ)P(I|λ)]</script><p>它的参数学习可以由EM算法实现。这里简单介绍一下EM算法，EM算法即Expectation Maximization期望最大算法。这个算法的引入可以从极大似然估计入手，极大似然估计是对于单分布问题通过已经发生的事件来估计概率模型中的位置参数，但事实上存在很多多分布问题，你只有最后的观测序列结果，但对于其具体的隐藏状态一无所知，比如经典的高斯混合模型。这个时候我们所采取的措施是先假设一组隐藏状态概率，然后进行极大似然估计，再用极大似然估计后的参数将原参数更新，这样不断迭代直至最后估计值收敛，具体的公式推导与证明只给明出处 ，在此并不细说。</p><ol><li><p>确定完全数据的对数似然函数<br>所有观测数据写成$O=(o_1,o_2,…,o_T)$,所有隐数据写成$I=(i_1,i_2,…,i_T)$，完全数据是$(O,I)=(o_1,o_2,…,o_T,i_1,i_2,…,i_T)$,。完全数据的对数似然函数是logP(O,I|λ)。</p></li><li><p>EM算法的E步：求Q函数</p><script type="math/tex; mode=display">Q(\lambda,\hat\lambda)=\sum_I[logP(O,I|\lambda)P(O,I|\hat\lambda)]</script><p>其中，λ ̅是隐马尔可夫模型参数的当前估计值，λ是要极大化的隐马尔可夫模型参数。</p><script type="math/tex; mode=display">P(O,I│\lambda)=\pi_{i_1} b_{i_1} (o_1 ) a_{i_1 i_2 } b_{i_2} (o_2 )…a_{i_{T-1} i_T } b_{i_T} (o_T )</script><p>这个式子从左到右依次是初始概率、发射概率、转移概率、发射概率……<br>于是函数Q可以写成：</p><script type="math/tex; mode=display">Q(\lambda,\hat\lambda)=\sum_I[log\pi_(i_1 ) P(O,I|\lambda)]\\\\+\sum_I(\sum_{t=1}^{T-1}[loga_{i_{t+1} \, i_t } ])  P(O,I│\hat\lambda)+\sum_I(\sum_{t=1}^Tlogb_{i_t}(o_t))P(O,I│\hat\lambda)</script><p>式中求和都是对所有训练数据的序列总长度T进行的。这个式子是将<script type="math/tex">P(O,I│λ)=π_{i_1} b_{i_1} (o_1 ) a_{i_1 i_2} b_{i_2} (o_2 )…a_{i_(T-1) \, i_T } b_{i_T} (o_T )</script>代入$Q(\lambda ,\hat\lambda)=\sum_I logP(O,I\mid\lambda)P(O,I\mid\hat\lambda)$后，将初始概率、转移概率、发射概率这三部分乘积的对数拆分为对数之和，所以有三项。</p></li><li><p>EM算法的M步:极大化Q函数求模型参数λ(A,B,π)，由于要极大化的参数在Q函数表达式中单独地出现在3个项中，所以只需对各项分别极大化。<br>第1项可以写成：</p><script type="math/tex; mode=display">\sum_Ilog\pi_{i_1} P(O,I|\hat\lambda)=\sum_{i=1}^Nlog\pi_i P(O,i_1=i|\hat\lambda)</script><p>注意到$\pi_i$满足约束条件利用拉格朗日乘子法，写出拉格朗日函数。这个方法更简单明了的说法就是求条件极值，与微积分下册第五章第九节 所说内容几乎一致：</p></li></ol><script type="math/tex; mode=display">\sum_{i=1}^Nlog\pi_i P (O,i_1=i\mid\hat\lambda)+\gamma(\sum_{i=1}^N\pi_i-1)</script><p> 对其求偏导数并令结果为0</p><script type="math/tex; mode=display">\frac{\partial}{\partial\pi_i} [\sum_{i=1}^Nlog\pi_i P (O,i_1=i\mid\hat\lambda)+\gamma(\sum_{i=1}^N\pi_i-1)]=0</script><p>  得到:</p><script type="math/tex; mode=display">P(O,i_1=i│\hat\lambda)+\gamma\pi_i=0</script><p>  这个求导是很简单的，求和项中非i的项对π_i求导都是0，logπ的导数是1/π，γ那边求导就剩下π_i自己对自己求导，也就是γ。等式两边同时乘以π_i就得到了上式。<br>  对i求和得到γ：</p><script type="math/tex; mode=display">\gamma=-P(O|\hat\lambda)</script><p> 代入$P(O,i_1=i│\hat\lambda)+\gamma\pi_i=0$中得到：</p><script type="math/tex; mode=display">\pi_i=\frac{P(o,i_1=i│\hat\lambda)}{P(O|\hat\lambda)}</script><p> 同理可以求得：</p><script type="math/tex; mode=display">a_{ij}=\frac{\sum_{i=1}^{T-1}P (O,i_t=i,i_{t+1}=j\mid\hat\lambda)}{\sum_{i=1}^{T-1}P (O,i_t=i\mid\hat\lambda)}</script><script type="math/tex; mode=display">b_j (k)=\frac{\sum_{i=1}^TP (O,i_t=j\mid\hat\lambda )I(o_t=v_(k))}{\sum_{i=1}^{T-1}P (O,i_t=i\mid\hat\lambda ) }</script><h3 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h3><h4 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h4><p> 维特比算法实际是用动态规划解隐马尔可夫模型预测问题，即用动态规划求概率最大路径（最优路径）。这时一条路径对应着一个状态序列。<br> 根据动态规划原理，最优路径具有这样的特性：如果最优路径在时刻t通过结点 ,那么这一路径从结点 到终点 的部分路径，对于从 到 的所有可能的部分路径来说，必须是最优的。因为假如不是这样，那么从 到 就有另一条更好的部分路径存在，如果把它和从 到达 的部分路径连接起来，就会形成一条比原来的路径更优的路径，这是矛盾的。依据这一原理，我们只需从时刻t=l开始，递推地计算在时刻t状态为i的各条部分路径的最大概率，直至得到时刻t=T状态为i的各条路径的最大概率。时刻t=T的最大概率即为最优路径的概率P,最优路径的终结点 也同时得到。之后，为了找出最优路径的各个结点，从终结点 开始，由后向前逐步求得结点 ,得到最优路径——这就是维特比算法 。<br> 换一种更加形象易懂的说法，假设将我们所有的状态拉成一个n*T的图，或者说一个每层有n个神经元，总共有T层的全连接神经网络。现在每一层的每个节点都会有来自上一层n个节点的连接，但我们只取其中概率最大的那一条边，将其他边全部“失活”，这样每个连接层都只剩n条边存在，不断递推直到最后一层为止，取最后一层概率最大的边为整个最优路径的概率，并不断回推得到最优路径。</p><h4 id="维特比算法的实例"><a href="#维特比算法的实例" class="headerlink" title="维特比算法的实例"></a>维特比算法的实例</h4><p> 我们再以之前天气的例子来说明前向算法，将HMM模型写成：</p><script type="math/tex; mode=display">A=\begin{bmatrix} 0.7 & 0.3 \\\\ 0.4 & 0.6 \\\\ \end{bmatrix}</script><script type="math/tex; mode=display">B=\begin{bmatrix} 0.1 & 0.4 & 0.5 \\\\ 0.6 & 0.3 & 0.1 \\\\ \end{bmatrix}</script><script type="math/tex; mode=display">π=[0.6,0.4]^T</script><script type="math/tex; mode=display">O=（散步，购物，扫除）</script><p> 假如在（0.6,0.4）的初始状态下，我们知道了Bob在接下来三天里分别按顺序做散步，购物，扫除，现在我们想知道那边的天气大概是什么样，按照维特比算法计算，步骤如下：</p><ul><li>初始化：在t=1时，对每个状态i，求i观测o_1为散步的概率δ_1 (i)：<br>$δ_1 (1)=0.6×0.1=0.06$<br>$δ_1 (2)=0.4×0.6=0.24$</li><li>在t=2时，对每个状态i，i=1,2，求在t=1时状态为j观测为散步并在t=2时状态为i观测为购物的路径的最大概率，记录此最大概率为δ_2 (i)，则：<br>$δ_2 (i)=max⁡[\delta_1 (j) a_{ji}]b_i (o_2) \qquad (1≤j≤2)$</li><li>通过该公式不断递推计算，我们可以很清楚的得到如下这张路径图：<br><img src="https://i.loli.net/2018/12/14/5c1374048ece8.png" alt=""><br>所以最优路径为（晴天，雨天，雨天）发生概率为（即最大概率）为0.01344</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hidden Markov Model(HMM)是一种关于时序的概率模型，最初由 L. E. Baum 和其它一些学者发表在一系列的统计学论文中，随后在语言识别，自然语言处理以及生物信息等领域体现了很大的价值。本文通过个人的理解以及《统计学习方法》 中的公式推导对HMM的定义及其三个基本问题进行了简单的介绍。
    
    </summary>
    
    
      <category term="机器学习" scheme="https://stardust567.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://stardust567.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="概率模型" scheme="https://stardust567.github.io/tags/%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程入门</title>
    <link href="https://stardust567.github.io/post/13592.html"/>
    <id>https://stardust567.github.io/post/13592.html</id>
    <published>2018-12-12T07:58:28.000Z</published>
    <updated>2019-03-20T12:05:56.706Z</updated>
    
    <content type="html"><![CDATA[<p>关于Java多线程的简单入门知识<br>其中最为重要的就是协调不同线程驱动的任务之间对资源的使用<br><em>（刚整理这篇的时候还没学OS，等OS学完后再回来修改&amp;对比总结一下）<del>希望我能成功填坑orz</del></em><br><a id="more"></a></p><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol><li><strong>进程：</strong>每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1—n个线程。（进程是资源分配的最小单位）</li><li><strong>线程：</strong>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</li><li><strong>更快的执行：</strong> 并行可以将任务分解到多个CPU上执行，但并发通常是提高运行在单处理器上的程序的性能。为什么实际运用会这么反直觉？——因为<strong>阻塞</strong>，当某个任务因为程序控制范围之外的条件（比如I/O）不能继续执行时，如果没有并发，那么整个主进程都将因此停止下来，直到外部条件发生变化。</li><li><strong>Java的并发：</strong> Java的并发系统与操作系统不同，会共享类如内存和I/O这样的资源，因此Java多线程最基本的困难就在于协调不同线程驱动的任务之间对资源的使用，以使得这些资源不会同时被多个任务访问。<ul><li>Java的线程机制是在由执行程序表示的单一进程中创建任务。</li><li>对于资源各个线程是抢占式的，调度机制会周期性地中断线程，将上下文切换到另一个线程。</li></ul></li></ol><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><ol><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行: "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">        Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">        mTh1.start();</span><br><span class="line">        mTh2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用两个对象的start方法，启动另外两个线程，这样整个应用就在多线程下成功运行了。<em>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由系统决定的。</em></p></li><li><p>实现java.lang.Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行  :  "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"C"</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"D"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。<br>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p></li></ol><p><strong>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的。</strong><br>实现Runnable接口比继承Thread类所具有的优势：</p><ul><li>适合多个相同的程序代码的线程去<strong>处理同一个资源</strong></li><li>可以<strong>避免java中的单继承的限制</strong></li><li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</li><li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li></ul><h3 id="线程状态切换"><a href="#线程状态切换" class="headerlink" title="线程状态切换"></a>线程状态切换</h3><p><img src="https://i.loli.net/2018/12/12/5c1109a616e2e.jpg" alt=""></p><ol><li>新建状态（New）：新创建了一个线程对象。</li><li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul><li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。_（注意,sleep是不会释放持有的锁）_</li></ul></li><li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol><li><p><strong>调整线程优先级：</strong>优先级高的线程会获得较多的运行机会。<br>Java线程的优先级用整数表示，取值范围是1~10<br>Thread类有以下三个静态常量：</p><blockquote><p><code>static int MAX_PRIORITY;//线程可以具有的最高优先级，取值为10。</code><br><code>static int MIN_PRIORITY;//线程可以具有的最低优先级，取值为1。</code><br><code>static int NORM_PRIORITY;//分配给线程的默认优先级，取值为5。</code></p><p>Thread类的<code>setPriority()</code>和<code>getPriority()</code>方法分别用来设置和获取线程优先级。<br>每个线程都有<em>默认优先级</em>，主线程的默认优先级为<code>Thread.NORM_PRIORITY</code><br>线程的优先级有<em>继承关系</em>，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>_JVM提供了10个线程优先级，但与常见的操作系统不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。_</p></blockquote></li><li><p><strong>线程睡眠：</strong><code>Thread.sleep(long millis)</code>方法，使线程转到阻塞状态。<br>millis：设定睡眠的时间(ms)当睡眠结束后，转为就绪（Runnable）状态。</p></li><li><p><strong>线程等待：</strong>Object类中的<code>wait()</code>方法，导致当前的线程等待，直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用<code>wait(0)</code>一样。</p></li><li><p><strong>线程让步：</strong><code>Thread.yield()</code>方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p></li><li><p><strong>线程加入：</strong><code>join()</code>方法，等待其他线程终止。<br>在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p></li><li><p><strong>线程唤醒：</strong>Object类中的<code>notify()</code>方法，唤醒在此对象监视器等待的单个线程。<br>如果所有线程都在此对象上等待，则会选择唤醒其中一个线程（选择是任意性的，并在对实现做出决定时发生）<br>线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有一个<code>notifyAll()</code>，唤醒在此对象监视器上等待的所有线程。</p></li></ol><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><code>Thread.sleep(long millis)</code>：<font color="SlateGray">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</font></li><li><code>Thread.join()</code>：<font color="SlateGray">指等待该线程终止。</font><br>该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。<br><em>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</em></li><li><code>Thread.yield()</code>：<font color="SlateGray">暂停当前正在执行的线程对象，并执行其他线程。</font><br>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</li><li><code>Thread.setPriority()</code>: <font color="SlateGray">更改线程的优先级。</font></li><li><p><code>Obj.wait()</code>：<font color="SlateGray">暂停当前线程，释放CPU控制权，释放对象锁的控制。</font><br><font color="MediumPurple">与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作</font>：</p><ul><li>从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。</li><li>从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</li></ul><p>线程类方法：</p><blockquote><p>sleep(): 强迫一个线程睡眠Ｎ毫秒。<br>isAlive(): 判断一个线程是否存活。<br>join(): 等待线程终止。<br>activeCount(): 程序中活跃的线程数。<br>enumerate(): 枚举程序中的线程。<br>currentThread(): 得到当前线程。<br>isDaemon(): 一个线程是否为守护线程。<br>setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)<br>setPriority(): 设置一个线程的优先级。</p></blockquote></li></ol><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li><p>synchronized关键字的作用域： </p><ul><li>是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； </li><li>是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ul><p><em>synchronized关键字是不能继承的，继承类需要你显式的指定它的某个方法为synchronized方法；</em></p></li><li>线程同步的TIPS<ul><li>线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</li><li>线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法。</li><li>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</li><li>对于同步，要时刻清醒在哪个对象上同步，这是关键。</li><li>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</li><li>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</li></ul></li><li>代码示例<br>创造一个<code>Object Lock</code>来充当锁，<br>用Lock类的变量lockon作为是否循环wait()语句的条件：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lockon;</span><br><span class="line">    Lock()&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockon = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    ThTest(Lock lock)&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lock.lockon==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(lock.lockon+<span class="string">"Lock is down.</span></span><br><span class="line"><span class="string">                        Next it will be on."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lockon = <span class="number">1</span>;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThRest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    ThRest(Lock lock)&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lock.lockon==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(lock.lockon+<span class="string">"Lock is on.</span></span><br><span class="line"><span class="string">                        Next it will be down."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lockon = <span class="number">0</span>;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">        ThTest thtest = <span class="keyword">new</span> ThTest(lock);</span><br><span class="line">        ThRest threst = <span class="keyword">new</span> ThRest(lock);</span><br><span class="line">        <span class="keyword">new</span> Thread(thtest).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(threst).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Java多线程的简单入门知识&lt;br&gt;其中最为重要的就是协调不同线程驱动的任务之间对资源的使用&lt;br&gt;&lt;em&gt;（刚整理这篇的时候还没学OS，等OS学完后再回来修改&amp;amp;对比总结一下）&lt;del&gt;希望我能成功填坑orz&lt;/del&gt;&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://stardust567.github.io/categories/Java/"/>
    
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="Java" scheme="https://stardust567.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://stardust567.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Gradient Descent</title>
    <link href="https://stardust567.github.io/post/17408.html"/>
    <id>https://stardust567.github.io/post/17408.html</id>
    <published>2018-12-11T12:05:38.000Z</published>
    <updated>2019-03-20T03:28:08.235Z</updated>
    
    <content type="html"><![CDATA[<p>梯度下降算法是机器学习领域中非常常用的优化算法。本文通过对梯度下降算法、AdaGrad算法、SGD算法、动量算法以及牛顿动量算法的介绍，将比较基础的梯度下降算法变种介绍给读者。<a id="more"></a></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>对于一个含参的函数，通过不断求解当前点的梯度值，并以该梯度值成负比例的步长不断更新所求点，以求解出使其函数值最小的一组参数。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>对于一个含参的函数，以与函数在当前点梯度（近似）成负比例的步长来不断更新该参数，使其不断向该参数偏导为0的点逼近，以找到函数的局部最小值。    当我们从损失函数的某一点出发，在该点附近做出以常数η为参数的一个邻域，根据微积分所学的知识可知，我们在该邻域上一定可以找出一个找到极小值。我们以该极小值点为下一步我们需要跟进的点，更新之后我们再在该点附近做出以常数η为参数的一个邻域并重复以上过程。通过这样的不断更新，我们理论上一定可以找出一个全局的极小值点或者是导数为0的驻点。<br>关于在某一邻域上如何找到该邻域上的局部最小值点。我们可以通过泰勒展开，该邻域上的损失函数可以近似写成 $L(\theta)=L(a,b)+u(\theta_1-a)+v(\theta_2-b)$也就是我们所熟知的全微分方程。令 $\Delta\theta_1=\theta_1-a;\Delta\theta_2=\theta_2-b$ 因为L(a,b)为一个常数，所以L的极小值直接取决于 u+ v同时我们可以将其书写成向量的形式$(\Delta\theta_1,\Delta\theta_2)·(u,v)$显然$(\Delta\theta_1,\Delta\theta_2)$与(u,v)反向时L最小，即</p><p>$$<br>  \begin{bmatrix}<br>   \Delta\theta_1 \\\\<br>   \Delta\theta_2<br>  \end{bmatrix}<br>=-\eta<br>  \begin{bmatrix}<br>   u \\\\<br>   v<br>  \end{bmatrix} </p><p>$$其中u和v分别为函数的偏导数值且η取值越小该结果越准确。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>用均方误差构造一个以函数f为自变量的二元损失函数 ：<br>(因为f = w*x + b所以也可以看出以w和b为自变量的函数)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L(f)=L(w,b)=((y - (w * x + b))**<span class="number">2</span>).sum()/len(x)</span><br></pre></td></tr></table></figure></p><p>首先考虑只有一个参数 w 的损失函数，随机的选取一个初始点，计算此时 L 对 w 的微分，然后顺着切线下降的方向更改 w 的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = w - grad(w)*learning_rate</span><br></pre></td></tr></table></figure></p><p>此后，w会不断靠近微分近似为0的点以达成目标。同样方法求出所有参数的值。而实际上我们所需要的是不断同时更新损失函数所需要的所有参数的值，我们在编程中只需要让所有参数的更新在同一次迭代过程中更新即可，因为当迭代次数足够多的时候，每一次的迭代都可以看成在很短的一个小时间段中进行，因此每次迭代的不同参数更新可以近似看成时在同一时间段所更新的，即达到了我们要求梯度下降同时更新损失函数中含有的所有参数的要求。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>学习率的不确定性所带来的一系列问题，比如若学习率过大，导致每次更新的步长过大，而过大的步长有可能并不符合实际更新的情况，导致了过大的学习率会使不断更新的参数在最值点上方震荡，甚至直接跨过最值点使损失函数值不断增大，无法逼近最值点；如果学习率过小，尽管较小的学习率符合我们梯度下降的数学原理，可以求得较为准确的符合我们预期的参数值。但是同时，过小的学习率会使更新的速度较慢，在计算中往往导致浪费计算机时间与性能，在我们的日常实际生活运用中可能会等不及出结果。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>通常刚开始，初始点会距离极值点比较远，所以使用大一点的学习率。而更新好几次参数之后呢，此时的参数点比较靠近最低点，故而可适当减小学习率。即随着次数的增加，使学习率的大小与更新次数呈负相关，例如采取将学习率除以次数加一的开根号$lr/\sqrt{t+1} \quad$等方法。</p><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><h4 id="AdaGrad算法（适应性梯度算法）："><a href="#AdaGrad算法（适应性梯度算法）：" class="headerlink" title="AdaGrad算法（适应性梯度算法）："></a>AdaGrad算法（适应性梯度算法）：</h4><p>每个参数的学习率都除上之前该参数所有微分的均方根[。为每一个参数保留一个学习率以提升在稀疏梯度上的性能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr_b += b_grad ** <span class="number">2</span></span><br><span class="line">b -= lr/np.sqrt(lr_b) * b_grad</span><br></pre></td></tr></table></figure></p><p>适应性梯度算法中的学习率($\eta_t/\sigma_t$)由两部分组成，其中 $\eta_t=\eta/\sqrt{t+1} \quad$即随着迭代次数的增加，不断削减学习率使每次更新的步长不断变小。$\sigma_t=\sqrt{\frac{\sum_{i=1}^t(g^i)^2\quad}{(t+1)}} \quad$即之前该参数所有微分和的均方根，用此作为分母用意在：如果走到当前点的微分过小，可以控制学习率让其步长适当增大一点；如果走到当前点的微分过大，通过控制学习率使其步长适当减小一点。如此，得到我们的学习率$\frac{\eta_t}{\sigma_t}=\frac{\eta}{\sqrt{\sum_{i=1}^t(g^i)^2\quad} \quad}g^t$接下来给出更本质的解释：适应性梯度算法中学习率近似于(|一阶导数|/二阶导数)。对于只有一个自变量的函数，我们可以用其一阶导数来表示该点的下降速率。但是对于有多个自变量的函数，每更新一次，所选取合适点的标准如果只有一阶导数唯一一个衡量标准显然是不合适的。而二次微分可以在一定程度上反映出当前点到偏导为0的驻点的距离。综合考虑着这两个因子，可以较好地提供出一个符合我们期望的学习率。而对于二次微分，我们用一次微分的均方根来表示，它可以在一定程度上反映二次微分的大小。例如如果二次微分较小，则一次微分图像斜率较缓，那么一次微分的均方根相对而言会较小。适应性梯度算法最好的举例便是一元二次函数 ，其最佳步长为 即|2ax+b|/2a上下分别是该一元二次函数的一次微分和二次微分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">w_init = <span class="number">4.2</span></span><br><span class="line">b_init = <span class="number">-150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> w_init * x + b_init</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initDate</span><span class="params">()</span>:</span></span><br><span class="line">    x_data = []</span><br><span class="line">    y_data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        x = random.randint(<span class="number">-99</span>,<span class="number">99</span>)</span><br><span class="line">        x_data.append(x)</span><br><span class="line">        y_data.append(f(x)+f(x)/<span class="number">10</span>*random.randint(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 给数据加点噪声，使过程更加真实一点</span></span><br><span class="line">    <span class="keyword">return</span> x_data,y_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exhaustion</span><span class="params">(x_data,y_data)</span>:</span></span><br><span class="line">    <span class="comment"># 通过穷举法试探出使均方误差最小的一组b&amp;w</span></span><br><span class="line">    x = np.arange(-abs(<span class="number">1.5</span>*b_init),abs(<span class="number">1.5</span>*b_init),abs(b_init)/<span class="number">20</span>) <span class="comment">#bias</span></span><br><span class="line">    Y= np.arange(-abs(<span class="number">1.5</span>*w_init),abs(<span class="number">1.5</span>*w_init),abs(w_init)/<span class="number">20</span>) <span class="comment">#weight</span></span><br><span class="line">    Z = np.zeros((len(x),len(y)))</span><br><span class="line">    X,Y = np.meshgrid(x,y)</span><br><span class="line">    <span class="comment">#return两个矩阵,X的行向量是向量x的简单复制,Y的列向量是向量y的简单复制    </span></span><br><span class="line">    x_data = np.array(x_data)</span><br><span class="line">    y_data = np.array(y_data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y)):</span><br><span class="line">            b = x[i]</span><br><span class="line">            w = y[j]</span><br><span class="line">            Z[j][i] = ((y_data - b - w * x_data)**<span class="number">2</span>).sum()/len(x_data)</span><br><span class="line">            <span class="comment"># Z值最小的那一组x[i]y[j]就是我们所期望的使f值最小的b，w        </span></span><br><span class="line">    <span class="keyword">return</span> X,Y,Z</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(x_data,y_data)</span>:</span></span><br><span class="line">    <span class="comment">#initial:</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    w = <span class="number">0</span></span><br><span class="line">    lr = <span class="number">1</span> <span class="comment"># learning rate</span></span><br><span class="line">    iteration = <span class="number">100000</span></span><br><span class="line">    b_history = [b]</span><br><span class="line">    w_history = [w]</span><br><span class="line"><span class="comment"># 我们实际用gandient descent求出的b&amp;w</span></span><br><span class="line"></span><br><span class="line">    lr_b = <span class="number">0</span></span><br><span class="line">    lr_w = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    <span class="comment">#不断向偏导为0的驻点靠拢，以获取均方误差最小的一组解w、b    </span></span><br><span class="line">        x = np.array(x_data)</span><br><span class="line">        y = np.array(y_data) </span><br><span class="line">        b_grad = <span class="number">-2.0</span>*(y - b - w*x)</span><br><span class="line">        w_grad = <span class="number">-2.0</span>*(y - b - w*x)*x</span><br><span class="line">        b_grad = b_grad.sum()/len(x)</span><br><span class="line">        w_grad = w_grad.sum()/len(x)</span><br><span class="line"></span><br><span class="line">        lr_b += b_grad ** <span class="number">2</span></span><br><span class="line">        lr_w += w_grad ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#update parameters: </span></span><br><span class="line">        b -= lr/np.sqrt(lr_b) * b_grad</span><br><span class="line">        w -= lr/np.sqrt(lr_w) * w_grad</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#store parameters for plotting:</span></span><br><span class="line">        b_history.append(b)</span><br><span class="line">        w_history.append(w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b_history,w_history</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPicture</span><span class="params">(b_history,w_history,X,Y,Z)</span>:</span></span><br><span class="line">    plt.figure(<span class="string">'gradient_descent'</span>)</span><br><span class="line">    plt.contourf(X,Y,Z,<span class="number">50</span>,alpha=<span class="number">0.5</span>,cmap=plt.get_cmap(<span class="string">'jet'</span>))</span><br><span class="line">    plt.plot([b_init],[w_init],<span class="string">'x'</span>,ms=<span class="number">12</span>,markeredgewidth=<span class="number">3</span>,color=<span class="string">'orange'</span>)</span><br><span class="line">    plt.plot(b_history,w_history,<span class="string">'o-'</span>,ms=<span class="number">3</span>,lw=<span class="number">1.5</span>,color=<span class="string">'black'</span>)</span><br><span class="line">    plt.xlim(-abs(<span class="number">1.5</span>*b_init),abs(<span class="number">1.5</span>*b_init))</span><br><span class="line">    plt.ylim(-abs(<span class="number">1.5</span>*w_init),abs(<span class="number">1.5</span>*w_init))</span><br><span class="line">    plt.xlabel(<span class="string">r'$b$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.ylabel(<span class="string">r'$w$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get3D</span><span class="params">(b_history,w_history,X,Y,Z)</span>:</span></span><br><span class="line">    <span class="comment">#为了画好看的三维图并考虑到memory error强行又弄了组数据</span></span><br><span class="line">    b_h = b_history[::<span class="number">1000</span>]</span><br><span class="line">    w_h = w_history[::<span class="number">1000</span>]</span><br><span class="line">    B,W = np.meshgrid(b_h,w_h)</span><br><span class="line">    Q = np.zeros(len(b_h))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b_h)):    </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">            Q[i] = Q[i] + (y_data[n] - b_h[i] - w_h[i] * x_data[n])**<span class="number">2</span> </span><br><span class="line">        Q[i] = Q[i]/len(x_data) <span class="comment"># 均方误差</span></span><br><span class="line">        </span><br><span class="line">    ax = Axes3D(plt.figure(<span class="string">'三维图'</span>))</span><br><span class="line">    ax.plot_surface(X,Y,Z,cmap = <span class="string">'rainbow'</span>)</span><br><span class="line">    ax.plot([b_init],[w_init],<span class="string">'x'</span>,ms=<span class="number">12</span>,markeredgewidth=<span class="number">3</span>,color = <span class="string">'orange'</span>)</span><br><span class="line">    ax.plot(b_h,w_h,Q,<span class="string">'o-'</span>,ms=<span class="number">3</span>,lw=<span class="number">1.5</span>,color=<span class="string">'black'</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">'--b--'</span>)  </span><br><span class="line">    ax.set_ylabel(<span class="string">'--w--'</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">'--z--'</span>)</span><br><span class="line">    ax.set_title(<span class="string">'3D'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initPicture</span><span class="params">(b,w)</span>:</span></span><br><span class="line">    plt.figure(<span class="string">'initial'</span>)</span><br><span class="line">    x = np.linspace(<span class="number">-99</span>,<span class="number">99</span>) </span><br><span class="line">    y_init = f(x) <span class="comment"># 所求目标函数的函数值</span></span><br><span class="line">    y_grad = w*x+b <span class="comment"># 梯度下降求出的函数所对应的函数值</span></span><br><span class="line">    plt.plot(x,y_init,<span class="string">'.'</span>)</span><br><span class="line">    plt.plot(x,y_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    x_data,y_data = initDate() <span class="comment"># 获取实验数据</span></span><br><span class="line">    X,Y,Z = exhaustion(x_data,y_data) <span class="comment"># X&amp;Y为网格图，Z为其函数值</span></span><br><span class="line">    b_history,w_history = gradientDescent(x_data,y_data)</span><br><span class="line">    b = b_history[<span class="number">-1</span>];print(b)</span><br><span class="line">    w = w_history[<span class="number">-1</span>];print(w)</span><br><span class="line">    </span><br><span class="line">    getPicture(b_history,w_history,X,Y,Z) <span class="comment"># 绘制图像</span></span><br><span class="line">    get3D(b_history,w_history,X,Y,Z)</span><br><span class="line">    initPicture(b,w)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><h4 id="SGD算法（Stochastic-Gradient-Descent随机梯度下降算法）："><a href="#SGD算法（Stochastic-Gradient-Descent随机梯度下降算法）：" class="headerlink" title="SGD算法（Stochastic Gradient Descent随机梯度下降算法）："></a>SGD算法（Stochastic Gradient Descent随机梯度下降算法）：</h4><p>随机梯度下降算法与基础的梯度下降极为相似，唯一的不同点在于它是从某一个样本点出发而并非像梯度下降算法那样每次都考虑整体的数值同时更新。随机梯度下降算法的优点是很明显的，计算的速度和效率要比普通的梯度下降快得多。而这样所带来的缺点就是随机梯度下降算法的路线可能会不断抖动，并且可能优化过程充满震荡，但同时，正是因为这种大幅度的震荡，有时可以解决大部分梯度下降算法都会面临的一个绝对难题，即“陷进”局部最小值点。大部分梯度下降算法在优化过程中很可能会被困在某个驻点，而随机梯度下降算法有时可以通过优化过程的抖动而逃离当前的局部最小值点。这也是很多自适应优化算法在实际训练出的结果都不如随机梯度下降算法的原因。</p><h4 id="Momentum算法（动量算法）："><a href="#Momentum算法（动量算法）：" class="headerlink" title="Momentum算法（动量算法）："></a>Momentum算法（动量算法）：</h4><p>momentum即动量，该算法在普通的梯度下降中引入了动量这个因子是因为普通的梯度下降算法，在每一次更新完成后在当前点的附近邻域上所求得的局部最小值点的方向很大可能是和之前一步的方向几乎相反的，这就导致了普通梯度下降算法在更新当前点时很容易不断震荡，效率低下不符合我们的期望。由此我们采用了动量算法，即增加一个变量v表示速度更新，在每次参数更新的时候加上计算出的当前的速度更新值v= γ· v - η·grad（其中参数γ为衰减权重，一般为0.9，可以让早期的梯度对当前梯度的影响越来越小）其中这个0.9倍上一个点的梯度下降方向就表示了当前该点的动量，让该动量与当前点的梯度方向做矢量和。之后将原参数更新θ = θ + v即可。这样每次更新就会多更新一部分上一次迭代的更新量，来平滑这一次迭代的梯度。从物理的角度来解释，就像是一个小球在滚落的过程中会受其自身的历史动量所影响，所以才称为动量算法。动量算法中学习率越大（实际情况中一般学习率比较小，例如0.001），当前梯度对现在更新的影响也就越大；v中含有所有速度更新值，可以反映历史时刻梯度方向。而由于动量积攒了历史的梯度，如点P前一刻的梯度与当前的梯度方向几乎相反。因此原本在P点原本要大幅徘徊的梯度，主要受到前一时刻的影响，而导致在当前时刻的梯度幅度减小。要是当前时刻的梯度与历史时刻梯度方向相似，这种趋势在当前时刻则会加强；要是不同，则当前时刻的梯度方向减弱。</p><h4 id="NAG算法（牛顿动量算法Nesterov-accelerated-gradient）："><a href="#NAG算法（牛顿动量算法Nesterov-accelerated-gradient）：" class="headerlink" title="NAG算法（牛顿动量算法Nesterov accelerated gradient）："></a>NAG算法（牛顿动量算法Nesterov accelerated gradient）：</h4><p>由之前所说，动量算法每下降一步都是由前面下降方向的一个累积和当前点的梯度方向组合而成。那么既然每一步都要将两个梯度方向（历史梯度、当前梯度）做一个合并再下降，那为什么不先按照历史梯度往前走那么一小步，按照前面一小步位置的“超前梯度”来做梯度合并呢？所以牛顿动量算法和动量算法唯一的区别就在于它的梯度不是根据当前参数位置，而是根据先走了一步本来计划要走的一步后达到参数的位置计算出来的。具体做法为先临时更新θ’ = θ + γ· v然后计算临时点的梯度grad’并计算出速度更新v= γ· v - η·grad’最后应用更新θ = θ + v即可。牛顿动量算法其实是相比于动量算法多考虑了本次梯度相对于上次梯度的变化量，而这个变化量本质是对于目标函数二阶导的近似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梯度下降算法是机器学习领域中非常常用的优化算法。本文通过对梯度下降算法、AdaGrad算法、SGD算法、动量算法以及牛顿动量算法的介绍，将比较基础的梯度下降算法变种介绍给读者。
    
    </summary>
    
    
      <category term="机器学习" scheme="https://stardust567.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://stardust567.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大二" scheme="https://stardust567.github.io/tags/%E5%A4%A7%E4%BA%8C/"/>
    
      <category term="优化算法" scheme="https://stardust567.github.io/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
