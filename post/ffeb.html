<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">










  <meta name="baidu-site-verification" content="HqDOiGSjrA">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/star.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/star.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/star.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="GAP,OS,MIT,6.828,">










<meta name="description" content="结合 MIT-6.828-2019 的各个 lab 来简单写下学习操作系统的学习心得。">
<meta name="keywords" content="GAP,OS,MIT,6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828">
<meta property="og:url" content="https://stardust567.github.io/post/ffeb.html">
<meta property="og:site_name" content="Star Trail">
<meta property="og:description" content="结合 MIT-6.828-2019 的各个 lab 来简单写下学习操作系统的学习心得。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2020/06/16/J9gEbckrvpmwqOf.png">
<meta property="og:image" content="https://i.loli.net/2020/10/04/JLqajpNC5sBvr3Z.png">
<meta property="og:updated_time" content="2020-10-06T08:37:51.899Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828">
<meta name="twitter:description" content="结合 MIT-6.828-2019 的各个 lab 来简单写下学习操作系统的学习心得。">
<meta name="twitter:image" content="https://i.loli.net/2020/06/16/J9gEbckrvpmwqOf.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://stardust567.github.io/post/ffeb.html">






  <title>MIT 6.828 | Star Trail</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '130666690', 'auto');
  ga('send', 'pageview');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Star Trail</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">stardust1084062596@gmail.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-link">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br>
            
            友链
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://stardust567.github.io/post/ffeb.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stardust567">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Star Trail">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT 6.828</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">写于</span>
              
              <time title="写于" itemprop="dateCreated datePublished" datetime="2020-06-03T13:32:51+08:00">
                2020-06-03
              </time>
            

            

            
          </span>
			
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">归档</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Sys/" itemprop="url" rel="index">
                    <span itemprop="name">Sys</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/ffeb.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/post/ffeb.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/post/ffeb.html" class="leancloud_visitors" data-flag-title="MIT 6.828">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">翻阅&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">共计&#58;</span>
                
                <span title="共计">
                  9.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">时长 &asymp;</span>
                
                <span title="时长">
                  49 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>结合 MIT-6.828-2019 的各个 lab 来简单写下学习操作系统的学习心得。<a id="more"></a></p>
<p>在进行相关labs前建议先看看xv6的<a href="https://github.com/ranxian/xv6-chinese" target="_blank" rel="noopener">中文文档</a>（当然能直接看英文文档更好）</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>实名羡慕MIT学生不用搭建xv6环境，直接ssh连接MIT提供的配好的环境就可。</p>
<blockquote>
<p>xv6 is a re-implementation of Dennis Ritchie’s and Ken Thompson’s Unix Version 6 (v6).  xv6 loosely follows the structure and style of v6, but is implemented for a modern RISC-V multiprocessor using ANSI C.</p>
</blockquote>
<p>我个人使用的虚拟机，但不建议用ubuntu，那个小水管的网速属实堪忧，哪怕找到了gitee镜像，但我下的时候qemu还是10kb/s上下浮动，同时还伴有EOF error，后来索性改用debian，瞬间幸福感就起来了QAQ</p>
<p>根据<a href="https://pdos.csail.mit.edu/6.828/2019/tools.html" target="_blank" rel="noopener">MIT 6.828官方指南</a>使用Debian只需一行就能搞定。但我一开始忽略了小字，Debian要做6.828fall19实验的话，不能安装稳定版本buster，需要安装测试版本bullseye。安装完buster一顿操作猛如虎的我不禁流出泪来QAQ</p>
<p>安装好bullseye后<code>su root</code>切到root账号执行工具下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切root后建议先修改/etc/sudoers来把用户的权限提上来</p>
</blockquote>
<h2 id="构建xv6"><a href="#构建xv6" class="headerlink" title="构建xv6"></a>构建xv6</h2><p>打开xv6-riscv-fall19文件夹后<code>make</code>操作无误后再输入<code>make qemu</code>如果这时报错<em>Cannot allocate memory</em>可能是设置虚拟机时候内存设小了，我设2G内存时候就会报错，可以<code>free -m</code>看一看那一点点可用内存，还是乖乖设置成4G比较合适，至少我能跑通了（感天动地）成功后有如下输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtio disk init 0</span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p>
<p>我们可以用ls查看一下初始的文件系统里都有啥programs/files：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 1982</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 22568</span><br><span class="line">echo           2 5 21456</span><br><span class="line">forktest       2 6 11768</span><br><span class="line">grep           2 7 25960</span><br><span class="line">init           2 8 22168</span><br><span class="line">kill           2 9 21400</span><br><span class="line">ln             2 10 21360</span><br><span class="line">ls             2 11 24856</span><br><span class="line">mkdir          2 12 21512</span><br><span class="line">rm             2 13 21496</span><br><span class="line">sh             2 14 40280</span><br><span class="line">stressfs       2 15 22496</span><br><span class="line">usertests      2 16 107504</span><br><span class="line">wc             2 17 23720</span><br><span class="line">zombie         2 18 20888</span><br><span class="line">cow            2 19 28840</span><br><span class="line">uthread        2 20 24528</span><br><span class="line">call           2 21 21456</span><br><span class="line">kalloctest     2 22 26296</span><br><span class="line">bcachetest     2 23 27400</span><br><span class="line">mounttest      2 24 33064</span><br><span class="line">crashtest      2 25 22616</span><br><span class="line">console        3 26 0</span><br></pre></td></tr></table></figure></p>
<p><strong>退出qemu就比较玄妙了，先按下Ctrl 键和A键, 然后释放这两个键，再按X键即可退出，不能同时按三个键哦。</strong></p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><style>
table th:nth-of-type(1){width: 30%;}
table th:nth-of-type(2){width: 70%;}
</style>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">system call</th>
<th style="text-align:left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fork()</td>
<td style="text-align:left">Create a process</td>
</tr>
<tr>
<td style="text-align:left">exit(xstatus)</td>
<td style="text-align:left">Terminate the current process with xstatus indicating success or  failure</td>
</tr>
<tr>
<td style="text-align:left">wait(*xstatus)</td>
<td style="text-align:left">Wait for a child process to exit and copy the child’s exit status to xstatus</td>
</tr>
<tr>
<td style="text-align:left">kill(pid)</td>
<td style="text-align:left">Terminate process pid</td>
</tr>
<tr>
<td style="text-align:left">getpid()</td>
<td style="text-align:left">Return the current process’s pid</td>
</tr>
<tr>
<td style="text-align:left">sleep(n)</td>
<td style="text-align:left">Sleep for n clock ticks</td>
</tr>
<tr>
<td style="text-align:left">exec(filename, *argv)</td>
<td style="text-align:left">Load an executable file and execute it</td>
</tr>
<tr>
<td style="text-align:left">sbrk(n)</td>
<td style="text-align:left">Grow process’s memory by n bytes</td>
</tr>
<tr>
<td style="text-align:left">open(filename, flags)</td>
<td style="text-align:left">Open a file; the flags indicate read/write</td>
</tr>
<tr>
<td style="text-align:left">read(fd, buf, n)</td>
<td style="text-align:left">Read n bytes from an open file into buf</td>
</tr>
<tr>
<td style="text-align:left">write(fd, buf, n)</td>
<td style="text-align:left">Write n bytes to an open file</td>
</tr>
<tr>
<td style="text-align:left">close(fd)</td>
<td style="text-align:left">Release open file fd</td>
</tr>
<tr>
<td style="text-align:left">dup(fd)</td>
<td style="text-align:left">Duplicate fd</td>
</tr>
<tr>
<td style="text-align:left">pipe(p)</td>
<td style="text-align:left">Create a pipe and return fd’s in p</td>
</tr>
<tr>
<td style="text-align:left">chdir(dirname)</td>
<td style="text-align:left">Change the current directory</td>
</tr>
<tr>
<td style="text-align:left">mkdir(dirname)</td>
<td style="text-align:left">Create a new directory</td>
</tr>
<tr>
<td style="text-align:left">mknod(name, major, minor)</td>
<td style="text-align:left">Create a device file</td>
</tr>
<tr>
<td style="text-align:left">fstat(fd)</td>
<td style="text-align:left">Return info about an open file</td>
</tr>
<tr>
<td style="text-align:left">link(f1, f2)</td>
<td style="text-align:left">Create another name (f2) for the file f1</td>
</tr>
<tr>
<td style="text-align:left">unlink(filename)</td>
<td style="text-align:left">Remove a file</td>
</tr>
</tbody>
</table>
</div>
<p>讲道理，写过操作系统实验的对上面xv6提供的系统调用大部分应该都蛮熟的，拿个简单例子演示一下，像fork父进程中return子进程PID，子进程中return0就不多说了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent: child=%d\en"</span>, pid);</span><br><span class="line">	pid = wait(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child %d is done\en"</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child: exiting\en"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fork error\en"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程一旦调用了wait就立即阻塞自己，由wait自动分析当前进程是否有子进程退出，如果找到了一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回子进程的pid；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>
<blockquote>
<p>child: exiting<br>parent: child=31<br>child 31 is done</p>
</blockquote>
<p>下面代码截取自常用的cat程序，从标准输入复制数据到标准输出。<code>read(fd, buf, n)</code>，最多从fd对应文件里读n bytes到buf中，return读取的字节数。<code>write(fd, buf, n)</code>最多从buf里写n bytes到fd对应文件中，return 写入的字节数。<code>n = read() / write()</code>每次读写都会把对应fd的offset往前推n bytes，让读写可以源源不断的按序进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"read error\en"</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(write(<span class="number">1</span>, buf, n) != n)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"write error\en"</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Talk is cheap，我们尝试下6.828的第一个简单的exercise，在xv6/user/下写一个sleep.c吧：</p>
<blockquote>
<p>Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. (A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip.) Your solution should be in the file <code>user/sleep.c</code>.</p>
</blockquote>
<p>TIPS: The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user/ulib.c)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) write(<span class="number">2</span>, <span class="string">"Error message"</span>, <span class="built_in">strlen</span>(<span class="string">"Error message"</span>));</span><br><span class="line">    <span class="keyword">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开Makefie输入<code>/UPROGS</code>定位以后加上<code>$U/_sleep\</code>然后wq再键入 <code>make fs.img</code>编译user programs即可。完成之后make qemu输入<code>sleep 20</code>测试下功能是否正常。</p>
<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent sends by writing a byte to <code>parent_fd[1]</code> and the child receives it by reading from <code>parent_fd[0]</code>. After receiving a byte from parent, the child responds with its own byte by writing to <code>child_fd[1]</code>, which the parent then reads. Your solution should be in the file <code>user/pingpong.c</code>.</p>
</blockquote>
<p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors.</p>
<p>父进程-&gt;pfd1-&gt;pipe-&gt;pfd0-&gt;子进程；子进程-&gt;cfd1-&gt;pipe-&gt;cfd0-&gt;父进程。一个pipe(fd)只能单向传递，fd[0]表示读端, fd[1]表示写端。所以要开两个pipe，大概是pipe([pfd0, pfd1]), pipe([cfd0, cfd1])这样。pipe会修改传进去的fd数组，所以不用担心没有初始化的问题，fork之后父子进程就可以借此完成通信了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent_fd[<span class="number">2</span>], child_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(parent_fd); pipe(child_fd);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        write(parent_fd[<span class="number">1</span>], <span class="string">"ping"</span>, <span class="number">4</span>);</span><br><span class="line">        read(child_fd[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, getpid(), buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(parent_fd[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received %s\n"</span>, getpid(), buf);</span><br><span class="line">        write(child_fd[<span class="number">1</span>], <span class="string">"pong"</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/" target="_blank" rel="noopener">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">source</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">36</span>; i++) write(<span class="number">1</span>, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (read(<span class="number">0</span>, &amp;n, <span class="keyword">sizeof</span>(n))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % p != <span class="number">0</span>) write(<span class="number">1</span>, &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> pd[])</span> </span>&#123;</span><br><span class="line">  close(k);</span><br><span class="line">  dup(pd[k]);</span><br><span class="line">  close(pd[<span class="number">0</span>]);</span><br><span class="line">  close(pd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pd[<span class="number">2</span>];<span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;p, <span class="keyword">sizeof</span>(p))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prime %d\n"</span>, p);</span><br><span class="line">    pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      redirect(<span class="number">0</span>, pd);</span><br><span class="line">      sink();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      redirect(<span class="number">1</span>, pd);</span><br><span class="line">      cull(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">int</span> pd[<span class="number">2</span>];pipe(pd);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    redirect(<span class="number">0</span>, pd);</span><br><span class="line">    sink();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    redirect(<span class="number">1</span>, pd);</span><br><span class="line">    source();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree whose name matches a string. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<p>在xv6中一个文件夹实质上是一个包含了很多<code>dirent</code>结构体的文件，每个结构体就是iNode和文件名的打包。我们可以传<code>struct stat st</code>进fstat函数来判断文件类型(dir or file)，递归find时要跳过<code>.</code>和<code>..</code>两个特殊路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DIR 1 	<span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_FILE 2 	<span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEVICE 3 	<span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> dev; 		<span class="comment">// File system’s disk device</span></span><br><span class="line">	uint ino; 		<span class="comment">// Inode number</span></span><br><span class="line">	<span class="keyword">short</span> type; 	<span class="comment">// Type of file</span></span><br><span class="line">	<span class="keyword">short</span> nlink; 	<span class="comment">// Number of links to file</span></span><br><span class="line">	uint64 size; 	<span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">	ushort inum;</span><br><span class="line">	<span class="keyword">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fmtname</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">'/'</span>; p--);</span><br><span class="line">    <span class="keyword">return</span> ++p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* path, <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot open %s\n"</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: cannot stat %s\n"</span>, path);</span><br><span class="line">	    close(fd);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">	    <span class="keyword">case</span> T_FILE:</span><br><span class="line">	        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(path), name) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, path);</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> T_DIR:</span><br><span class="line">	        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">	            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: path too long\n"</span>);</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">	        <span class="keyword">char</span>* p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">	        *p++ = <span class="string">'/'</span>;</span><br><span class="line">	        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (de.inum == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">"."</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">".."</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	            memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                find(buf, name);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>) <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"find: not enough params provided"</span>);</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>char* fmtname(char *path)</code>函数是白嫖的ls.c源码，不过ls.c里的fmtname函数会截取当前目录文件名后再自动补齐空格到定长，也就是加padding，但是我们需要strcmp比较，肯定不能让它补齐，所以稍微改了一下。</p>
<p><code>if (de.inum == 0) continue</code>这句，这句是xv6自有的<code>ls.c</code>里的源码，官方文档里有这么一句 <strong>Directory entries with inode number zero are free.</strong> 而对于<code>memmove(p, de.name, DIRSIZ)</code>这句，function <strong>void *memmove(void *str1, const void *str2, size_t n)</strong> copies <strong>n</strong> characters from <strong>str2</strong> to <strong>str1</strong></p>
<p><code>char* p = buf + strlen(buf); *p++ = &#39;/&#39;;</code>这个应该不难理解，p初始是把指向buf的指针推strlen(buf)个位置，也即到’/0’的位置，然后把这个位置赋’/‘并把p指针再推一位，之后<code>memmove(p, de.name, DIRSIZ)</code>把de.name全部复制到p指针的位置，然后在复制完的后一个位置把值置0（类似于’/0’，我在printf.c里找到这一句<code>for(; *s; s++) consputc(*s);</code>有理由相信xv6字符串置0是起到了终止符的作用)</p>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>
</blockquote>
<p>大概意思是，除xargs后的参数外，回车后，接收标准输入的每一行为参运行程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARG       32  <span class="comment">// max exec arguments (defined in kernel/param.h)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	argc--;</span><br><span class="line">    argv++;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">char</span> xargv[MAXARG][MAXARG];</span><br><span class="line">  	<span class="keyword">char</span> *pass[MAXARG];</span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXARG; i++) pass[i] = xargv[i];</span><br><span class="line">    <span class="keyword">int</span> xargc = argc;</span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) <span class="built_in">strcpy</span>(xargv[i], argv[i]);</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">char</span> buf[<span class="number">512</span>];<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span> (read(<span class="number">0</span>, buf+index, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) &#123;          </span><br><span class="line">      	<span class="keyword">if</span> (*(buf+index) == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            *(buf+index) = <span class="string">'\0'</span>;</span><br><span class="line">        	<span class="built_in">strcpy</span>(xargv[xargc++], buf);</span><br><span class="line">           	pass[xargc+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (fork()) wait();</span><br><span class="line">    		<span class="keyword">else</span> exec(pass[<span class="number">0</span>], pass);</span><br><span class="line">                </span><br><span class="line">            pass[xargc+<span class="number">1</span>] = xargv[xargc+<span class="number">1</span>];</span><br><span class="line">            xargc = argc;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(*(buf+index) == <span class="string">' '</span>) &#123;</span><br><span class="line">            *(buf+index) = <span class="string">'\0'</span>;</span><br><span class="line">           	<span class="built_in">strcpy</span>(xargv[xargc++], buf);</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用pass而不是直接上xargc是因为exec接收指针数组，但是指针数组赋值时候，不能直接memmove呀，你首先要malloc这就麻烦了，索性干脆传pass进exec，把pass每个指针指向xargc数组始址。至于<code>pass[xargc+1] = 0;</code>，指针赋0表示指针为空，不用担心报错。为了下次继续使用，我们再把<code>pass[xargc+1] = xargv[xargc+1];</code>重新指向xargc即可。</p>
</blockquote>
<p>最后<code>make grade</code>得到 Score: 100/100 的美好分数，感觉世界都美好了起来（虽然才是第一个lab）</p>
<p>当然别忘了push所有的分支到远程仓库以免意外，然后切到新的 sh 分支，准备迎接新的实验。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename origin old_origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://github.com/Stardust567/6.828.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin --all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout sh</span></span><br></pre></td></tr></table></figure>
<h1 id="Simple-xv6-shell"><a href="#Simple-xv6-shell" class="headerlink" title="Simple xv6 shell"></a>Simple xv6 shell</h1><p>Your job is to write a simple shell for xv6. It should be able to run commands with arguments, handle input and output redirection, and set up two-element pipelines. Your shell should act like the xv6 shell <code>sh</code> for these examples as well as similar commands:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo hello there</span><br><span class="line">echo something &gt; file.txt</span><br><span class="line">ls | grep READ</span><br><span class="line">grep lion &lt; data.txt | wc &gt; count</span><br><span class="line">echo echo hello | nsh</span><br><span class="line">find . b | xargs grep hello</span><br></pre></td></tr></table></figure>
<p>You should put your shell source in <code>user/nsh.c</code>, and modify the <code>Makefile</code> to compile it. Your shell should use <code>@</code> (at sign) as a prompt rather than <code>$</code>, to avoid confusion with the real shell.</p>
<p><code>gets()</code>一次读一行，但它不像<code>read()</code>它是读不到’\n’的哦，会自动把’\n’替换成’\0’这个问题坑了我好一会儿。</p>
<p><code>redirect(int k, int pd[])</code>是个重定向函数。dup(fd)调用会复制fd给当前一个当前最小可用描述符，并把这个描述符return出来，这样这两个描述符就会共享一个文件偏移。如果先把fd=1关了，再dup(pd[1])那之后标准输出就会同时写进pd[1]即写入pipe中对pd[1]；如果是把fd=0关了，再dup(pd[0])就会把从pipe中读取的数据作为标准输入看待。当然因为我们是重定向，不是双开，所以只会把管道原先两端fd给close掉。</p>
<p><code>handle</code>，argc从0开始，而不是像main函数中的从1开始。然后对于重定向的处理，我们只用变量pos定位输入输出参数的位置，之后会用pass2把<code>&lt;</code>和<code>&gt;</code>从参数行里过滤掉。然后<code>handle_cmd()</code>开了多个子进程去实现管道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fcntl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARG       32  <span class="comment">// max exec arguments</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replace the left side "|" with "\0"</span></span><br><span class="line"><span class="comment">// return the rest of the string or NULL</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simple_tok</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">char</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">'\0'</span> &amp;&amp; *p != d)  p++;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trim spaces on both side</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">trim</span><span class="params">(<span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *e = c;</span><br><span class="line">    <span class="keyword">while</span> (*e)  e++; <span class="comment">// point to the end</span></span><br><span class="line">    <span class="keyword">while</span> (*c == <span class="string">' '</span>)  *(c++) = <span class="string">'\0'</span>; <span class="comment">// delete spaces on left side</span></span><br><span class="line">    <span class="keyword">while</span> (*(--e) == <span class="string">' '</span>); <span class="comment">// skip spaces on right side</span></span><br><span class="line">    *(e + <span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> pd[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close(k);</span><br><span class="line">    dup(pd[k]);</span><br><span class="line">    close(pd[<span class="number">0</span>]);</span><br><span class="line">    close(pd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cmd = trim(cmd);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> buf[MAXARG][MAXARG]; <span class="keyword">char</span> *pass[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXARG; i++) pass[i] = buf[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>; <span class="keyword">char</span> *c = buf[argc];</span><br><span class="line">    <span class="keyword">int</span> input_pos = <span class="number">0</span>, output_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> *p = cmd; *p; p++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *c = <span class="string">'\0'</span>;</span><br><span class="line">            argc++;</span><br><span class="line">            c = buf[argc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(*p == <span class="string">'&lt;'</span>)  input_pos = argc + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(*p == <span class="string">'&gt;'</span>)  output_pos = argc + <span class="number">1</span>;</span><br><span class="line">            *c++ = *p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gets() returns no '\n'</span></span><br><span class="line">    *c = <span class="string">'\0'</span>;</span><br><span class="line">    argc++;</span><br><span class="line">    pass[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(input_pos) &#123;</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        open(pass[input_pos], O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(output_pos) &#123;</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        open(pass[output_pos], O_WRONLY | O_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pass2[<span class="number">32</span>]; <span class="keyword">int</span> argc2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pos = <span class="number">0</span>; pos &lt; argc; pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == input_pos - <span class="number">1</span>) pos += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == output_pos - <span class="number">1</span>) pos += <span class="number">2</span>;</span><br><span class="line">        pass2[argc2++] = pass[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    pass2[argc2] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        exec(pass2[<span class="number">0</span>], pass2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_cmd</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pd[<span class="number">2</span>];</span><br><span class="line">        pipe(pd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">            <span class="keyword">if</span>(n) redirect(<span class="number">1</span>, pd);</span><br><span class="line">            handle(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n) &#123;</span><br><span class="line">                redirect(<span class="number">0</span>, pd);</span><br><span class="line">                a = n;</span><br><span class="line">                n = simple_tok(a, <span class="string">'|'</span>);</span><br><span class="line">                handle_cmd(a, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> cmd_buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">"@ "</span>);</span><br><span class="line">        <span class="built_in">memset</span>(cmd_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        gets(cmd_buf, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd_buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        *<span class="built_in">strchr</span>(cmd_buf, <span class="string">'\n'</span>) = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *a = cmd_buf;</span><br><span class="line">            <span class="keyword">char</span> *n = simple_tok(a, <span class="string">'|'</span>);</span><br><span class="line">            handle_cmd(a, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真的，别的不多说，当执行<code>testsh nsh</code>后出现 <em>passed all tests</em> 这句的时候，喜极而泣 泣不成声 声泪俱下QAQ</p>
<blockquote>
<p>BTW这个lab我参考sh.c得不多，因为nsh远没有sh复杂，作为lab我觉得不太需要那么严谨的设计，所以更多参考了github上更亲民的设计实现，同时进行了相关的设计修改。</p>
</blockquote>
<h1 id="Allocator-for-xv6"><a href="#Allocator-for-xv6" class="headerlink" title="Allocator for xv6"></a>Allocator for xv6</h1><p>快<code>git fetch</code>后<code>git checkout alloc</code>开始新的lab吧。</p>
<blockquote>
<p>For this lab we have replaced the page allocator in the xv6 kernel with a buddy allocator. You will modify xv6 to use this allocator to allocate and free file structs so that xv6 can have more open file descriptors than the existing system-wide limit <code>NFILE</code>. Furthermore, you will implement an optimization that reduces the buddy’s use of memory. You are done if your modified kernel passes both alloctest and usertests.</p>
</blockquote>
<p>在此之前，我们先来看看xv6文件系统的文件描述符层。UNIX 接口很爽的一点就是大多数的资源都可以用文件来表示，包括终端这样的设备、管道，当然，还有真正的文件。文件描述符层就是实现这种统一性的一层。</p>
<p>xv6 每个进程都有一个自己的打开文件表，每一个打开文件都由结构体 <code>file</code>(3750)表示，它是一个对 i 节点或者管道和文件偏移的封装。每次调用 <code>open</code> 都会创建一个新的打开文件（一个新的 <code>file</code>结构体）。如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的 i/o 偏移。另一方面，同一个文件可以（同一个file结构体）可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现（一个进程用 <code>open</code> 打开了一个文件而后使用 <code>dup</code>，或者把这个文件和子进程共享都会导致这一点发生）对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、写 or both, <code>readable</code>域和<code>writable</code>域记录这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> &#123; FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line"><span class="keyword">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line"><span class="keyword">char</span> readable;</span><br><span class="line"><span class="keyword">char</span> writable;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line"><span class="keyword">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h2><blockquote>
<p>Modify <code>kernel/file.c</code> to use the buddy allocator so that the number of file structures is limited by memory rather than <code>NFILE</code>.</p>
</blockquote>
<h3 id="struct-ftable"><a href="#struct-ftable" class="headerlink" title="struct ftable"></a>struct ftable</h3><p>首先，要舍弃原先方式，我们先把file.c里ftable结构体的<code>struct file file[NFILE]</code>注释掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// struct file file[NFILE];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
<p>系统中所有的打开文件都存在于一个全局的文件表 <code>ftable</code> 中。这个文件表有一个分配文件的函数<code>filealloc</code>，有一个重复引用文件的函数<code>filedup</code>，释放对文件引用的函数<code>fileclose</code>，读和写文件的函数<code>fileread</code> 和 <code>filewrite</code> </p>
<h3 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc()"></a>filealloc()</h3><p><code>filealloc</code> (5225)扫描整个文件表找一个没被引用，即引用数ref=0的文件，然后改完它的ref后把它return出来。但这样整个系统的文件数会被ftable的file数组大小所限制，因而改用伙伴系统bd_malloc()申请新文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="function">struct file* <span class="title">filealloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    </span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void * bd_malloc(uint64 nbytes)</code>会allocate nbytes，但必须大于LEAF_SIZE=16即最小的block size，还有一点，<code>bd_malloc</code> doesn’t clear the memory it returns; instead, allocated memory starts out with whatever content it had from its last use. Callers should not assume that it starts out containing zeroes. 所以需要手动<code>memset(f, 0, sizeof(struct file));</code>置0一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="function">struct file* <span class="title">filealloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    </span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">    </span><br><span class="line">  f = bd_malloc(<span class="keyword">sizeof</span>(struct file));</span><br><span class="line">  <span class="keyword">if</span>(f) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct file));</span><br><span class="line">    f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose()"></a>fileclose()</h3><p><code>fileclose</code> (5264)减少引用计数。当一个文件的引用计数变为0的时候，<code>fileclose</code>就会释放掉当前的管道或者i 节点（根据文件类型的不同）我们在原函数的最后加上bd_free(f)即可。虽然官方说可以优化掉ff，但我实操并没有成功，估计还是对源码领悟不够，这里就先不优化了（TO DO)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fileclose</span><span class="params">(struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>) panic(<span class="string">"fileclose"</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op(ff.ip-&gt;dev);</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op(ff.ip-&gt;dev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// use bd_free()</span></span><br><span class="line">  bd_free(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h2><blockquote>
<p> The buddy allocator is space inefficient. The <code>alloc</code> array has a bit for each block for each size. There is a clever optimization that reduces the cost to only one bit for each pair of blocks. This single bit is B1_is_free XOR B2_is_free, for a buddy pair of blocks B1 and B2. Each time a block is allocated or freed, you flip the bit to reflect the change. For example, if B1 and B2 are allocated, the bit will be zero and if B1 is freed the bit changes to 1. If the bit is 1 and B2 is freed, then we know that B1 and B2 should be merged. Saving 1/2 bit per block matters when xv6 uses the buddy allocator for the roughly 128 Mbyte of free memory that xv6 must manage: this optimization saves about 1 MByte of memory.</p>
</blockquote>
<p>buddy allocator中维护了两个bitset，一个存是否分裂 <code>bd_sizes[k].split</code>，另一个存是否已占用 <code>bd_sizes[k].alloc</code>。根据官方给的提示，编写好bit_toggle()和bit_isset()，并对所有的<code>bd_sizes[k].alloc</code>把bit_set()替换成bit_toggle()并把所有的bit_isset()替换成bit_get()即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return 1 if bit at position index in array is set to 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_isset</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> b = <span class="built_in">array</span>[index/<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> m = (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">  <span class="keyword">return</span> (b &amp; m) == m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bit at position index in array to 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_set</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> b = <span class="built_in">array</span>[index/<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> m = (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">  <span class="built_in">array</span>[index/<span class="number">8</span>] = (b | m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear bit at position index in array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_clear</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> b = <span class="built_in">array</span>[index/<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> m = (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">  <span class="built_in">array</span>[index/<span class="number">8</span>] = (b &amp; ~m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_toggle</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	index &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> m = (<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>));</span><br><span class="line">	<span class="built_in">array</span>[index/<span class="number">8</span>] ^= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_get</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> dex)</span> </span>&#123;</span><br><span class="line">    index &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="built_in">array</span>[index/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span> m = (<span class="number">1</span> &lt;&lt; (index%<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">return</span> (b&amp;m) == m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 buddy allocator 管理内存的同时需要在内存区域头部放一些 metadata，且内核提供内存区域的长度也很可能不是对其 2^k 次方的，故需要把一些区域 mark 为 allocated 。同时这些区域对应的 buddy 可能需要被加入 free_list (<code>bd_initfree()/bd_initfree_pair()</code> 用来完成此工作)</p>
<p>根据 <code>bd_init()</code> 中代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done allocating; mark the memory range [base, p) as allocated, so</span></span><br><span class="line"><span class="comment">// that buddy will not hand out that memory.</span></span><br><span class="line"><span class="keyword">int</span> meta = bd_mark_data_structures(p);</span><br><span class="line"><span class="comment">// mark the unavailable memory range [end, HEAP_SIZE) as allocated,</span></span><br><span class="line"><span class="comment">// so that buddy will not hand out that memory.</span></span><br><span class="line"><span class="keyword">int</span> unavailable = bd_mark_unavailable(end, p);</span><br><span class="line"><span class="keyword">void</span> *bd_end = bd_base+BLK_SIZE(MAXSIZE) - unavailable;</span><br><span class="line"><span class="comment">// initialize free lists for each size kint </span></span><br><span class="line"><span class="built_in">free</span> = bd_initfree(p, bd_end, p, end);</span><br></pre></td></tr></table></figure>
<p>这些不可用内存对应的内存区间为 <code>[begin, p)</code> 和 <code>[end, HEAP_SIZE)</code>。在 <code>bd_initfree_pair()</code> 中特判这些内存范围，就可以把他们的 buddy 识别出来，而无需查找 <code>bd_sizes[k].alloc</code> 。</p>
<h1 id="xv6-lazy-page-allocation"><a href="#xv6-lazy-page-allocation" class="headerlink" title="xv6 lazy page allocation"></a>xv6 lazy page allocation</h1><p>老规矩了， <code>git fetch</code>后<code>git checkout lazy</code> 开始新的lab吧。</p>
<p>一个 x86 页表就是一个包含 2^20（1,048,576）条<em>页表条目</em>（PTE）的数组。每条 PTE 包含了一个 20 位的物理页号（PPN）及一些标志位。分页硬件要找到一个虚拟地址对应的 PTE，只需使用其高20位来找到该虚拟地址在页表中的索引，然后把其高 20 位替换为对应 PTE 的 PPN。而低 12 位是会被分页硬件原样复制的。因此在虚拟地址-物理地址的翻译机制下，页表可以为操作系统提供对一块块大小为 4096（2^12）字节的内存片，这样的一个内存片就是一页。</p>
<p><img src="https://i.loli.net/2020/06/16/J9gEbckrvpmwqOf.png" alt="6828-pageTable.png"></p>
<p>如果用一级页表，那么连续的<em>（`K号页对应的页表项位置 = 页表起始地址 + K </em> 页表项长度`，所以这就要求页表存储必须是连续的）*2^20页表项属实太占空间，本来页表就是为了离散存储，如果整了个巨大的连续页表，显得有些本末倒置。</p>
<p>所以x86采用二级页表，把页表项按页的大小（2^12B）分页离散存在内存中，通过页目录项Dir来定位页表项所在的页框，然后根据Table来确定页表项位置，最后再根据偏移量Offset来确定实际内存地址。</p>
<blockquote>
<p>One of the many neat tricks an O/S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. However, there are programs that use sbrk() to ask for large amounts of memory but never use most of it, for example to implement large sparse arrays. To optimize for this case, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which addresses are allocated. When the process first tries to use any given page of memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p>
</blockquote>
<p>简单说这次lab就是 lazy page allocation，一开始不申请物理内存，只有要用的时候再缺页中断去申请实际内存。</p>
<h2 id="Print-page-table"><a href="#Print-page-table" class="headerlink" title="Print page table"></a>Print page table</h2><blockquote>
<p>It’s often worthwhile to invest time writing code that helps debugging, so your first task is to implement a function that prints the contents of a page table. Define the function in kernel/vm.c; it has the following prototype: <code>void vmprint(pagetable_t)</code>. This function will be handy for debugging and will make you familiar with RISC-V page tables. Insert a call to <code>vmprint</code> in exec.c to print the page table for the first user process.</p>
<p>The first line prints the address of the argument of <code>vmprint</code>. Each PTE line shows the PTE index in its page directory, the pte, the physical address for the PTE. The output should also indicate the level of the page directory: the top-level entries are preceeded by “..”, the next level down with another “..”, and so on. You should not print entries that are not mapped. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printwalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; depth; j++) <span class="built_in">printf</span>(<span class="string">" .."</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d: pte %p pa %p\n"</span>, i, pte, PTE2PA(pte));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      printwalk((<span class="keyword">pagetable_t</span>)child, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, t);</span><br><span class="line">  printwalk(t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们按照官方说明，修改下 /kernel/exec.c 和 /kernel/defs.h即可。最后结果如下：the top-level page directory has mappings for entry 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped. </p>
<blockquote>
<p>page table 0x0000000087f6e000<br> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000<br> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000<br> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000<br> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br> .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000<br> .. .. ..511: pte 0x000000002000200b pa 0x0000000080008000</p>
</blockquote>
<h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h2><blockquote>
<p>Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory — so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
</blockquote>
<p>我们不再调用<code>growproc()</code>，然后考虑到官方说的 <strong>Handle negative sbrk() arguments.</strong>  通过 <code>sbrk</code> 输入负数来归还线性空间时，需要及时释放内存<code>dealloc</code> 。所以将原先的<code>if(growproc(n) &lt; 0) return -1;</code>改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myproc()-&gt;sz += n;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>) uvmdealloc(myproc()-&gt;pagetable, addr, myproc()-&gt;sz);</span><br></pre></td></tr></table></figure>
<p>关于<code>myproc()</code>以下是 myproc() 和 proc 结构体的源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="function">struct proc* <span class="title">myproc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">c</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="keyword">enum</span> procstate state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent's wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// Page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当然，这会出现官方所认证的panic，毕竟事实上我们并没有进行mapping。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ <span class="built_in">echo</span> hi</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> usertrap(): unexpected scause 0x000000000000000f pid=3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             sepc=0x0000000000001258 stval=0x0000000000004008</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> va=0x0000000000004000 pte=0x0000000000000000</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> panic: uvmunmap: not mapped</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><blockquote>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Your solution is acceptable if it passes usertests.</p>
</blockquote>
<p>A good way to start this lab is by fixing <code>usertrap()</code> in <code>trap.c</code> so that you can run “echo hi” in the shell again. 该函数是专门处理中断、异常和系统调用的，<code>r_scause()</code>为13的话是 Page load fault，为15的话是 Page store fault，以此处理逻辑。这里用函数<code>handle_page_fault(p, r_stval())</code>来处理异常的情况然后kill掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle_page_fault(p, r_stval()) == <span class="number">-1</span>)  p-&gt;killed = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们在proc.c里把该函数写好，并把函数头注册到defs.h里。</p>
<ul>
<li><strong>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</strong> </li>
<li><strong>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</strong> </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_page_fault</span><span class="params">(struct proc* p, uint64 addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addr &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 page_addr = PGROUNDDOWN(addr);</span><br><span class="line">  <span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, page_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* printf("page allocated at %p (%d.%d.%d)\n", page_addr,</span></span><br><span class="line"><span class="comment">    PX(2, page_addr),</span></span><br><span class="line"><span class="comment">    PX(1, page_addr),</span></span><br><span class="line"><span class="comment">    PX(0, page_addr)); */</span></span><br><span class="line">  <span class="comment">// vmprint(p-&gt;pagetable);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Handle fork() correctly.</strong></li>
</ul>
<p>在vm.c里的uvmunmap()函数，忽视掉page directory is not mapped定义的panic(“uvmunmap: walk”)和page not mapped定义的panic(“uvmunmap: not mapped”) 注意这两个判断，每个判断成功都应该直接goto到<code>if(a == last) break;</code>语句这。在vm.c里的uvmcopy()函数，忽视掉page may be not present定义的panic(“uvmcopy: pte should exist”)和panic(“uvmcopy: page not present”) 这两个也是每次判断成功都会进入到下一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove mappings from a page table. The mappings in the</span></span><br><span class="line"><span class="comment">// given range must exist. Optionally free the physical memory.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmunmap</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 size, <span class="keyword">int</span> do_free)</span></span>&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">goto</span> next_page;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) <span class="keyword">goto</span> next_page;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V) panic(<span class="string">"uvmunmap: not a leaf"</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">next_page:</span><br><span class="line">    <span class="keyword">if</span>(a == last) <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given a parent process's page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child's page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</strong></li>
</ul>
<p>You can fix it by add code in <code>walkaddr()</code> in <code>kernel/vm.c:104</code>, as any r/w syscall will invoke <code>walkaddr</code> to get physical address. 我们首先可以看下walkaddr函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address,or 0 if not mapped.	</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line"><span class="function">uint64 <span class="title">walkaddr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);	</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	   </span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vm.c加上spinlock.h和proc.h头文件后，我们对walkaddr函数进行修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">walkaddr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">int</span> page_grant = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>) page_grant = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>) page_grant = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>) page_grant = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (page_grant) pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    p = myproc();</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      uint64 page_addr = PGROUNDDOWN(va);</span><br><span class="line">      mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, page_addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pa = (uint64) mem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Handle faults on the invalid page below the stack.</strong></li>
</ul>
<p>As the page below the stack is set PTE_V but not set PTE_U, you can distinguish it in <code>mappages()</code> at vm.c:164. 在vm.c里的mappages()函数把if(*pte &amp; PTE_V)  panic(“remap”);修改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_U) panic(<span class="string">"remap"</span>);	</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h1><p>To start the lab, switch to the trap branch:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout syscall</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Before writing code, you should make sure you have read “Chapter 6: Scheduling” from the <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf" target="_blank" rel="noopener">xv6 book</a> and studied the corresponding code.</p>
</blockquote>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p> 关于IO多路复用，可以看上一篇 <a href="https://stardust567.github.io/post/ddca.html">Linux IO</a> 来回顾一下知识点: )</p>
<p>关于xv6的IO多路复用，实现如下：当一个进程等待磁盘请求时，xv6 使之进入睡眠状态，然后调度执行另一个进程。另外，当一个进程耗尽了它在处理器上运行的时间片（100ms）后，xv6 使用时钟中断强制它停止运行，这样调度器才能调度运行其他进程。这样的多路复用机制为进程提供了独占处理器的假象，类似于 xv6 使用内存分配器和页表硬件为进程提供了独占内存的假象。</p>
<h3 id="xv6进程切换"><a href="#xv6进程切换" class="headerlink" title="xv6进程切换"></a>xv6进程切换</h3><ol>
<li>如何让上下文切换透明化？xv6 只简单地使用时钟中断处理程序来驱动上下文切换。</li>
<li>可能出现多个 CPU 同时切换进程的情况，所以必须使用一个带锁的方案来避免竞争。</li>
<li>进程退出时必须释放其占用内存与资源，但由于它本身在使用自己的资源（譬如其内核栈），所以不能由该进程本身释放其占有的所有资源。</li>
</ol>
<p>同时xv6 必须为进程提供互相协作的方法。譬如，父进程需要等待子进程结束，以及读取管道数据的进程需要等待其他进程向管道中写入数据。与其让这些等待中的进程消耗 CPU 资源，不如让它们暂时放弃 CPU，进入睡眠状态来等待其他进程发出事件来唤醒它们。但我们必须要小心设计以防睡眠进程遗漏事件通知。</p>
<p><img src="https://i.loli.net/2020/10/04/JLqajpNC5sBvr3Z.png" alt="6828-processSwitch.png"><br>如图，xv6 在低层次中实现了两种上下文切换：从进程的内核线程切换到当前 CPU 的调度器线程，从调度器线程到进程的内核线程。xv6 永远不会直接从用户态进程切换到另一个用户态进程；这种切换是通过用户态-内核态切换（系统调用或中断）、切换到调度器、切换到新进程的内核线程、最后这个陷入返回实现的。</p>
<p>每个 xv6 进程都有自己的内核栈以及寄存器集合。每个 CPU 都有一个单独的调度器线程，这样调度就不会发生在进程的内核线程中，而是在此调度器线程中。线程的切换涉及到了保存旧线程的 CPU 寄存器，恢复新线程之前保存的寄存器；其中  <code>%esp</code> 和 <code>%eip</code> 的变换意味着 CPU 会切换运行栈与运行代码。</p>
<p><code>swtch</code> 并不了解线程，它只是简单地保存和恢复寄存器集合，即<strong>上下文</strong>。当进程让出 CPU 时，进程的内核线程调用 <code>swtch</code> 来保存自己的上下文然后返回到调度器的上下文中。每个上下文都是以结构体 <code>struct context*</code> 表示的，这实际上是一个保存在内核栈中的指针。<code>swtch</code> 有两个参数：<code>struct context **old</code>、<code>struct context *new</code>。它将当前 CPU 的寄存器压入栈中并将栈指针保存在 <code>*old</code> 中。然后 <code>swtch</code> 将 <code>new</code> 拷贝到 <code>%esp</code> 中，弹出之前保存的寄存器，然后返回。</p>
<ul>
<li><strong>可能出现多个 CPU 同时切换进程的情况，所以必须使用一个带锁的方案来避免竞争。</strong></li>
</ul>
<p>如果将 <code>swtch</code> 看做一个既有功能。进程想要让出 CPU 必须要获得进程表的锁 <code>ptable.lock</code>，并释放其拥有的其他锁，修改自己的状态（<code>proc-&gt;state</code>），然后调用 <code>sched</code>。在对 <code>swtch</code> 的调用的整个过程中，xv6 都持有锁 <code>ptable.lock</code>：<code>swtch</code> 的调用者必须持有该锁，并将锁的控制权转移给切换代码。锁的这种使用方式很少见，通常来说，持有锁的线程应该负责释放该锁，这样更容易让我们理解其正确性。但对于上下文切换来说，我们必须使用这种方式，因为 <code>ptable.lock</code> 会保证进程的 <code>state</code> 和 <code>context</code> 在运行 <code>swtch</code> 时保持不变。如果在 <code>swtch</code> 中没有持有 <code>ptable.lock</code>，可能引发这样的问题：在 <code>yield</code> 将某个进程状态设置为 <code>RUNNABLE</code> 之后，但又是在 <code>swtch</code> 让它停止在其内核栈上运行之前，有另一个 CPU 要运行该进程。其结果将是两个 CPU 都运行在同一个栈上，这显然是不该发生的。</p>
<h2 id="Warmup-RISC-V-assembly"><a href="#Warmup-RISC-V-assembly" class="headerlink" title="Warmup: RISC-V assembly"></a>Warmup: RISC-V assembly</h2><p>There is a file user/call.c in your xv6 repo. make fs.img builds a user program call and a readable assembly version of the program in user/call.asm.</p>
<p>打开 <code>user/call.c</code> ，有如下代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>user/call.asm</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000000001</span>c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>c:	<span class="number">1141</span>                	addi	sp,sp,<span class="number">-16</span></span><br><span class="line">  <span class="number">1</span>e:	e406                	sd	ra,<span class="number">8</span>(sp)</span><br><span class="line">  <span class="number">20</span>:	e022                	sd	s0,<span class="number">0</span>(sp)</span><br><span class="line">  <span class="number">22</span>:	<span class="number">0800</span>                	addi	s0,sp,<span class="number">16</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="number">24</span>:	<span class="number">4635</span>                	li	a2,<span class="number">13</span>   </span><br><span class="line">  <span class="number">26</span>:	<span class="number">45b</span>1                	li	a1,<span class="number">12</span></span><br><span class="line">  <span class="number">28</span>:	<span class="number">00000517</span>          	auipc	a0,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>c:	<span class="number">75050513</span>          	addi	a0,a0,<span class="number">1872</span> # <span class="number">778</span> &lt;<span class="built_in">malloc</span>+<span class="number">0xea</span>&gt;</span><br><span class="line">  <span class="number">30</span>:	<span class="number">00000097</span>          	auipc	ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">34</span>:	<span class="number">5</span>a0080e7          	jalr	<span class="number">1440</span>(ra) # <span class="number">5</span>d0 &lt;<span class="built_in">printf</span>&gt;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="number">38</span>:	<span class="number">4501</span>                	li	a0,<span class="number">0</span></span><br><span class="line">  <span class="number">3</span>a:	<span class="number">00000097</span>          	auipc	ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">3</span>e:	<span class="number">1f</span>e080e7          	jalr	<span class="number">510</span>(ra) # <span class="number">238</span> &lt;<span class="built_in">exit</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">... lines omitted</span><br><span class="line"></span><br><span class="line"><span class="number">00000000000005</span>d0 &lt;<span class="built_in">printf</span>&gt;:</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>下面来回答问题：</p>
<ol>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<ul>
<li>根据 riscv user-level isa （在 <code>doc/riscv-calling.pdf</code>） ， a0-a7 和 fa0-fa7 共计 16 个寄存器会用于传递参数</li>
<li>具体而言，根据以上代码，可以得知 a2 寄存器用于存传给 printf 的参数 <code>13</code></li>
</ul>
</li>
<li>Where is the function call to f from main? Where is the call to g? (Hint: the compiler may inline functions.)<ul>
<li>注意括号里的话。根据笔算我们知道 <code>f(8)+1 = 12</code>，又发现 main 中并未调用 f 函数，说明 f 在编译期被直接优化成一个常量 <code>12</code> 塞到 a1 寄存器里了。</li>
</ul>
</li>
<li>At what address is the function printf located?<ul>
<li>观察 main 函数，在调用时使用了代码 <code>auipc ra,0x0</code> 和 <code>jalr 1440(ra)</code>，前者取当前指令的 pc 加上 0x0 存入 ra，后者跳转到 ra + 1440。计算知 <code>0x0000000000000030 + 1440 = 0x00000000000005d0</code>。经验证是 printf 的入口地址。</li>
</ul>
</li>
<li>What value is in the register ra just after the jalr to printf in main?<ul>
<li>此题需要看 rv spec 。<code>jalr</code> 指令完成后，<code>ra</code> 寄存器会存储返回点位置（也即 pc + 4 ）</li>
</ul>
</li>
</ol>
<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>In this exercise you will design the context switch mechanism for a user-level threading system, and then implement it. Your job is to come up with a plan to create threads and save/restore registers to switch between threads, and implement that plan.</p>
<p>You should complete <code>thread_create</code> to create a properly initialized thread so that when the scheduler switches to that thread for the first time, <code>thread_switch</code> returns to the function passed as argument <code>func</code>, running on the thread’s stack. You will have to decide where to save/restore registers. <em>Several solutions are possible.</em> You are allowed to modify struct thread. You’ll need to add a call to <code>thread_switch</code> in <code>thread_schedule</code>; you can pass whatever arguments you need to <code>thread_switch</code>, but the intent is to switch from thread <code>t</code> to the <code>next_thread</code>.</p>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p><code>thread_switch</code> needs to save/restore only the callee-save registers. Why? 这是因为协程切换的过程本质是一个函数调用，因此 <code>caller-save registers</code> 是被调用者（如 <code>thread_a()</code> ）保存好的。</p>
</li>
<li><p>You can add fields to <code>struct thread</code> into which to save registers.</p>
</li>
<li><p>You can see the assembly code for uthread in user/uthread.asm, which may be handy for debugging.</p>
</li>
<li><p>To test your code it might be helpful to single step through your <code>thread_switch</code> using <code>riscv64-linux-gnu-gdb</code>. You can get started in this way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   (gdb) file user/_uthread</span><br><span class="line">&gt;   Reading symbols from user/_uthread...</span><br><span class="line">&gt;   (gdb) b thread.c:60</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  This sets a breakpoint at a specified line in thread.c. The breakpoint may (or may not) be triggered before you even run <code>uthread</code>. How could that happen?</p>
<p>  Once your xv6 shell runs, type “uthread”, and gdb will break at line <code>thread_switch</code>. Now you can type commands like the following to inspect the state of <code>uthread</code>:  <code>(gdb) p/x *next_thread</code> </p>
<p>  With “x”, you can examine the content of a memory location: <code>(gdb) x/x next_thread-&gt;stack</code></p>
<p>  You can single step assembly instructions using: <code>(gdb) si</code></p>
<p>  On-line documentation for gdb is <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<p>然后我们研究以下代码该怎么写（抄）：</p>
<ol>
<li>首先打开 <code>kernel/swtch.S</code> ，查阅 riscv calling convention ，验证这段代码可以完成寄存器的切换。注意 ra 表示返回地址，sp 表示当前栈顶。直接复制到 <code>user/uthread_switch.S</code> 即可。<ol>
<li>接着在 <code>kernel/proc.h</code> 中，找到上述代码配套的 <code>context</code> 结构体声明，复制到 <code>user/uthread.c</code> 中。</li>
</ol>
</li>
<li>修改几行代码。当发生协程切换时调用 <code>uthread_switch(old_ctx, new_ctx)</code>，完成寄存器状态的切换；当新建协程时，将 ra 设为协程入口点地址，sp 设为 <code>thread.stack</code> 的最高地址（栈底）。</li>
</ol>
<p>第三部相对有思维量的代码如下，可以证明是正确的：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;ctx.ra = (uint64) func;</span><br><span class="line">t-&gt;ctx.sp = (uint64) (&amp;t-&gt;<span class="built_in">stack</span>) + STACK_SIZE;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>投币</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Stardust567 微信">
        <p>微信</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Stardust567 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Stardust567
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://stardust567.github.io/post/ffeb.html" title="MIT 6.828">https://stardust567.github.io/post/ffeb.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议，转载请务必署名，欢迎邮件私我讨论交流。
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/GAP/" rel="tag"><i class="fa fa-tag"></i> GAP</a>
          
            <a href="/tags/OS/" rel="tag"><i class="fa fa-tag"></i> OS</a>
          
            <a href="/tags/MIT/" rel="tag"><i class="fa fa-tag"></i> MIT</a>
          
            <a href="/tags/6-828/" rel="tag"><i class="fa fa-tag"></i> 6.828</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/ddca.html" rel="next" title="Linux I/O">
                <i class="fa fa-chevron-left"></i> Linux I/O
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/84d.html" rel="prev" title="SSL协议">
                SSL协议 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Stardust567</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建xv6"><span class="nav-number">1.1.</span> <span class="nav-text">构建xv6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#syscall"><span class="nav-number">1.2.</span> <span class="nav-text">syscall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep"><span class="nav-number">1.3.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pingpong"><span class="nav-number">1.4.</span> <span class="nav-text">pingpong</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#primes"><span class="nav-number">1.5.</span> <span class="nav-text">primes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find"><span class="nav-number">1.6.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs"><span class="nav-number">1.7.</span> <span class="nav-text">xargs</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Simple-xv6-shell"><span class="nav-number">2.</span> <span class="nav-text">Simple xv6 shell</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Allocator-for-xv6"><span class="nav-number">3.</span> <span class="nav-text">Allocator for xv6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task1"><span class="nav-number">3.1.</span> <span class="nav-text">Task1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-ftable"><span class="nav-number">3.1.1.</span> <span class="nav-text">struct ftable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filealloc"><span class="nav-number">3.1.2.</span> <span class="nav-text">filealloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fileclose"><span class="nav-number">3.1.3.</span> <span class="nav-text">fileclose()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task2"><span class="nav-number">3.2.</span> <span class="nav-text">Task2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xv6-lazy-page-allocation"><span class="nav-number">4.</span> <span class="nav-text">xv6 lazy page allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Print-page-table"><span class="nav-number">4.1.</span> <span class="nav-text">Print page table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eliminate-allocation-from-sbrk"><span class="nav-number">4.2.</span> <span class="nav-text">Eliminate allocation from sbrk()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lazy-allocation"><span class="nav-number">4.3.</span> <span class="nav-text">Lazy allocation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multithreading"><span class="nav-number">5.</span> <span class="nav-text">Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用"><span class="nav-number">5.1.</span> <span class="nav-text">多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xv6进程切换"><span class="nav-number">5.1.1.</span> <span class="nav-text">xv6进程切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Warmup-RISC-V-assembly"><span class="nav-number">5.2.</span> <span class="nav-text">Warmup: RISC-V assembly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Uthread-switching-between-threads"><span class="nav-number">5.3.</span> <span class="nav-text">Uthread: switching between threads</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stardust567</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bABdvcserWST8hctdXncW0he-gzGzoHsz',
        appKey: 'Ng2B24N8TgiGzK8fKds99MLc',
        placeholder: '谢谢你认真看到了最后，这里欢迎各种吐槽与交流：',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("bABdvcserWST8hctdXncW0he-gzGzoHsz", "Ng2B24N8TgiGzK8fKds99MLc");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  
  

  
  


  

  

</body>
</html>
