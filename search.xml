<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F12%2F09%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[2018/2/20不知道现在的自己所思考的究竟和以前的自己所想的有多少出入。也不知道现在自己所坚持的和以前的自己有多少区别。能做的，只有坚信着未来不断前进。未来是一个闪着光的字眼，闪着一种叫希望的光。怀着希望是最悲伤的事情，因为希望，所以要不断支撑着自己向前爬行。怀着希望是最幸福的事情，因为希望，所以赌上一切只是为了几近虚妄的“光明的未来”。仿佛抓住了那片幻想中的光明，就能得到救赎，可以宽恕一切不希望发生的过去，或者说，给那些过去安排了一个合适到完美的理由。但是每个人心底都清楚得很，光，哪是人可以抓住的？于是乎，又给了自己一个超脱“人”这个范畴的动机与理由。直到最终面目全非，披着“人”的幌子留给光鲜而已。2018/11/22时间：2018/11/21, 2018/11/22地点：成都 成华 成电沙河校区云被层惨白朦胧的画布压在头顶，每个人都揣着心事来来往往地走，步伐像守更人沉默的敲击，敲着没人在意的，新一天的到来。云层变稀，不再是之前阴郁的惨白，像是有人舀了一勺糖水和了进去，如果可以戳得到的话，说不定还会有点黏？云层慢慢像雾一样散开，淡淡的玉色中晕开了几滴月白。云层被慢慢撕开来，像是小时候吃棉花糖的时间总喜欢偏着头看着它拔丝。被撕开的云丝终于盖不住藏在它下面的那抹浅蓝，是种小小的，软软的浅蓝。而等那片天的云完全被撕开后的蓝，很好看，也很耐看。不像是之前在藏区见到的蓝宝石般纯净冷冽的惊艳，是那种很温柔，很舒服的蓝，真的很喜欢了。 2018/12/7 节气：大雪今天成都空气所有的寒意和水汽，都肯定是芜湖的初雪化开的，不然怎么这么的刻骨铭心。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort]]></title>
    <url>%2F2018%2F12%2F09%2FSort%2F</url>
    <content type="text"><![CDATA[快排（nlogn）：将列表以首元(a[0])为判断依据隔成两部分,第一部分全部小于首元，第二部分全部大于等于首元。（复杂度n）重复上述过程至所有元素（次数为logn） void quick_sort(int a[],int low,int high); int find_pos(int a[],int low,int high); 希尔（nlogn）：将列表以不同的步长进行划分，常用n/2不断划分至步长为1。每次划分后将各子列表排序即可。希尔复杂度最优时为1.3n，分析起来好像有点复杂orz void shell_sort(int a[],int n); void step_wise(int a[],int D,int n); 归并（nlogn）：将列表不断二分成两份列表，当分成每个子列表的长度都为1时显然每个子列表都有序（次数logn），然后将有序的两个子列表不断合并并使之有序（复杂度n） void merge_sort(int a[], int b[], int start, int end); void Merge(int a[],int b[], int start, int mid, int end); 堆排（nlogn）：大顶堆（二叉树）的性质是父节点大于子节点，先通过这个性质建个堆。（tips：建堆的时候用完全二叉树的性质a[i]d的左子树为a[2*i]，所以存值从a[1]开始，a[0]用来暂存值就好啦）此时a[1]一定是最大数，将a[1]（堆顶）与末元a[n-1]（最后一个叶节点）交换后将a[n-1]忽略，不进入下次堆排（n–）再将堆的性质恢复（logn），依次进行至堆顶（n） void heap_sort(int a[],int n); void sift(int a[],int r,int n); 排序树（nlogn）：右节点&gt;父节点&gt;左节点，建立后将该二叉树中序遍历即可。 void tree_sort(int a[],int n); void setting(TNode* tree,int x); void tree_order(TNode* tree); 基数排序 (d(n+r))：依次按不同位数（d）进行关键字的比较（需要构建队列（队列大小r）） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179​#include &lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;time.h&gt; typedef struct node&#123; int data; struct node* lc; struct node* rc;&#125;TNode;void quick_sort(int a[],int low,int high);int find_pos(int a[],int low,int high);void shell_sort(int a[],int n);void step_wise(int a[],int D,int n);void choose_sort(int a[],int n);void merge_sort(int a[], int b[], int start, int end);void Merge(int a[],int b[], int start, int mid, int end);void heap_sort(int a[],int n);void sift(int a[],int r,int n);void tree_sort(int a[],int n); TNode* secrach(TNode* tree,int x);void setting(TNode* tree,int x);void tree_order(TNode* tree);int main()&#123; int a[10];int b[10]; srand( (unsigned int)(time(0)) ); for(int i=0;i&lt;10;i++)&#123; a[i]=rand()%100+1; printf("%02d\t",a[i]); &#125;printf("\n"); //quick_sort(a,0,9); //shell_sort(a,10); //choose_sort(a,10); //merge_sort(a,b,0,9); //heap_sort(a,10); //tree_sort(a,10); for(int i=0;i&lt;10;i++) printf("%02d\t",a[i]); &#125;void quick_sort(int a[],int low,int high)&#123; if(low&gt;=high) return; int idx = find_pos(a,low,high); quick_sort(a,low,idx-1); quick_sort(a,idx+1,high);&#125;int find_pos(int a[],int low,int high)&#123; int temp = a[low]; while(low&lt;high)&#123; while(low&lt;high&amp;&amp;a[high]&gt;temp) high--; a[low] = a[high]; while(low&lt;high&amp;&amp;a[low]&lt;=temp) low++; a[high] = a[low]; &#125; a[low] = temp; return low;&#125;void shell_sort(int a[],int n)&#123; int d = n/2; while(d&gt;=1)&#123; step_wise(a,d,n); d = d/2; &#125;&#125;void step_wise(int a[],int D,int n)&#123; for(int d=0;d&lt;D;d++)&#123; for(int i=d+D;i&lt;n;i=i+D)&#123; int temp = a[i];int j=i; for(j=i;j-D&gt;=0;j=j-D)&#123; if(temp&lt;a[j-D]) a[j] = a[j-D]; else break; &#125; a[j] = temp; &#125; &#125;&#125;void choose_sort(int a[],int n)&#123;//选择排序 for (int i = 0;i&lt;n;i++)&#123; for (int j = i;j&lt;n;j++)&#123; if (a[j]&lt;a[i])&#123; int ex = a[i]; a[i] = a[j]; a[j] = ex; &#125; &#125; &#125;&#125;void Merge(int a[],int b[], int start, int mid, int end)&#123;//合并a、b数组并排序 int i = start, j=mid+1, k = start; while(i!=mid+1 &amp;&amp; j!=end+1)&#123; if(a[i] &gt; a[j]) b[k++] = a[j++]; else b[k++] = a[i++]; &#125; while(i != mid+1) b[k++] = a[i++]; while(j != end+1) b[k++] = a[j++]; for(i=start; i&lt;=end; i++) a[i] = b[i];&#125;void merge_sort(int a[], int b[], int start, int end)&#123; if(start &lt; end)&#123; int mid = (start + end) / 2; merge_sort(a, b, start, mid); merge_sort(a, b, mid+1, end); Merge(a, b, start, mid, end); &#125;&#125;void sift(int p[],int r,int n)&#123;//树根p[r]（可能是子树的树根）最值性质被破坏的堆 int k = 2*r; int temp = p[r]; while(k&lt;=n)&#123;//尽力将p[r]沉到最底，以确保整体性质的正确 if(k&lt;n &amp;&amp; p[k+1]&gt;p[k]) k++;//k&lt;n防止k+1越界 if(temp&gt;=p[k]) break; p[r] = p[k];r = k;//先不急交换完p[r]，我们看看p[r]最后能沉到哪 k = 2*r; &#125; p[r] = temp; &#125;void heap_sort(int a[],int n)&#123; n = n+1;int p[n]; for(int i=1;i&lt;n;i++) p[i]=a[i-1]; for(int i=n/2;i&gt;=1;i--) sift(p,i,n); for(int i=n;i&gt;=2;i--)&#123; p[0] = p[1]; p[1] = p[i]; p[i] = p[0]; sift(p,1,i-1); &#125; for(int i=1;i&lt;n;i++) a[i-1]=p[i]; &#125;void tree_sort(int a[],int n)&#123; TNode* tree = (TNode*)malloc(sizeof(TNode)); tree-&gt;lc=NULL;tree-&gt;rc=NULL;tree-&gt;data=a[0]; for(int i=1;i&lt;n;i++) setting(tree,a[i]); tree_order(tree);&#125;TNode* secrach(TNode* tree,int x)&#123; TNode* p; while(tree!=NULL)&#123; if(x&lt;tree-&gt;data)&#123; p=tree;tree=tree-&gt;lc; &#125; else&#123; p=tree;tree=tree-&gt;rc; &#125; &#125; return p;&#125;void setting(TNode* tree,int x)&#123; TNode* p = secrach(tree,x); TNode* q = (TNode*)malloc(sizeof(TNode)); q-&gt;data=x;q-&gt;lc=NULL;q-&gt;rc=NULL; if(p==NULL)&#123; p=q;return; &#125; if(x&lt;p-&gt;data) p-&gt;lc=q; else p-&gt;rc=q; return;&#125;void tree_order(TNode* tree)&#123; if(tree==NULL) return; tree_order(tree-&gt;lc); printf("%02d\t",tree-&gt;data); tree_order(tree-&gt;rc);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的遍历]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[这是一个以邻接表为基础的遍历……1.递归DFS：12345678910111213141516171819202122​int main()&#123; TGraph* G = (TGraph*)malloc(sizeof(TGraph)); graph_init(G);//稍微初始化一下我们的图 int visited[N];for(int i=0;i&lt;N;i++) visited[i]=0; for(int i=0;i&lt;N;i++)&#123; if(visited[i]==0)&#123; DFS(G,visited,i); printf("\n"); &#125; &#125;&#125; void DFS(TGraph* G,int visited[N],int i)&#123; printf("%d ",G-&gt;adjlist[i].vex);visited[i]=1; ENode* p = G-&gt;adjlist[i].next; while(p!=NULL)&#123; if(visited[p-&gt;vex]==0)&#123; DFS(G,visited,p-&gt;vex); &#125; p = p-&gt;next; &#125;&#125; 2.非递归DFS： 12345678910111213141516171819202122232425​void dfs(TGraph* G,int visited[N])&#123; Tqueue* stack = stack_init(G-&gt;nv); for(int i=0;i&lt;G-&gt;nv;i++)&#123; if(visited[i]==1) break; else&#123; stack-&gt;qu[stack-&gt;rear++] = i; visited[i]=1; while(stack-&gt;front!=stack-&gt;rear)&#123; ENode* temp = G-&gt;adjlist[stack-&gt;qu[stack-&gt;rear-1]].next; printf("%d ",stack-&gt;qu[--stack-&gt;rear]); while(1)&#123; if(temp==NULL) break; if(visited[temp-&gt;vex]==0)&#123; stack-&gt;qu[stack-&gt;rear++] = temp-&gt;vex; visited[temp-&gt;vex]=1;break; &#125; temp = temp-&gt;next; &#125; &#125; &#125; &#125; free(stack);&#125; 3.BFS： 123456789101112131415161718192021​void bfs(TGraph* G,int visited[N])&#123; Tqueue* queue = queue_init(G-&gt;nv); for(int i=0;i&lt;G-&gt;nv;i++)&#123; if(visited[i]==1) break; queue-&gt;qu[queue-&gt;rear++%G-&gt;nv] = i;visited[i]=1;//简单地借用一下循环队列的思想 while(queue-&gt;front%G-&gt;nv!=queue-&gt;rear%G-&gt;nv)&#123; ENode* temp = G-&gt;adjlist[queue-&gt;qu[(queue-&gt;front)%G-&gt;nv]].next; printf("%d ",queue-&gt;qu[(queue-&gt;front++)%G-&gt;nv]); while(1)&#123; if(temp==NULL) break; if(visited[temp-&gt;vex]==0)&#123; queue-&gt;qu[queue-&gt;rear++%G-&gt;nv] = temp-&gt;vex; visited[temp-&gt;vex]=1;break; &#125; temp = temp-&gt;next; &#125; &#125; &#125; free(queue);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的储存结构]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[邻接矩阵 邻接表 十字链表 邻接多重表 边集数组1.邻接矩阵（n个结点，构造n*n的矩阵，各点值可达为1，不可达为0） 当我们需要将权重赋在矩阵上时，各点值若可达，则为其权重；不可达则为∞（INT_MAX）；对角元为0 2.邻接表（n个结点，构造有n个首结点的数组，每个首结点拉出一条含该首结点所有可达结点的链表） 12345678910111213141516​typedef struct node&#123; int vex; int cost;//对应VNode到该点的权重 struct node* next;&#125;ENode;typedef struct&#123; int vex; ENode* next;&#125;VNode;typedef struct&#123; VNode adjlist[N]; int nv,ne;&#125;TGraph;​ 3.十字链表（有向图） 相比于邻接表，VNode多开了个指针域让你指向以该点为弧尾的第一个弧结点，便于同时求出度和入度，将原先的TNode变成有两个结点编号和两个指针域（一个指向弧头相同的下一条弧，一个指向弧尾相同的下一条弧）的Vex（弧结点）。 1234567891011121314151617​typedef struct vex&#123; int headvex,tailvex;//弧头（尾）顶点编号 int cost; struct vex* hlink,tlink;//指向弧头（尾）相同的下一条弧&#125;Vex;typedef struct&#123; int data;//存放顶点信息 Vex* firstin;//以该点为弧头的第一个弧结点 Vex* firstout;//以该点为弧尾的第一个弧结点&#125;VNode;typedef struct&#123; VNode orthlist[N]; int nv,ne;&#125;OrthGraph;​ 4.邻接多重表（无向图） 相比于邻接表，VNode不变，将原先的TNode变成有两个结点编号和两个指针域（一个指向下一条依附）的Vex（弧结点） 1234567891011121314151617​typedef struct vex&#123; int ivex,jvex;//依附于该边的两个顶点编号 int cost; struct vex* ilink;//指向下一条依附于顶点ivex的边 struct vex* jlink;//指向下一条依附于顶点jvex的边&#125;Vex;typedef struct&#123; int data;//存放顶点信息 Vex* firstedge;//指向第一条依附于该顶点的边结点&#125;VNode;typedef struct&#123; VNode orthlist[N]; int nv,ne;&#125;OrthGraph;​ （TIPS_对比：十字链表注重对边的操作，而邻接多重表更注重对点的操作） 5.边集数组（类似于三元组） 1234567891011121314151617​typedef struct&#123; int vex; int gno;//连通分量，用于kruskal算法&#125;TVex;typedef struct&#123; int va,vb; int cost; &#125;TEdge;typedef struct&#123; TVex* pv; TEdge* pe; int nv,ne;&#125;TGraph;​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Prime算法（稠密矩阵；邻接矩阵）: 从点0开始不断拉相邻权重最小且不构成回路的点进来（形成一个超点）Kruskal（稀疏矩阵；邻接表）: 在原图中不断找权重最小的边“记录在案”，保证不构成回路（与标记过的点不属于同一连通分量gno）1.Prime算法（稠密矩阵；邻接矩阵） 从点0开始不断拉相邻权重最小且不构成回路的点进来（形成一个超点） 123456789101112131415161718192021222324252627282930313233​void prime(int G[N][N])&#123; Edge edges[N]; for(int i=0;i&lt;N;i++)&#123; edges[i].vex = 0;//表示"0"到各个节点 edges[i].cost = G[0][i];//距离 &#125; edges[0].cost = 0;//距离"0"表示不可达 printf("%d ",edges[0].vex); for(int a=1;a&lt;N;a++)&#123; int k = select(edges); printf("%d(last: %d) ",k,edges[k].vex); edges[k].cost = 0; for(int i=0;i&lt;N;i++)&#123; if(G[k][i]&lt;edges[i].cost)&#123; edges[i].vex = k;//表示到i这个点是从k走更近一点 edges[i].cost = G[k][i]; &#125; &#125; &#125;&#125;int select(Edge edges[])&#123; int val = INT_MAX;int idx = -1; for(int i=0;i&lt;N;i++)&#123; if(edges[i].cost&lt;val&amp;&amp;edges[i].cost&gt;0)&#123; val = edges[i].cost; idx = i; &#125; &#125; return idx;&#125;​ 2.Kruskal（稀疏矩阵；邻接表） 在原图中不断找权重最小的边“记录在案”，保证不构成回路（与标记过的点不属于同一连通分量gno） 12345678910111213141516171819202122​void kruskal(TGraph* G)&#123; heapsort(G);//稍微排个序 int idx=1;int num=0; for(int i=1;i&lt;G-&gt;nv;i++)&#123; while(1)&#123; if(G-&gt;pv[G-&gt;pe[idx].va].gno!=G-&gt;pv[G-&gt;pe[idx].vb].gno)&#123; int a=G-&gt;pv[G-&gt;pe[idx].va].gno,b=G-&gt;pv[G-&gt;pe[idx].vb].gno; for(int j=1;j&lt;idx;j++)&#123; if(G-&gt;pv[G-&gt;pe[j].va].gno==a) G-&gt;pv[G-&gt;pe[j].va].gno=b; if(G-&gt;pv[G-&gt;pe[j].vb].gno==a) G-&gt;pv[G-&gt;pe[j].vb].gno=b; &#125; G-&gt;pv[G-&gt;pe[idx].va].gno=b; printf("%d-%d ",G-&gt;pe[idx].va,G-&gt;pe[idx].vb);break; &#125; else idx++; &#125; idx++; &#125;&#125;​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的最短路径]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Dijkstra : 从点v0开始，不断把距V0距离最小的点拉进超点（注意：权重值一定要是正的）Floyd : 如果i-&gt;k-&gt;j的距离比直接i-&gt;j要短的话，更新一下dist的距离和path的路径1.Dijkstra 从点v0开始，不断把距V0距离最小的点拉进超点（注意：权重值一定要是正的） 123456789101112131415161718192021222324252627282930​void dijkstra(int G[N][N],int v0,int path[],int s[])&#123; int dist[N]; for(int i=0;i&lt;N;i++)&#123; dist[i]=G[v0][i]; if(dist[i]&lt;INT_MAX) path[i]=v0;//记录前驱，即“0” else path[i] = -1; &#125;dist[v0]=-1; for(int a=0;a&lt;N;a++)&#123; int idx=-1,min=INT_MAX; for(int i=0;i&lt;N;i++)&#123; if(dist[i]&gt;0&amp;&amp;dist[i]&lt;min)&#123; idx = i;min = dist[i]; &#125; &#125; if(idx&lt;0) break;s[idx]=min; dist[idx] = -1; for(int i=0;i&lt;N;i++)&#123; if(dist[i]&gt;0&amp;&amp;G[idx][i]!=INT_MAX&amp;&amp;min+G[idx][i]&lt;dist[i])&#123; dist[i]=min+G[idx][i]; path[i] = idx; &#125; &#125; &#125;&#125;void print(int path[N],int s[N])&#123; for(int i=0;i&lt;N;i++) if(path[i]&gt;=0) printf("node :%2d(pre:%2d) s:%d \n",i,path[i],s[i]);&#125;​ 2.Floyd 如果i-&gt;k-&gt;j的距离比直接i-&gt;j要短的话，更新一下dist的距离和path的路径 （特别注意：关于循环的顺序，k一定在最外层循环，不然程序会出现差错，以下为解释） k在最外层保证了每次k变动后会遍历图上所有的点以达成完备的更新。 123456789101112131415161718192021222324​void dist_init(int dist[N][N])&#123; freopen("SP_edge.txt","r",stdin); for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) dist[i][j]=INT_MAX; int va,vb,cost; while(scanf("%d %d %d\n",&amp;va,&amp;vb,&amp;cost)==3) dist[va][vb] = cost; for(int i=0;i&lt;N;i++) dist[i][i] = 0;&#125;void path_init(int path[N][N])&#123; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) path[i][j]=i;&#125;void floyd(int dist[N][N],int path[N][N])&#123; for(int k=0;j&lt;N;j++)&#123; for(int i=0;i&lt;N;i++)&#123; for(int j=0;k&lt;N;k++)&#123; if(dist[i][k]+dist[k][j]&lt;dist[i][j]&amp;&amp;dist[i][k]!=INT_MAX&amp;&amp;dist[k][j]!=INT_MAX)&#123; dist[i][j]=dist[i][k]+dist[k][j];path[i][j]=k; &#125; &#125; &#125; &#125;&#125;​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVLtree]]></title>
    <url>%2F2018%2F12%2F08%2FAVLtree%2F</url>
    <content type="text"><![CDATA[平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 1.引入：在说平衡二叉树之前，我们先需要谈谈二叉排序树，详见我之前在《排序》中所写。当排序树构建出来过于“畸形”，两边不对称，极端一点就是一路下来毫无分叉，那么显然，它的时间复杂度就是n，为了避免这种情况或者说，为了找寻最优情况，我们希望我们构建出来的二叉树可以两边对称平衡一下，使其树的深度为lonn而非n，为此，我们引入平衡二叉树的概念。 2.调整：旋转。当每次插入一个结点后，我们根据这棵树的现状对它进行旋转操作，可以简单的分为： （1）单旋：在A结点的左孩子的左子树或者右孩子的右子树上插入结点。 直接将B结点提上来，再把离A最近的子树滑给A。（2）双旋：在A结点的左孩子的右子树或者右孩子的左子树上插入结点。 直接将C提到A、B之间，再把C的子树分别分给A、B所缺的位置。3.删除： （1）查找：现在平衡树中查找到关键字相同的结点p （2）删除：分以下几种情况： 叶结点：直接删除就好单分支结点：把后面那个孩子结点接上来就好啦双分支结点：把这个双分支结点p的值，用其中序前驱结点q的值替代后，直接删掉结点q]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree]]></title>
    <url>%2F2018%2F12%2F08%2FTree%2F</url>
    <content type="text"><![CDATA[二叉树的编程我觉着可以帮助你学习递归 : )123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;typedef struct node&#123; ElemType data; struct node* lc; struct node* rc; int visit;//真的，如果不是这样写最方便，我也不想直接改掉TNode结构体orz &#125;TNode;typedef struct&#123; TNode** qu; int n; int front; int rear;&#125;Tqueue;TNode* tree_init();//树的初始化void preorder(TNode* tree); //递归遍历void tree_pre(TNode* tree); //非递归遍历void inorder(TNode* tree); void tree_in(TNode* tree); void postorder(TNode* tree); void tree_post(TNode* tree); void level_order(TNode* tree);//层次遍历int tree_nodes(TNode* tree);int tree_leaves(TNode* tree);int tree_depth(TNode* tree);int tree_level(TNode* tree,int x,int* j);//查找int tree_width(TNode* tree);Tqueue* queue_init(int n)&#123; Tqueue* queue = (Tqueue*)malloc(sizeof(Tqueue)); queue-&gt;qu = (TNode**)malloc(sizeof(TNode*)*n); queue-&gt;front = 0; queue-&gt;rear = 0; queue-&gt;n = n; return queue;&#125;int main()&#123; freopen("tree.txt","r",stdin); TNode* tree = tree_init(); preorder(tree);printf("\n");tree_pre(tree);printf("\n"); inorder(tree);printf("\n");tree_in(tree);printf("\n"); postorder(tree);printf("\n");tree_post(tree);printf("\n"); level_order(tree); printf("\nTree leaves: %d\tTree depth: %d\tTree nodes: %d",tree_leaves(tree),tree_depth(tree),tree_nodes(tree)); int num;tree_level(tree,'K',&amp;num);printf("\t'K': %d",num+1); printf("\tTree width: %d",tree_width(tree));&#125; TNode* tree_init()&#123; TNode* tree = (TNode*)malloc(sizeof(TNode)); if(tree==NULL)&#123; printf("tree_init:malloc error."); exit(0); &#125; ElemType a; scanf("%d",&amp;a); if(a==0) tree=NULL; else&#123; tree-&gt;data = a; tree-&gt;visit= 0; tree-&gt;lc = tree_init(); tree-&gt;rc = tree_init(); &#125; return tree; &#125;void preorder(TNode* tree)&#123; if(tree==NULL) return; else&#123; printf("%c ",tree-&gt;data); preorder(tree-&gt;lc); preorder(tree-&gt;rc); &#125;&#125;void tree_pre(TNode* tree)&#123; Tqueue* stack = queue_init(tree_nodes(tree));//假装这是初始化栈的函数 while((stack-&gt;rear!=0)||(tree!=NULL))&#123; if(tree!=NULL)&#123; stack-&gt;qu[stack-&gt;rear++] = tree; printf("%c ",tree-&gt;data); tree = tree-&gt;lc; &#125; else&#123; tree = stack-&gt;qu[--stack-&gt;rear]; tree = tree-&gt;rc; &#125; &#125; free(stack);&#125; void inorder(TNode* tree)&#123; if(tree==NULL) return; else&#123; inorder(tree-&gt;lc); printf("%c ",tree-&gt;data); inorder(tree-&gt;rc); &#125;&#125;void tree_in(TNode* tree)&#123; Tqueue* stack = queue_init(tree_nodes(tree)); while((stack-&gt;rear!=0)||(tree!=NULL))&#123; if(tree!=NULL)&#123; stack-&gt;qu[stack-&gt;rear++] = tree; tree = tree-&gt;lc; &#125; else&#123; tree = stack-&gt;qu[--stack-&gt;rear]; printf("%c ",tree-&gt;data); tree = tree-&gt;rc; &#125; &#125; free(stack);&#125; void postorder(TNode* tree)&#123; if(tree==NULL) return; else&#123; postorder(tree-&gt;lc); postorder(tree-&gt;rc); printf("%c ",tree-&gt;data); &#125;&#125;void tree_post(TNode* tree)&#123; Tqueue* stack = queue_init(tree_nodes(tree)); while((stack-&gt;rear!=0)||(tree!=NULL))&#123; if(tree!=NULL)&#123; if(tree-&gt;visit==0) stack-&gt;qu[stack-&gt;rear++] = tree; tree = tree-&gt;lc; &#125; else&#123; tree = stack-&gt;qu[--stack-&gt;rear]; if(tree-&gt;visit==1) printf("%c ",tree-&gt;data); else&#123; tree-&gt;visit = 1; stack-&gt;qu[stack-&gt;rear++] = tree; &#125; tree = tree-&gt;rc; &#125; &#125; free(stack);&#125; void level_order(TNode* tree)&#123; Tqueue* queue = queue_init(tree_nodes(tree)); queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = tree; while(queue-&gt;front%queue-&gt;n!=queue-&gt;rear%queue-&gt;n)&#123; if(queue-&gt;qu[(queue-&gt;front)%queue-&gt;n]-&gt;lc!=NULL) queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = queue-&gt;qu[(queue-&gt;front)%queue-&gt;n]-&gt;lc; if(queue-&gt;qu[(queue-&gt;front)%queue-&gt;n]-&gt;rc!=NULL) queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = queue-&gt;qu[(queue-&gt;front)%queue-&gt;n]-&gt;rc; printf("%c ",queue-&gt;qu[(queue-&gt;front++)%queue-&gt;n]-&gt;data); &#125; free(queue);&#125;int tree_nodes(TNode* tree)&#123; if(tree==NULL) return 0; int a,b; a = tree_nodes(tree-&gt;lc); b = tree_nodes(tree-&gt;rc); return a+b+1;&#125;int tree_leaves(TNode* tree)&#123; if(tree==NULL) return 0; if(tree-&gt;lc==NULL&amp;&amp;tree-&gt;rc==NULL) return 1; return tree_leaves(tree-&gt;lc)+tree_leaves(tree-&gt;rc);&#125;int tree_depth(TNode* tree)&#123; int dl = 0; int dr = 0; if(tree==NULL) return 0; if(tree-&gt;lc==NULL&amp;&amp;tree-&gt;rc==NULL) return 1; dl = tree_depth(tree-&gt;lc); dr = tree_depth(tree-&gt;rc); return 1+((dl&gt;dr)?dl:dr);&#125;int tree_level(TNode* tree,int x,int *j)&#123; if(tree==NULL) return -1; // 没找到 返回-1； if(tree-&gt;data==x) return *j; int t=++*j; // 层数加1 int ret=tree_level(tree-&gt;lc,x,j); if(ret&gt;0)return ret; //在左子树分支找到 *j=t; //恢复层数 return tree_level(tree-&gt;rc,x,j);&#125;int tree_width(TNode* tree)&#123; if(tree==NULL) return 0; Tqueue* queue = queue_init(tree_nodes(tree)); queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = tree; int width=1; while(true)&#123; int size=queue-&gt;rear-queue-&gt;front;//当前层的节点数 if(size&gt;width) width = size; if(size==0) break; while(size&gt;0)&#123;//如果当前层还有节点就进行下去 TNode* node = queue-&gt;qu[(queue-&gt;front++)%queue-&gt;n];size--; if(node-&gt;lc) queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = node-&gt;lc; if(node-&gt;rc) queue-&gt;qu[queue-&gt;rear++%queue-&gt;n] = node-&gt;rc; &#125; &#125; free(queue); return width;&#125;​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman]]></title>
    <url>%2F2018%2F12%2F08%2FHuffman%2F</url>
    <content type="text"><![CDATA[1.概念：哈夫曼树也称为最优二叉树，是一种带权路径长度最短的二叉树。（树的带权路径长度：树中所有的叶结点的权值乘上其到根结点的路径长度，然后进行加和的结果）哈夫曼树中根结点为第0层，N个权值构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为其层数。树的路径长度是从树根到每一结点的路径长度之和，记为WPL 易证哈夫曼树的WPL是最小的。 2.原理：编码表是通过对源符号出现的概率进行评估的方式得到，出现概率高的符号使用较短的编码，反之则使用较长的编码，由此实现编码后字符串的平均长度的期望值降低，从而达到无损压缩数据的目的。 3.举例：根据文本文件得出45个不同字符，通过所给的函数初始化哈夫曼树，根据45个初始节点完善填充整个（2*n-1 = 89）哈夫曼数组，再根据哈夫曼数组制作密码本，进行文件的压缩（加密）与解压（解密）的功能实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210​#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define LEN 100typedef struct&#123; char ch; int weight;int parent; int lchild;int rchild;&#125;TNode;typedef struct&#123; char ch; char code[LEN];&#125;TCode;typedef struct&#123; char ch; int weight;&#125;TW;void select_subtree(TNode* pht,int n,int* pa,int* pb)&#123; for(int i=0;i&lt;n;i++)&#123; if(pht[i].parent==-1)&#123; *pa = i; break; &#125; &#125; for(int j=*pa+1;j&lt;n;j++)&#123; if(pht[j].parent==-1)&#123; *pb = j; break; &#125; &#125; //printf("\n%d\t%d\t%d\t%d\t",*pa,*pb,pht[*pa].parent,pht[*pb].parent); int temp = *pa; *pa = (pht[*pa].weight&gt;pht[*pb].weight)?*pb:*pa; *pb = (pht[*pb].weight&lt;pht[temp].weight)?temp:*pb; //printf("\n%d\t%d",*pa,*pb); for(int i=0;i&lt;n;i++)&#123; if(pht[i].parent==-1)&#123; if(pht[i].weight &lt; pht[*pa].weight&amp;&amp;i!=*pa&amp;&amp;i!=*pb) &#123;*pb = *pa;*pa = i;&#125; else if(pht[i].weight &lt; pht[*pb].weight&amp;&amp;i!=*pa&amp;&amp;i!=*pb) &#123;*pb = i;&#125; &#125; &#125; //printf("\n%d\t%d",*pa,*pb); &#125;TNode* create_htree(TW weights[],int n)&#123; TNode* pht = (TNode*)malloc(sizeof(TNode)*(2*n-1)); for(int i=0;i&lt;n*2-1;i++)&#123; pht[i].ch = (i&lt;n)?weights[i].ch:' '; pht[i].weight = (i&lt;n)?weights[i].weight:0; pht[i].parent = -1; pht[i].lchild = -1;pht[i].rchild = -1; &#125; int pa,pb; for(int i=n;i&lt;n*2-1;i++)&#123; select_subtree(pht,i,&amp;pa,&amp;pb); pht[pa].parent=i;pht[pb].parent=i; pht[i].lchild = pa;pht[i].rchild = pb; pht[i].weight = pht[pa].weight+pht[pb].weight; //printf("\n%d\t%02d\t%02d\t%02d\t%02d\n",i,pht[i].weight,pht[i].parent,pht[i].lchild,pht[i].rchild); //printf("%d\t%d\n",pht[pht[i].lchild].parent,pht[pht[i].rchild].parent); &#125; return pht;&#125;void encoding(TNode* pht,TCode book[],int n)&#123; char* str = (char*)malloc(n+1); str[n] = '\0'; for(int i=0;i&lt;n;i++)&#123; int idx = i;int j = n; while(pht[idx].parent!=-1)&#123; if(pht[pht[idx].parent].lchild==idx)&#123; j--;str[j]='0'; &#125; if(pht[pht[idx].parent].rchild==idx)&#123; j--;str[j]='1'; &#125; idx = pht[idx].parent; &#125; book[i].ch = pht[i].ch; strcpy(book[i].code,&amp;str[j]); printf("%c : ",book[i].ch); puts(book[i].code); &#125;&#125;void decoding(TNode* pht,char codes[],int n)&#123; freopen("your_love.txt","w",stdout); int i=0,p = 2*n-2; while(codes[i]!='\0')&#123; while(pht[p].lchild!=-1&amp;&amp;pht[p].rchild!=-1)&#123; if(codes[i]=='0') p = pht[p].lchild; else p = pht[p].rchild; i++; &#125; printf("%c",pht[p].ch); p = 2*n-2; &#125; printf("\n"); fclose(stdout); &#125;// 统计字符串text中字符出现的频率，参数n为字符串长度// 返回值为：text中出现的不同种类的字符个数// 副作用：通过指针参数间接返回两个数组，其中：// dict：字符数组，存放 text中出现的不同种类的字符// freq：整型数组，存放 text中出现的不同种类的字符的出现频率 int calc_freq(char text[], int **freq, char **dict, int n)&#123; int i, k, nchar = 0; int * pwght; char * pch; int tokens[256] = &#123;0&#125;; // 根据输入的文本字符串逐一统计字符出现的频率 for(i = 0; i &lt; n; ++i)&#123; tokens[text[i]]++; &#125; // 统计共有多少个相异的字符出现在文本串中 for(i = 0; i &lt; 256; i++)&#123; if( tokens[i] &gt; 0 )&#123; nchar++; &#125; &#125; // 为权重数组分配空间 pwght = (int*)malloc(sizeof(int)*nchar); if( !pwght )&#123; printf("为权重数组分配空间失败！\n"); exit(0); &#125; // 为字符数组（字典）分配空间 pch = (char *)malloc(sizeof(char)*nchar); if( !pch )&#123; printf("为字符数组（字典）分配空间失败！\n"); exit(0); &#125; k = 0; for(i = 0; i &lt; 256; ++i)&#123; if( tokens[i] &gt; 0 )&#123; pwght[k] = tokens[i]; pch[k] = (char)i; //强制类型转换 k++; &#125; &#125; *freq = pwght; *dict = pch; return nchar;&#125; int main()&#123; freopen("love_letter.txt","r",stdin); char* str = (char*)malloc(2000); gets(str); fclose(stdin); int** ch_f = (int**)malloc(4); char**ch_c = (char**)malloc(4); int n = calc_freq(str,ch_f,ch_c,strlen(str)); free(str); TW weights[n]; for(int i=0;i&lt;n;i++)&#123; weights[i].weight = (*ch_f)[i]; weights[i].ch = (*ch_c)[i]; &#125; free(ch_f);free(ch_c); TNode* pht = create_htree(weights,n); TCode codebook[n]; encoding(pht,codebook,n); freopen("love_letter.txt","r",stdin); char* word = (char*)malloc(2000); gets(word); fclose(stdin); freopen("codebook.txt","w",stdout); while(*word!='\0')&#123; for(int i=0;i&lt;n;i++)&#123; if(*word==codebook[i].ch)&#123; for(int j=0;j&lt;strlen(codebook[i].code);j++)&#123; printf("%c",codebook[i].code[j]); &#125; &#125; &#125; word++; &#125; fclose(stdout); //free(word); freopen("codebook.txt","r",stdin); char* codes = (char*)malloc(6000); gets(codes); fclose(stdin); decoding(pht,codes,n); return 0;&#125;​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F12%2F08%2FKMP%2F</url>
    <content type="text"><![CDATA[KMP匹配 普通的查找匹配需要在失配时回溯到失配串第二位继续开始查找是否匹配，复杂度过高。 于是我们想着能不能一次不回头的走到底，针对模式串创建了一个辅助数组（next数组）next数组各个元的值：固定字符串的最长真前缀（第一个字符伊始，但不含最后一个）和最长真后缀相同的长度，以下举例。 n e x t 数 组 各元固定字符串 相同最长前后缀 前后缀相同长度 n e x t [0] a “ ” 0 n e x t [1] ab “ ” 0 n e x t [2] aba “a” 1 n e x t [3] abab “ab” 2 n e x t [4] ababa “aba” 3 n e x t [5] ababab “abab” 4 n e x t [6] abababc “ ” 0 n e x t [7] abababca “a” 1 a b a b a b c a 的 n e x t 数 组 为 ： -1 0 0 1 2 3 4 0 1 因为你的目标串没有必要完全回溯，可以把前面相同的位置掠过，因此有了基于next数组的KMP算法，以下举例： 目标串T：ababaacababbabababca 模式串P：abababca 指针i指向目标串，指针j指向模式串，if（T[i]==P[j]）//匹配成功 i++ , j++//往后继续尝试是否匹配 如果失配，i指针不回溯，j指针回溯（j = next[j]），当回溯到首元时，无法再回溯，继续往后试探 i++ , j++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748​#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct&#123; char *pch; int len;&#125;Tstr;int* KMP(Tstr* T,Tstr* P,int *next)&#123; int i=0,j=0,k=0,m = T-&gt;len,n = P-&gt;len; int num[m]; for(int i=0;i&lt;m;i++) num[i]=0; while(i&lt;=m-n)&#123; //不超过目标串的长度，且i&gt;m-n时不可能存在匹配 while(j==-1||(j&lt;n&amp;&amp;T-&gt;pch[i]==P-&gt;pch[j]))&#123; //只要相同且不超过模式串长度就继续往前走 i++; j++; &#125; if(j==n) num[k++] = (i-n+1);//成功找到一个匹配 j = next[j];//通过next数组回溯模式串，继续寻找匹配 &#125; return num;&#125;int* KMP_next(Tstr* P)&#123; int *next = (int*)malloc(sizeof(int)*(P-&gt;len)); int j=0,k=-1,n = P-&gt;len; next[0] = -1; while(j&lt;n)&#123; if(k==-1||P-&gt;pch[j]==P-&gt;pch[k])&#123; next[j+1] = k+1; j++; k++; &#125; else k = next[k]; &#125; return next; &#125;int* KMP_nextval(Tstr* P)&#123; int* nextval = KMP_next(P); for(int j=1;j&lt;P-&gt;len;j++)&#123; if(P-&gt;pch[j]==P-&gt;pch[nextval[j]]) nextval[j]=nextval[nextval[j]]; &#125; return nextval;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方寸间的茶，骨子里的美]]></title>
    <url>%2F2018%2F12%2F08%2FHello%2F</url>
    <content type="text"><![CDATA[喜欢，从来都是简单随性的，它可能是雨天里脚踏在水坑上清脆的回响和扬起奇妙弧度的水花；也可能是夏日里偶然撞见的白色衬衫和“刺啦”一声打开的汽水罐……这些，是生活在这青葱岁月的我们所定义的喜欢，而在唐宋元明清，一扇又一扇翩跹舞开的帘幕下藏着的，是那个时代的人们心底最敏感、最柔软却又最热烈的喜欢——诗词。便如茶，元稹的“铫煎黄蕊色，婉转曲尘花”是喜欢；高鹗的“瓦铫煮春雪，淡香生古瓷”是喜欢；刘禹锡的“骤雨松声入鼎来，白云满碗花徘徊”是喜欢。每个人的喜欢都是不同的，一千种茶，在品茶者眼里是一千种人生、一千种欢喜。这接下来，我就借用朱海燕老师在《中国茶美学研究》里的一篇文章——《唐宋诗词中茶之“美”的刻画》，浅述一下我个人对于“茶”与“美”的认知与看法，以及流淌在诗词中的那一份微醉的喜欢。 茶形色之美 细如粟粒柔如蕊,肥如云腴壮似笋——茶芽之美 枪旗鸟爪劲姿爽,鹰嘴雀舌展芽叶——芽梢之美 圆如皓月润似玉,方比珪璧芳胜兰——团饼茶之美 茶芽，刚吐露的嫩芽无处不炫耀着她娇嫩诱人的初生姿态，这理当是茶这一植株在其生长的一生中最欢愉最激情向上的阶段，这个阶段表现最突出的便是生命力——那种绿的逼人的翠色，让人生怕它会在你转身的那一刹那“噗啦”一声滴下来，令你不得不着迷似的定在那里，移不开视线。而作为人类文明演变发展的长河中，思绪最为敏感的那一圈人中，在我国唐宋时期，体现的最为明显的便是或风花雪月，或忧国忧民的诗人。他们用他们传世的诗、词、曲勾画着他们当时心底那份敏感纯粹被挑拨得激动不已的时刻。这是个感性的区域，从来就没有个方程中唯一解这样让人觉着安稳，却不禁扫兴的说法。每个人在那一瞬所呈现的感觉是不一样的，同时也是最能展示和区分他们波澜壮阔的内心世界的东西，那就是——想象。想象，这是自人类出生开始就赐予人一生的珍贵的天赋：它是天生的，孩子的想象往往最为干净纯粹，包含了最初始最接近“0”的美好烂漫，而随着世俗的沾染，想象这种东西渐渐被束缚，被怀疑，被丢弃……我个人，或者说，在我这个时期，刚感受着离家两千公里的大一生活的我，愈发地觉得，失去了想象的人，是最为可悲的，因为这应是一个不可逆的过程。但是在这个社会转型的大过渡时期，一个大弯甩过来，荡平了多少人纯真，不切实际却美好异常的想象；甩掉多少人那心底小小的仅存的遵守和天真；一个弯所圈出来的怀疑与自我否定，与其说是辩证性地思考，倒不如说是失去自信地辩解。当桌上的茶叶全部被速溶咖啡取代的时候，不敢说这种前进我能有多讨厌，但我敢说我绝不会喜欢。我更希望的是另一种前进，一种精神上或者说人性上的前进，给我的不再是昂不起的头颅和直不起的脊梁的感觉，不再是没有自信没有底气却还要不断争辩的无力与腻歪，而是一种像茶芽一般喷涌着惊人生命力的饱满姿态，那种骨子里的自信、自知与谦和，真正做到心细如粟，心柔如蕊；神壮似笋，肥如云腴。同时，想象也是后天所培育发展的，一个人所能想象出的事物，起源于这个人从他出生至今所经历的事情，所感悟的美好，所体会的失落，所思考的问题，所接触的人群，所读过的书籍……这一切的一切所综合起来构成了他想象的基石。所以在那个信息不流通的年代，他们游山玩水，他们体验人生；他们“不羡朝入省”，他们“不羡慕登台”；他们感悟不同的风土人情，他们把玩不同的文物古籍；这样的他们用他们一生的所见所闻，所思所感筑成了这座瑰丽的想象宫殿，供我们观赏感叹，找寻在快节奏下的闹市里心灵的一片净土，甚至说是归宿。 接下来，就是两种不同方向的意象美，芽梢和团饼茶。芽梢较尖，一般所代表的是一种灵动的个性；而饼茶较为圆润，讲究的是一种温润的淳善。 枪旗、鸟爪、鹰嘴、雀舌，古人对芽梢的形容无一不将浓郁的生命力赋给了这小巧的尖角，擦亮了一抹惊艳的生命色彩。明明只有两字，却极鲜明地将芽梢的那种“尖”劲儿脆生生地呈现在我们的眼中，茶叶本身的形状只是种客观存在的形态，并不包含融在这两个字里的“灵魂”，无疑，这迸发出强烈生机与共鸣的感受源于诗人自身的灵魂，在诗人的一字一句中，融入了他对于这个世界自然而又感性的认识，每一种感性的认知都单纯而又坦诚地给读者打开了一扇了解作者根源的门，他幼年的纯真或残酷，他少年的幻想或青涩，他成年的欢愉或失落，构成了他对这个自然世界的认知，一字一句中我们都能看见掠过的只属于他的浮窗剪影。由此，在我个人看来，感性的或者说个性的创作是会流传不朽，待人发现的。这样的创作会勾起读者的情绪与回忆，人只有对自己共鸣的作品才会真正的爱不释手，产生一种微妙的专有感与占有欲，先不论对错与后续的影响，但是这个作品无疑会因为这样微妙的感情而传递下去。而这之中传承的不仅是茶叶神态中的神韵，更有一种流淌在华夏血脉里，刻进骨子里的精神，如茶一般，千姿百态，各有各的个性与傲骨。 “圆如皓月润似玉,方比珪璧芳胜兰”，说来这和前两种有着本质上的区别。前两种是茶自然的、原生态的情况，如果说这前两种是原汁原味的生命力的展现，那么，团饼茶就是体现我们中华先辈劳动智慧与蕙质兰心的引喻了。若是按我的想象来看，这团饼茶所代表的，就是古人对“君子”的美好向往与期待了：“圆如皓月润似玉”，象征着君子的温润如玉，包容沉稳；而“方比珪璧芳胜兰”，则象征着君子的清远宁人，秀智兰香。在朱海燕女士的原文中有提到：“形色产生美感其根源是人类在社会实践时对自然形状(包括运动、结构)的把握和运用的过程中，使形色与主体知觉结构的相互适应，从而引起审美愉悦。品读茶诗时，可以感受诗人们对茶形色的审美情趣，而形象的刻画更能激发人们无尽的遐想：麦粒的纤小，枪旗的英姿，雀舌的灵巧，琼蕊的秀丽，圭璧的圆润，紫的高贵、绿的生机、白的纯洁、黄的温馨、黑的凝重，每个意象仿佛就是一幅精妙绝伦的工笔画。”可以说，在茶的形色之美上，古人的诗词将自己的美好祝愿与自身情感全部寓情于“茶”，在品茶的形色中感受诗词的妙韵，在品读诗词中欣赏着茶的形色，将声色与想象融于美之中，清幽的茶与沉香的诗，相互交织构成了现在我们所品味研究的“茶美学”。 茶香之美 香飘九畹清若兰,幽薄芳草得天真——茶香之清幽美 疏香皓齿有余味,更觉鹤心通杳冥——茶香之悠远美 风流气味未染尘,不是人间香味色——茶香之脱俗美 “茶的香气,分为真香和混和香两种,真香是茶自身所具有的香味,混和香是加入香味物与茶的真香混合而形成。不同的茶香各有区别,或甜润馥郁,或清幽淡雅,或高爽持久,或鲜灵沁心,因茶之别而变化无穷。” 著名茶叶专家施兆鹏在其主编的《茶叶审评与检验》一书中，将成品茶香气归纳为九种香气类型：毫香型、嫩香型、花香型、果香型、清香型、甜香型、火香型、陈醇香型、松烟香型。正是因为这些纷繁的香气，些微的不同往往会带给品茶者全然不同的崭新感受，这也是茶香的无穷魅力所在，引起文人墨客的争相赞颂。而除此之外，诗人当时所处的环境和心境对茶香的品味也有很大的影响，想来，吵杂市井里的茶香和幽静庭院里的茶香，给人的感受是绝对不同的。“花笺茗碗香千载，云影波光活一楼”茶香是一个很玄妙的东西，用嗅觉触发想象，便比“形色”来得更为飘忽。 唐代诗人李德裕描写茶香为：“松花飘鼎泛，兰气入瓯轻”。“轻”字形象地表达如兰花般极为清雅的茶香随着茶的烹煮而逐渐散发出来的过程。“香于九畹芳兰气”，茶香清幽如兰，不浓烈，不艳俗，香虽清淡却能随风飘送至数里之外，如此清风傲骨的象征，又有哪一个文人雅士能不受她的诱惑?在我家乡有种被称作“汀溪兰香”的茶叶，因为在生长过程中长期与空谷幽兰相伴随生长，便渐渐浸染上了兰花的那一股幽香，颇受一些文人雅士所推崇，当然也因此这种茶叶的珍品售价极高。先不论其他，就单单这一点便不难看出品茗者们对于兰香是何等的推崇，大概都是向往着《离骚》中“余既滋兰之九畹兮，又树蕙之百亩”生活的吧。 朱海燕老师在原文中所引用的这句“疏香皓齿有余味，更觉鹤心通杳冥”，取自于温庭筠的《西陵道士茶歌》，原诗这样写道： 乳窦溅溅通石脉，绿尘愁草春江色。 涧花入井水味香，山月当人松影直。仙翁白扇霜鸟翎，拂坛夜读黄庭经。 疏香皓齿有余味，更觉鹤心通杳冥。 茶香悠远，这份悠远如烟般萦绕在诗人温庭筠的皓齿舌尖，逐渐在精神上更加地贴近一种通明的无为而治的感觉，在诗人主观上与心中所念的“道”相为贴近。按照我个人的理解，“道法自然”，道修的是自身与自然的连接，并不主张用世间的条条框框来束缚自己。他们的随性而为，他们的无为而治，不是说随意、无节制地放出自身的欲望破坏人常纲理，他们的心不是随意散乱的，而更偏向于一种浑圆透彻的状态，在我个人的想象中，便是种“太极”的姿态，周而往返、浑圆剔透。他们所修的是一种智慧的自然，他们去探寻自然而不改变自然，故因此，与自然更加亲近。这或许也是为什么道家和儒家一样推崇着茶道，甚至有着“以茶入道”的说法与故事。也不知道是茶本身就如此玄妙，还是在人为赋予自身的幻想与寄托之后，才那么地令人着迷。但不管怎样，茶，早已成为我国传统文化一面无可或缺的明镜，映照着华夏五千年的历史变迁与文化发展。 茶味之美 流华无尘净肌骨,疏瀹清味涤心源——茶味之清美 琼蕊甘露贵流霞,灵芽云液胜醍醐——茶味之甘美 茗饮醇滑齿颊香,消尽酲醲爽气来——茶味之爽美 香茗一盏甘与苦,人生百味寓其中——“味外之味” “清”，这个在中国古代美学上留下浓墨重彩的一笔的字。“清”字，《说文解字》之中将其释为“澄水之貌”，意指水澄澈明净的样子。茶味之清，体现于淡。这种淡不是苍白的寡淡，而是“清淡”与“轻淡”。借用朱海燕老师在《中国茶美学研究》中所说，“其味觉是丰富的，味感是微妙的”。我们为了感受清美不妨设想一下，说到清，想到了什么？清雨？这个词最先映入我的脑海，接着便是随之而来的意想。清雨？为什么不是微雨？“落花人独立，微雨燕双飞”第一眼见到小山的词，便觉惊艳，不是李商隐那般华美的惊艳，而是扑面而来的清爽与干净利索。但微雨成丝，连绵不绝，与心中所期待的清美相比，总觉着是差了些味道。不知为何，说到“清雨”，总会有花浮现，大概是那句“清明时节雨纷纷”在脑中洗脑般的刻印所致。“清明时节雨纷纷”的清雨，是带着踏青的美好与春日的生机的。或者说，是带着我对于春雨踏青的印象。在玉珠连丝的春日，伴着雨线划过脸颊的清凉，看着雨水洗过的绿色，陷在其中的我大概分不出到底是“青”还是“清”，但这里的一切和我脑海中浮现的一切，一定都是“美”的概念作为我内心里的某种具象化。 “甘”这一点自不必说，想来在大家心中甜美都是很幸福很美好的存在。而对于茶叶而言，茶味之甘美却又与我们正常情况下所提及的甘美不同，我们在日常生活中喜爱甜食，用化学的眼光来看待是因为甜食中的糖分在于人体接触后发生化学变化造成大量的多巴胺，通过不断的吸收与溶解，多巴胺通过血管流至全身，最后刺激神经致使人体产生亢奋状态，这可能也是我对巧克力那么痴迷的原因之一吧。而茶味的甘美是在于它的回味，先苦后甜，而这种苦后回甘之味才是受古代文人雅士所推崇的，这倒也符合我们中国传统的文化思想观念与美德。“爽”，这里的爽同样和我们现在常说的有些区别，这里所表示的更多是“神清气爽”，现在我们也常听到长辈们说关于醒酒茶的功效，虽然现代科学证明了用茶醒酒是错误的做法，但这也是古代人将茶作为提神醒脑的良药的佐证。按文中所说便是“好茶往往滋味醇爽，入口润滑而不紧涩，饮过之后齿颊留香，提神醒脑，畅意不已，唐宋时任将这种让人通体舒泰的美感谓之‘爽’”。而所谓“味外之味”，简单来说就是借品茶来品味人生。比如苏轼一生坎坷，在“乌台诗案”之后，在儒、道、佛思想的共同影响之下，有着复杂的处事观念，既有儒家忧国忧民的入世之心，又有佛家放空自我的出世之心，同时又在道家的影响下向往自然，寻求与自然的超脱。这三种思想集中在一个人身上，不由显得矛盾而又分裂。为了调和改善这种情况，他把品茶作为沟通自然、内省自性、品味人生、超越自我的载体，将不同的思想通过“茶”这一纽带相互串连。也因如此，茶渐渐成为了他生命中寄思不可缺少的物品。这便是茶之“味”，茶之美的某种体现吧。 茶叶，在唐宋词人的眼中，是寓于自身丰沛情感的寄托，是自己内心世界的写照。茶如明镜，一滴茶水滴落下去，“叮”地激起一圈水纹，荡起一层清绿，随之平静无褶。诗人走到茶水边，先看上那么几眼，看看茶水中荡漾的自己的“形色”，然后不用动上鼻尖，便会闻到自心里溢出来的“茶香”，接着便一头栽进这茶水里，让茶水洗涤着自己的身子和心，去体会最回归与最纯粹的“茶味”，纯粹到令人艳羡。这些，便构成了唐宋诗词中对于“茶”之美的刻画。而这些美，是需要寻着诗词品赏茶、感受茶，将茶带进自己的人生与思考才能真正体会到的美学。希望看到这篇文章的人，都能尝试着去体会中国的茶文化，去感悟这之中蕴藏着的茶美学。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>大一</tag>
        <tag>茶美学</tag>
      </tags>
  </entry>
</search>
